{"version":3,"file":"schema.js","sourceRoot":"","sources":["../../src/type/schema.ts"],"names":[],"mappings":"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","sourcesContent":["import { inspect } from '../jsutils/inspect.js';\nimport { instanceOf } from '../jsutils/instanceOf.js';\nimport type { Maybe } from '../jsutils/Maybe.js';\nimport type { ObjMap } from '../jsutils/ObjMap.js';\nimport { toObjMapWithSymbols } from '../jsutils/toObjMap.js';\n\nimport type { GraphQLError } from '../error/GraphQLError.js';\n\nimport type {\n  SchemaDefinitionNode,\n  SchemaExtensionNode,\n} from '../language/ast.js';\nimport { OperationTypeNode } from '../language/ast.js';\n\nimport type {\n  GraphQLAbstractType,\n  GraphQLCompositeType,\n  GraphQLField,\n  GraphQLInterfaceType,\n  GraphQLNamedType,\n  GraphQLObjectType,\n  GraphQLType,\n} from './definition.js';\nimport {\n  getNamedType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isUnionType,\n} from './definition.js';\nimport type { GraphQLDirective } from './directives.js';\nimport { isDirective, specifiedDirectives } from './directives.js';\nimport {\n  __Schema,\n  SchemaMetaFieldDef,\n  TypeMetaFieldDef,\n  TypeNameMetaFieldDef,\n} from './introspection.js';\n\n/**\n * Test if the given value is a GraphQL schema.\n */\nexport function isSchema(schema: unknown): schema is GraphQLSchema {\n  return instanceOf(schema, GraphQLSchema);\n}\n\nexport function assertSchema(schema: unknown): GraphQLSchema {\n  if (!isSchema(schema)) {\n    throw new Error(`Expected ${inspect(schema)} to be a GraphQL schema.`);\n  }\n  return schema;\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLSchemaExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   query: MyAppQueryRootType,\n *   mutation: MyAppMutationRootType,\n * })\n * ```\n *\n * Note: When the schema is constructed, by default only the types that are\n * reachable by traversing the root types are included, other types must be\n * explicitly referenced.\n *\n * Example:\n *\n * ```ts\n * const characterInterface = new GraphQLInterfaceType({\n *   name: 'Character',\n *   ...\n * });\n *\n * const humanType = new GraphQLObjectType({\n *   name: 'Human',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const droidType = new GraphQLObjectType({\n *   name: 'Droid',\n *   interfaces: [characterInterface],\n *   ...\n * });\n *\n * const schema = new GraphQLSchema({\n *   query: new GraphQLObjectType({\n *     name: 'Query',\n *     fields: {\n *       hero: { type: characterInterface, ... },\n *     }\n *   }),\n *   ...\n *   // Since this schema references only the `Character` interface it's\n *   // necessary to explicitly list the types that implement it if\n *   // you want them to be included in the final schema.\n *   types: [humanType, droidType],\n * })\n * ```\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. `@include` and\n * `@skip`) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n * ```ts\n * const MyAppSchema = new GraphQLSchema({\n *   ...\n *   directives: specifiedDirectives.concat([ myCustomDirective ]),\n * })\n * ```\n */\nexport class GraphQLSchema {\n  description: Maybe<string>;\n  extensions: Readonly<GraphQLSchemaExtensions>;\n  astNode: Maybe<SchemaDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<SchemaExtensionNode>;\n\n  assumeValid: boolean;\n  __validationErrors: Maybe<ReadonlyArray<GraphQLError>>;\n\n  private _queryType: Maybe<GraphQLObjectType>;\n  private _mutationType: Maybe<GraphQLObjectType>;\n  private _subscriptionType: Maybe<GraphQLObjectType>;\n  private _directives: ReadonlyArray<GraphQLDirective>;\n  private _typeMap: TypeMap;\n  private _subTypeMap: Map<\n    GraphQLAbstractType,\n    Set<GraphQLObjectType | GraphQLInterfaceType>\n  >;\n\n  private _implementationsMap: ObjMap<{\n    objects: Array<GraphQLObjectType>;\n    interfaces: Array<GraphQLInterfaceType>;\n  }>;\n\n  constructor(config: Readonly<GraphQLSchemaConfig>) {\n    // If this schema was built from a source known to be valid, then it may be\n    // marked with assumeValid to avoid an additional type system validation.\n    this.assumeValid = config.assumeValid ?? false;\n    // Used as a cache for validateSchema().\n    this.__validationErrors = config.assumeValid === true ? [] : undefined;\n\n    this.description = config.description;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes ?? [];\n\n    this._queryType = config.query;\n    this._mutationType = config.mutation;\n    this._subscriptionType = config.subscription;\n    // Provide specified directives (e.g. @include and @skip) by default.\n    this._directives = config.directives ?? specifiedDirectives;\n\n    // To preserve order of user-provided types, we add first to add them to\n    // the set of \"collected\" types, so `collectReferencedTypes` ignore them.\n    const allReferencedTypes = new Set<GraphQLNamedType>(config.types);\n    if (config.types != null) {\n      for (const type of config.types) {\n        // When we ready to process this type, we remove it from \"collected\" types\n        // and then add it together with all dependent types in the correct position.\n        allReferencedTypes.delete(type);\n        collectReferencedTypes(type, allReferencedTypes);\n      }\n    }\n\n    if (this._queryType != null) {\n      collectReferencedTypes(this._queryType, allReferencedTypes);\n    }\n    if (this._mutationType != null) {\n      collectReferencedTypes(this._mutationType, allReferencedTypes);\n    }\n    if (this._subscriptionType != null) {\n      collectReferencedTypes(this._subscriptionType, allReferencedTypes);\n    }\n\n    for (const directive of this._directives) {\n      // Directives are not validated until validateSchema() is called.\n      if (isDirective(directive)) {\n        for (const arg of directive.args) {\n          collectReferencedTypes(arg.type, allReferencedTypes);\n        }\n      }\n    }\n    collectReferencedTypes(__Schema, allReferencedTypes);\n\n    // Storing the resulting map for reference by the schema.\n    this._typeMap = Object.create(null);\n    this._subTypeMap = new Map();\n    // Keep track of all implementations by interface name.\n    this._implementationsMap = Object.create(null);\n\n    for (const namedType of allReferencedTypes) {\n      if (namedType == null) {\n        continue;\n      }\n\n      const typeName = namedType.name;\n      if (this._typeMap[typeName] !== undefined) {\n        throw new Error(\n          `Schema must contain uniquely named types but contains multiple types named \"${typeName}\".`,\n        );\n      }\n      this._typeMap[typeName] = namedType;\n\n      if (isInterfaceType(namedType)) {\n        // Store implementations by interface.\n        for (const iface of namedType.getInterfaces()) {\n          if (isInterfaceType(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: [],\n              };\n            }\n\n            implementations.interfaces.push(namedType);\n          }\n        }\n      } else if (isObjectType(namedType)) {\n        // Store implementations by objects.\n        for (const iface of namedType.getInterfaces()) {\n          if (isInterfaceType(iface)) {\n            let implementations = this._implementationsMap[iface.name];\n            if (implementations === undefined) {\n              implementations = this._implementationsMap[iface.name] = {\n                objects: [],\n                interfaces: [],\n              };\n            }\n\n            implementations.objects.push(namedType);\n          }\n        }\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLSchema';\n  }\n\n  getQueryType(): Maybe<GraphQLObjectType> {\n    return this._queryType;\n  }\n\n  getMutationType(): Maybe<GraphQLObjectType> {\n    return this._mutationType;\n  }\n\n  getSubscriptionType(): Maybe<GraphQLObjectType> {\n    return this._subscriptionType;\n  }\n\n  getRootType(operation: OperationTypeNode): Maybe<GraphQLObjectType> {\n    switch (operation) {\n      case OperationTypeNode.QUERY:\n        return this.getQueryType();\n      case OperationTypeNode.MUTATION:\n        return this.getMutationType();\n      case OperationTypeNode.SUBSCRIPTION:\n        return this.getSubscriptionType();\n    }\n  }\n\n  getTypeMap(): TypeMap {\n    return this._typeMap;\n  }\n\n  getType(name: string): GraphQLNamedType | undefined {\n    return this.getTypeMap()[name];\n  }\n\n  getPossibleTypes(\n    abstractType: GraphQLAbstractType,\n  ): ReadonlyArray<GraphQLObjectType> {\n    return isUnionType(abstractType)\n      ? abstractType.getTypes()\n      : this.getImplementations(abstractType).objects;\n  }\n\n  getImplementations(interfaceType: GraphQLInterfaceType): {\n    objects: ReadonlyArray<GraphQLObjectType>;\n    interfaces: ReadonlyArray<GraphQLInterfaceType>;\n  } {\n    const implementations = this._implementationsMap[interfaceType.name];\n    return implementations ?? { objects: [], interfaces: [] };\n  }\n\n  isSubType(\n    abstractType: GraphQLAbstractType,\n    maybeSubType: GraphQLObjectType | GraphQLInterfaceType,\n  ): boolean {\n    let set = this._subTypeMap.get(abstractType);\n    if (set === undefined) {\n      if (isUnionType(abstractType)) {\n        set = new Set<GraphQLObjectType>(abstractType.getTypes());\n      } else {\n        const implementations = this.getImplementations(abstractType);\n        set = new Set<GraphQLObjectType | GraphQLInterfaceType>([\n          ...implementations.objects,\n          ...implementations.interfaces,\n        ]);\n      }\n\n      this._subTypeMap.set(abstractType, set);\n    }\n    return set.has(maybeSubType);\n  }\n\n  getDirectives(): ReadonlyArray<GraphQLDirective> {\n    return this._directives;\n  }\n\n  getDirective(name: string): Maybe<GraphQLDirective> {\n    return this.getDirectives().find((directive) => directive.name === name);\n  }\n\n  /**\n   * This method looks up the field on the given type definition.\n   * It has special casing for the three introspection fields, `__schema`,\n   * `__type` and `__typename`.\n   *\n   * `__typename` is special because it can always be queried as a field, even\n   * in situations where no other fields are allowed, like on a Union.\n   *\n   * `__schema` and `__type` could get automatically added to the query type,\n   * but that would require mutating type definitions, which would cause issues.\n   */\n  getField(\n    parentType: GraphQLCompositeType,\n    fieldName: string,\n  ): GraphQLField<unknown, unknown> | undefined {\n    switch (fieldName) {\n      case SchemaMetaFieldDef.name:\n        return this.getQueryType() === parentType\n          ? SchemaMetaFieldDef\n          : undefined;\n      case TypeMetaFieldDef.name:\n        return this.getQueryType() === parentType\n          ? TypeMetaFieldDef\n          : undefined;\n      case TypeNameMetaFieldDef.name:\n        return TypeNameMetaFieldDef;\n    }\n\n    // this function is part \"hot\" path inside executor and check presence\n    // of 'getFields' is faster than to use `!isUnionType`\n    if ('getFields' in parentType) {\n      return parentType.getFields()[fieldName];\n    }\n    return undefined;\n  }\n\n  toConfig(): GraphQLSchemaNormalizedConfig {\n    return {\n      description: this.description,\n      query: this.getQueryType(),\n      mutation: this.getMutationType(),\n      subscription: this.getSubscriptionType(),\n      types: Object.values(this.getTypeMap()),\n      directives: this.getDirectives(),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n      assumeValid: this.assumeValid,\n    };\n  }\n}\n\ntype TypeMap = ObjMap<GraphQLNamedType>;\n\nexport interface GraphQLSchemaValidationOptions {\n  /**\n   * When building a schema from a GraphQL service's introspection result, it\n   * might be safe to assume the schema is valid. Set to true to assume the\n   * produced schema is valid.\n   *\n   * Default: false\n   */\n  assumeValid?: boolean | undefined;\n}\n\nexport interface GraphQLSchemaConfig extends GraphQLSchemaValidationOptions {\n  description?: Maybe<string>;\n  query?: Maybe<GraphQLObjectType>;\n  mutation?: Maybe<GraphQLObjectType>;\n  subscription?: Maybe<GraphQLObjectType>;\n  types?: Maybe<ReadonlyArray<GraphQLNamedType>>;\n  directives?: Maybe<ReadonlyArray<GraphQLDirective>>;\n  extensions?: Maybe<Readonly<GraphQLSchemaExtensions>>;\n  astNode?: Maybe<SchemaDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<SchemaExtensionNode>>;\n}\n\n/**\n * @internal\n */\nexport interface GraphQLSchemaNormalizedConfig extends GraphQLSchemaConfig {\n  description: Maybe<string>;\n  types: ReadonlyArray<GraphQLNamedType>;\n  directives: ReadonlyArray<GraphQLDirective>;\n  extensions: Readonly<GraphQLSchemaExtensions>;\n  extensionASTNodes: ReadonlyArray<SchemaExtensionNode>;\n  assumeValid: boolean;\n}\n\nfunction collectReferencedTypes(\n  type: GraphQLType,\n  typeSet: Set<GraphQLNamedType>,\n): Set<GraphQLNamedType> {\n  const namedType = getNamedType(type);\n\n  if (!typeSet.has(namedType)) {\n    typeSet.add(namedType);\n    if (isUnionType(namedType)) {\n      for (const memberType of namedType.getTypes()) {\n        collectReferencedTypes(memberType, typeSet);\n      }\n    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {\n      for (const interfaceType of namedType.getInterfaces()) {\n        collectReferencedTypes(interfaceType, typeSet);\n      }\n\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n        for (const arg of field.args) {\n          collectReferencedTypes(arg.type, typeSet);\n        }\n      }\n    } else if (isInputObjectType(namedType)) {\n      for (const field of Object.values(namedType.getFields())) {\n        collectReferencedTypes(field.type, typeSet);\n      }\n    }\n  }\n\n  return typeSet;\n}\n"]}