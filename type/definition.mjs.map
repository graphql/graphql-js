{"version":3,"file":"definition.js","sourceRoot":"","sources":["../../src/type/definition.ts"],"names":[],"mappings":"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","sourcesContent":["import { devAssert } from '../jsutils/devAssert.js';\nimport { didYouMean } from '../jsutils/didYouMean.js';\nimport { identityFunc } from '../jsutils/identityFunc.js';\nimport { inspect } from '../jsutils/inspect.js';\nimport { instanceOf } from '../jsutils/instanceOf.js';\nimport { keyMap } from '../jsutils/keyMap.js';\nimport { keyValMap } from '../jsutils/keyValMap.js';\nimport { mapValue } from '../jsutils/mapValue.js';\nimport type { Maybe } from '../jsutils/Maybe.js';\nimport type { ObjMap } from '../jsutils/ObjMap.js';\nimport type { Path } from '../jsutils/Path.js';\nimport type { PromiseOrValue } from '../jsutils/PromiseOrValue.js';\nimport { suggestionList } from '../jsutils/suggestionList.js';\nimport { toObjMapWithSymbols } from '../jsutils/toObjMap.js';\n\nimport { GraphQLError } from '../error/GraphQLError.js';\n\nimport type {\n  ConstValueNode,\n  EnumTypeDefinitionNode,\n  EnumTypeExtensionNode,\n  EnumValueDefinitionNode,\n  FieldDefinitionNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InputObjectTypeDefinitionNode,\n  InputObjectTypeExtensionNode,\n  InputValueDefinitionNode,\n  InterfaceTypeDefinitionNode,\n  InterfaceTypeExtensionNode,\n  ObjectTypeDefinitionNode,\n  ObjectTypeExtensionNode,\n  OperationDefinitionNode,\n  ScalarTypeDefinitionNode,\n  ScalarTypeExtensionNode,\n  UnionTypeDefinitionNode,\n  UnionTypeExtensionNode,\n  ValueNode,\n} from '../language/ast.js';\nimport { Kind } from '../language/kinds.js';\nimport { print } from '../language/printer.js';\n\nimport type { GraphQLVariableSignature } from '../execution/getVariableSignature.js';\nimport type { VariableValues } from '../execution/values.js';\n\nimport { valueFromASTUntyped } from '../utilities/valueFromASTUntyped.js';\n\nimport { assertEnumValueName, assertName } from './assertName.js';\nimport type { GraphQLDirective } from './directives.js';\nimport type { GraphQLSchema } from './schema.js';\n\n// Predicates & Assertions\n\n/**\n * These are all of the possible kinds of types.\n */\nexport type GraphQLType = GraphQLNamedType | GraphQLWrappingType;\n\nexport function isType(type: unknown): type is GraphQLType {\n  return (\n    isScalarType(type) ||\n    isObjectType(type) ||\n    isInterfaceType(type) ||\n    isUnionType(type) ||\n    isEnumType(type) ||\n    isInputObjectType(type) ||\n    isListType(type) ||\n    isNonNullType(type)\n  );\n}\n\nexport function assertType(type: unknown): GraphQLType {\n  if (!isType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL type.`);\n  }\n  return type;\n}\n\n/**\n * There are predicates for each GraphQL schema element.\n */\nexport function isScalarType(type: unknown): type is GraphQLScalarType {\n  return instanceOf(type, GraphQLScalarType);\n}\n\nexport function assertScalarType(type: unknown): GraphQLScalarType {\n  if (!isScalarType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Scalar type.`);\n  }\n  return type;\n}\n\nexport function isObjectType(type: unknown): type is GraphQLObjectType {\n  return instanceOf(type, GraphQLObjectType);\n}\n\nexport function assertObjectType(type: unknown): GraphQLObjectType {\n  if (!isObjectType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Object type.`);\n  }\n  return type;\n}\n\nexport function isField(field: unknown): field is GraphQLField {\n  return instanceOf(field, GraphQLField);\n}\n\nexport function assertField(field: unknown): GraphQLField {\n  if (!isField(field)) {\n    throw new Error(`Expected ${inspect(field)} to be a GraphQL field.`);\n  }\n  return field;\n}\n\nexport function isArgument(arg: unknown): arg is GraphQLArgument {\n  return instanceOf(arg, GraphQLArgument);\n}\n\nexport function assertArgument(arg: unknown): GraphQLArgument {\n  if (!isArgument(arg)) {\n    throw new Error(`Expected ${inspect(arg)} to be a GraphQL argument.`);\n  }\n  return arg;\n}\n\nexport function isInterfaceType(type: unknown): type is GraphQLInterfaceType {\n  return instanceOf(type, GraphQLInterfaceType);\n}\n\nexport function assertInterfaceType(type: unknown): GraphQLInterfaceType {\n  if (!isInterfaceType(type)) {\n    throw new Error(\n      `Expected ${inspect(type)} to be a GraphQL Interface type.`,\n    );\n  }\n  return type;\n}\n\nexport function isUnionType(type: unknown): type is GraphQLUnionType {\n  return instanceOf(type, GraphQLUnionType);\n}\n\nexport function assertUnionType(type: unknown): GraphQLUnionType {\n  if (!isUnionType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Union type.`);\n  }\n  return type;\n}\n\nexport function isEnumType(type: unknown): type is GraphQLEnumType {\n  return instanceOf(type, GraphQLEnumType);\n}\n\nexport function assertEnumType(type: unknown): GraphQLEnumType {\n  if (!isEnumType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Enum type.`);\n  }\n  return type;\n}\n\nexport function isEnumValue(value: unknown): value is GraphQLEnumValue {\n  return instanceOf(value, GraphQLEnumValue);\n}\n\nexport function assertEnumValue(value: unknown): GraphQLEnumValue {\n  if (!isEnumValue(value)) {\n    throw new Error(`Expected ${inspect(value)} to be a GraphQL Enum value.`);\n  }\n  return value;\n}\n\nexport function isInputObjectType(\n  type: unknown,\n): type is GraphQLInputObjectType {\n  return instanceOf(type, GraphQLInputObjectType);\n}\n\nexport function assertInputObjectType(type: unknown): GraphQLInputObjectType {\n  if (!isInputObjectType(type)) {\n    throw new Error(\n      `Expected ${inspect(type)} to be a GraphQL Input Object type.`,\n    );\n  }\n  return type;\n}\n\nexport function isInputField(field: unknown): field is GraphQLInputField {\n  return instanceOf(field, GraphQLInputField);\n}\n\nexport function assertInputField(field: unknown): GraphQLInputField {\n  if (!isInputField(field)) {\n    throw new Error(`Expected ${inspect(field)} to be a GraphQL input field.`);\n  }\n  return field;\n}\n\nexport function isListType(\n  type: GraphQLInputType,\n): type is GraphQLList<GraphQLInputType>;\nexport function isListType(\n  type: GraphQLOutputType,\n): type is GraphQLList<GraphQLOutputType>;\nexport function isListType(type: unknown): type is GraphQLList<GraphQLType>;\nexport function isListType(type: unknown): type is GraphQLList<GraphQLType> {\n  return instanceOf(type, GraphQLList);\n}\n\nexport function assertListType(type: unknown): GraphQLList<GraphQLType> {\n  if (!isListType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL List type.`);\n  }\n  return type;\n}\n\nexport function isNonNullType(\n  type: GraphQLInputType,\n): type is GraphQLNonNull<GraphQLNullableInputType>;\nexport function isNonNullType(\n  type: GraphQLOutputType,\n): type is GraphQLNonNull<GraphQLNullableOutputType>;\nexport function isNonNullType(\n  type: unknown,\n): type is GraphQLNonNull<GraphQLNullableType>;\nexport function isNonNullType(\n  type: unknown,\n): type is GraphQLNonNull<GraphQLNullableType> {\n  return instanceOf(type, GraphQLNonNull);\n}\n\nexport function assertNonNullType(\n  type: unknown,\n): GraphQLNonNull<GraphQLNullableType> {\n  if (!isNonNullType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Non-Null type.`);\n  }\n  return type;\n}\n\n/**\n * These types may be used as input types for arguments and directives.\n */\nexport type GraphQLNullableInputType =\n  | GraphQLNamedInputType\n  | GraphQLList<GraphQLInputType>;\n\nexport type GraphQLInputType =\n  | GraphQLNullableInputType\n  | GraphQLNonNull<GraphQLNullableInputType>;\n\nexport function isInputType(type: unknown): type is GraphQLInputType {\n  return (\n    isScalarType(type) ||\n    isEnumType(type) ||\n    isInputObjectType(type) ||\n    (isWrappingType(type) && isInputType(type.ofType))\n  );\n}\n\nexport function assertInputType(type: unknown): GraphQLInputType {\n  if (!isInputType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL input type.`);\n  }\n  return type;\n}\n\n/**\n * These types may be used as output types as the result of fields.\n */\nexport type GraphQLNullableOutputType =\n  | GraphQLNamedOutputType\n  | GraphQLList<GraphQLOutputType>;\n\nexport type GraphQLOutputType =\n  | GraphQLNullableOutputType\n  | GraphQLNonNull<GraphQLNullableOutputType>;\n\nexport function isOutputType(type: unknown): type is GraphQLOutputType {\n  return (\n    isScalarType(type) ||\n    isObjectType(type) ||\n    isInterfaceType(type) ||\n    isUnionType(type) ||\n    isEnumType(type) ||\n    (isWrappingType(type) && isOutputType(type.ofType))\n  );\n}\n\nexport function assertOutputType(type: unknown): GraphQLOutputType {\n  if (!isOutputType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL output type.`);\n  }\n  return type;\n}\n\n/**\n * These types may describe types which may be leaf values.\n */\nexport type GraphQLLeafType = GraphQLScalarType | GraphQLEnumType;\n\nexport function isLeafType(type: unknown): type is GraphQLLeafType {\n  return isScalarType(type) || isEnumType(type);\n}\n\nexport function assertLeafType(type: unknown): GraphQLLeafType {\n  if (!isLeafType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL leaf type.`);\n  }\n  return type;\n}\n\n/**\n * These types may describe the parent context of a selection set.\n */\nexport type GraphQLCompositeType =\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLUnionType;\n\nexport function isCompositeType(type: unknown): type is GraphQLCompositeType {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\n\nexport function assertCompositeType(type: unknown): GraphQLCompositeType {\n  if (!isCompositeType(type)) {\n    throw new Error(\n      `Expected ${inspect(type)} to be a GraphQL composite type.`,\n    );\n  }\n  return type;\n}\n\n/**\n * These types may describe the parent context of a selection set.\n */\nexport type GraphQLAbstractType = GraphQLInterfaceType | GraphQLUnionType;\n\nexport function isAbstractType(type: unknown): type is GraphQLAbstractType {\n  return isInterfaceType(type) || isUnionType(type);\n}\n\nexport function assertAbstractType(type: unknown): GraphQLAbstractType {\n  if (!isAbstractType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL abstract type.`);\n  }\n  return type;\n}\n\n/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n * ```ts\n * const PersonType = new GraphQLObjectType({\n *   name: 'Person',\n *   fields: () => ({\n *     parents: { type: new GraphQLList(PersonType) },\n *     children: { type: new GraphQLList(PersonType) },\n *   })\n * })\n * ```\n */\nexport class GraphQLList<T extends GraphQLType>\n  implements GraphQLSchemaElement\n{\n  readonly ofType: T;\n\n  constructor(ofType: T) {\n    this.ofType = ofType;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLList';\n  }\n\n  toString(): string {\n    return '[' + String(this.ofType) + ']';\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\n/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n * ```ts\n * const RowType = new GraphQLObjectType({\n *   name: 'Row',\n *   fields: () => ({\n *     id: { type: new GraphQLNonNull(GraphQLString) },\n *   })\n * })\n * ```\n * Note: the enforcement of non-nullability occurs within the executor.\n */\nexport class GraphQLNonNull<T extends GraphQLNullableType>\n  implements GraphQLSchemaElement\n{\n  readonly ofType: T;\n\n  constructor(ofType: T) {\n    this.ofType = ofType;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLNonNull';\n  }\n\n  toString(): string {\n    return String(this.ofType) + '!';\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\n/**\n * These types wrap and modify other types\n */\n\nexport type GraphQLWrappingType =\n  | GraphQLList<GraphQLType>\n  | GraphQLNonNull<GraphQLNullableType>;\n\nexport function isWrappingType(type: unknown): type is GraphQLWrappingType {\n  return isListType(type) || isNonNullType(type);\n}\n\nexport function assertWrappingType(type: unknown): GraphQLWrappingType {\n  if (!isWrappingType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL wrapping type.`);\n  }\n  return type;\n}\n\n/**\n * These types can all accept null as a value.\n */\nexport type GraphQLNullableType = GraphQLNamedType | GraphQLList<GraphQLType>;\n\nexport function isNullableType(type: unknown): type is GraphQLNullableType {\n  return isType(type) && !isNonNullType(type);\n}\n\nexport function assertNullableType(type: unknown): GraphQLNullableType {\n  if (!isNullableType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL nullable type.`);\n  }\n  return type;\n}\n\nexport function getNullableType(type: undefined | null): void;\nexport function getNullableType<T extends GraphQLNullableType>(\n  type: T | GraphQLNonNull<T>,\n): T;\nexport function getNullableType(\n  type: Maybe<GraphQLType>,\n): GraphQLNullableType | undefined;\nexport function getNullableType(\n  type: Maybe<GraphQLType>,\n): GraphQLNullableType | undefined {\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n\n/**\n * These named types do not include modifiers like List or NonNull.\n */\nexport type GraphQLNamedType = GraphQLNamedInputType | GraphQLNamedOutputType;\n\nexport type GraphQLNamedInputType =\n  | GraphQLScalarType\n  | GraphQLEnumType\n  | GraphQLInputObjectType;\n\nexport type GraphQLNamedOutputType =\n  | GraphQLScalarType\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLUnionType\n  | GraphQLEnumType;\n\nexport function isNamedType(type: unknown): type is GraphQLNamedType {\n  return (\n    isScalarType(type) ||\n    isObjectType(type) ||\n    isInterfaceType(type) ||\n    isUnionType(type) ||\n    isEnumType(type) ||\n    isInputObjectType(type)\n  );\n}\n\nexport function assertNamedType(type: unknown): GraphQLNamedType {\n  if (!isNamedType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL named type.`);\n  }\n  return type;\n}\n\nexport function getNamedType(type: undefined | null): void;\nexport function getNamedType(type: GraphQLInputType): GraphQLNamedInputType;\nexport function getNamedType(type: GraphQLOutputType): GraphQLNamedOutputType;\nexport function getNamedType(type: GraphQLType): GraphQLNamedType;\nexport function getNamedType(\n  type: Maybe<GraphQLType>,\n): GraphQLNamedType | undefined;\nexport function getNamedType(\n  type: Maybe<GraphQLType>,\n): GraphQLNamedType | undefined {\n  if (type) {\n    let unwrappedType = type;\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n    return unwrappedType;\n  }\n}\n\n/**\n * An interface for all Schema Elements.\n */\n\nexport interface GraphQLSchemaElement {\n  toString: () => string;\n  toJSON: () => string;\n}\n\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\nexport type ThunkReadonlyArray<T> = (() => ReadonlyArray<T>) | ReadonlyArray<T>;\nexport type ThunkObjMap<T> = (() => ObjMap<T>) | ObjMap<T>;\n\nexport function resolveReadonlyArrayThunk<T>(\n  thunk: ThunkReadonlyArray<T>,\n): ReadonlyArray<T> {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n\nexport function resolveObjMapThunk<T>(thunk: ThunkObjMap<T>): ObjMap<T> {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLScalarTypeExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's coerceOutputValue function returns `null` or does not return a\n * value (i.e. it returns `undefined`) then an error will be raised and a\n * `null` value will be returned in the response. It is always better to\n * validate.\n *\n * Example:\n *\n * ```ts\n * function ensureOdd(value) {\n *   if (!Number.isFinite(value)) {\n *     throw new Error(\n *       `Scalar \"Odd\" cannot represent \"${value}\" since it is not a finite number.`,\n *     );\n *   }\n *\n *   if (value % 2 === 0) {\n *     throw new Error(`Scalar \"Odd\" cannot represent \"${value}\" since it is even.`);\n *   }\n * }\n *\n * const OddType = new GraphQLScalarType({\n *   name: 'Odd',\n *   coerceOutputValue(value) {\n *     return ensureOdd(value);\n *   },\n *   coerceInputValue(value) {\n *     return ensureOdd(value);\n *   }\n *   valueToLiteral(value) {\n *    return parse(`${ensureOdd(value)`);\n *   }\n * });\n * ```\n *\n * Custom scalars behavior is defined via the following functions:\n *\n *  - coerceOutputValue(value): Implements \"Result Coercion\". Given an internal value,\n *    produces an external value valid for this type. Returns undefined or\n *    throws an error to indicate invalid values.\n *\n *  - coerceInputValue(value): Implements \"Input Coercion\" for values. Given an\n *    external value (for example, variable values), produces an internal value\n *    valid for this type. Returns undefined or throws an error to indicate\n *    invalid values.\n *\n *  - coerceInputLiteral(ast): Implements \"Input Coercion\" for constant literals.\n *    Given an GraphQL literal (AST) (for example, an argument value), produces\n *    an internal value valid for this type. Returns undefined or throws an\n *    error to indicate invalid values.\n *\n *  - valueToLiteral(value): Converts an external value to a GraphQL\n *    literal (AST). Returns undefined or throws an error to indicate\n *    invalid values.\n *\n *  Deprecated, to be removed in v18:\n *\n *  - serialize(value): Implements \"Result Coercion\". Renamed to\n *    `coerceOutputValue()`.\n *\n *  - parseValue(value): Implements \"Input Coercion\" for values. Renamed to\n *    `coerceInputValue()`.\n *\n *  - parseLiteral(ast): Implements \"Input Coercion\" for literals including\n *    non-specified replacement of variables embedded within complex scalars.\n *    Replaced by the combination of the `replaceVariables()` utility and the\n *    `coerceInputLiteral()` method.\n *\n */\nexport class GraphQLScalarType<TInternal = unknown, TExternal = TInternal>\n  implements GraphQLSchemaElement\n{\n  name: string;\n  description: Maybe<string>;\n  specifiedByURL: Maybe<string>;\n  /** @deprecated use `coerceOutputValue()` instead, `serialize()` will be removed in v18 */\n  serialize: GraphQLScalarSerializer<TExternal>;\n  /** @deprecated use `coerceInputValue()` instead, `parseValue()` will be removed in v18 */\n  parseValue: GraphQLScalarValueParser<TInternal>;\n  /** @deprecated use `replaceVariables()` and `coerceInputLiteral()` instead, `parseLiteral()` will be removed in v18 */\n  parseLiteral: GraphQLScalarLiteralParser<TInternal>;\n  coerceOutputValue: GraphQLScalarOutputValueCoercer<TExternal>;\n  coerceInputValue: GraphQLScalarInputValueCoercer<TInternal>;\n  coerceInputLiteral: GraphQLScalarInputLiteralCoercer<TInternal> | undefined;\n  valueToLiteral: GraphQLScalarValueToLiteral | undefined;\n  extensions: Readonly<GraphQLScalarTypeExtensions>;\n  astNode: Maybe<ScalarTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<ScalarTypeExtensionNode>;\n\n  constructor(config: Readonly<GraphQLScalarTypeConfig<TInternal, TExternal>>) {\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.specifiedByURL = config.specifiedByURL;\n    this.serialize =\n      config.serialize ??\n      config.coerceOutputValue ??\n      (identityFunc as GraphQLScalarSerializer<TExternal>);\n    this.parseValue =\n      config.parseValue ??\n      config.coerceInputValue ??\n      (identityFunc as GraphQLScalarValueParser<TInternal>);\n    this.parseLiteral =\n      config.parseLiteral ??\n      ((node, variables) =>\n        this.coerceInputValue(valueFromASTUntyped(node, variables)));\n    this.coerceOutputValue = config.coerceOutputValue ?? this.serialize;\n    this.coerceInputValue = config.coerceInputValue ?? this.parseValue;\n    this.coerceInputLiteral = config.coerceInputLiteral;\n    this.valueToLiteral = config.valueToLiteral;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes ?? [];\n\n    if (config.parseLiteral) {\n      devAssert(\n        typeof config.parseValue === 'function' &&\n          typeof config.parseLiteral === 'function',\n        `${this.name} must provide both \"parseValue\" and \"parseLiteral\" functions.`,\n      );\n    }\n\n    if (config.coerceInputLiteral) {\n      devAssert(\n        typeof config.coerceInputValue === 'function' &&\n          typeof config.coerceInputLiteral === 'function',\n        `${this.name} must provide both \"coerceInputValue\" and \"coerceInputLiteral\" functions.`,\n      );\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLScalarType';\n  }\n\n  toConfig(): GraphQLScalarTypeNormalizedConfig<TInternal, TExternal> {\n    return {\n      name: this.name,\n      description: this.description,\n      specifiedByURL: this.specifiedByURL,\n      serialize: this.serialize,\n      parseValue: this.parseValue,\n      parseLiteral: this.parseLiteral,\n      coerceOutputValue: this.coerceOutputValue,\n      coerceInputValue: this.coerceInputValue,\n      coerceInputLiteral: this.coerceInputLiteral,\n      valueToLiteral: this.valueToLiteral,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString(): string {\n    return this.name;\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\n/* @deprecated in favor of GraphQLScalarOutputValueCoercer, will be removed in v18 */\nexport type GraphQLScalarSerializer<TExternal> = (\n  outputValue: unknown,\n) => TExternal;\n\nexport type GraphQLScalarOutputValueCoercer<TExternal> = (\n  outputValue: unknown,\n) => TExternal;\n\n/* @deprecated in favor of GraphQLScalarInputValueCoercer, will be removed in v18 */\nexport type GraphQLScalarValueParser<TInternal> = (\n  inputValue: unknown,\n) => TInternal;\n\nexport type GraphQLScalarInputValueCoercer<TInternal> = (\n  inputValue: unknown,\n) => TInternal;\n\n/* @deprecated in favor of GraphQLScalarInputLiteralCoercer, will be removed in v18 */\nexport type GraphQLScalarLiteralParser<TInternal> = (\n  valueNode: ValueNode,\n  variables: Maybe<ObjMap<unknown>>,\n) => Maybe<TInternal>;\n\nexport type GraphQLScalarInputLiteralCoercer<TInternal> = (\n  valueNode: ConstValueNode,\n) => Maybe<TInternal>;\n\nexport type GraphQLScalarValueToLiteral = (\n  inputValue: unknown,\n) => ConstValueNode | undefined;\n\nexport interface GraphQLScalarTypeConfig<TInternal, TExternal> {\n  name: string;\n  description?: Maybe<string>;\n  specifiedByURL?: Maybe<string>;\n  /** Serializes an internal value to include in a response. */\n  /** @deprecated use `coerceOutputValue()` instead, `serialize()` will be removed in v18 */\n  serialize?: GraphQLScalarSerializer<TExternal> | undefined;\n  /** Parses an externally provided value to use as an input. */\n  /** @deprecated use `coerceInputValue()` instead, `parseValue()` will be removed in v18 */\n  parseValue?: GraphQLScalarValueParser<TInternal> | undefined;\n  /** Parses an externally provided literal value to use as an input. */\n  /** @deprecated use `replaceVariables()` and `coerceInputLiteral()` instead, `parseLiteral()` will be removed in v18 */\n  parseLiteral?: GraphQLScalarLiteralParser<TInternal> | undefined;\n  /** Coerces an externally provided value to use as an input. */\n  coerceOutputValue?: GraphQLScalarOutputValueCoercer<TExternal> | undefined;\n  /** Coerces an internal value to include in a response. */\n  coerceInputValue?: GraphQLScalarInputValueCoercer<TInternal> | undefined;\n  /** Coerces an externally provided const literal value to use as an input. */\n  coerceInputLiteral?: GraphQLScalarInputLiteralCoercer<TInternal> | undefined;\n  /** Translates an externally provided value to a literal (AST). */\n  valueToLiteral?: GraphQLScalarValueToLiteral | undefined;\n  extensions?: Maybe<Readonly<GraphQLScalarTypeExtensions>>;\n  astNode?: Maybe<ScalarTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<ScalarTypeExtensionNode>>;\n}\n\nexport interface GraphQLScalarTypeNormalizedConfig<TInternal, TExternal>\n  extends GraphQLScalarTypeConfig<TInternal, TExternal> {\n  serialize: GraphQLScalarSerializer<TExternal>;\n  parseValue: GraphQLScalarValueParser<TInternal>;\n  parseLiteral: GraphQLScalarLiteralParser<TInternal>;\n  coerceOutputValue: GraphQLScalarOutputValueCoercer<TExternal>;\n  coerceInputValue: GraphQLScalarInputValueCoercer<TInternal>;\n  coerceInputLiteral: GraphQLScalarInputLiteralCoercer<TInternal> | undefined;\n  extensions: Readonly<GraphQLScalarTypeExtensions>;\n  extensionASTNodes: ReadonlyArray<ScalarTypeExtensionNode>;\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n *\n * We've provided these template arguments because this is an open type and\n * you may find them useful.\n */\nexport interface GraphQLObjectTypeExtensions<_TSource = any, _TContext = any> {\n  [attributeName: string | symbol]: unknown;\n}\n\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n * ```ts\n * const AddressType = new GraphQLObjectType({\n *   name: 'Address',\n *   fields: {\n *     street: { type: GraphQLString },\n *     number: { type: GraphQLInt },\n *     formatted: {\n *       type: GraphQLString,\n *       resolve(obj) {\n *         return obj.number + ' ' + obj.street\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n * ```ts\n * const PersonType = new GraphQLObjectType({\n *   name: 'Person',\n *   fields: () => ({\n *     name: { type: GraphQLString },\n *     bestFriend: { type: PersonType },\n *   })\n * });\n * ```\n */\nexport class GraphQLObjectType<TSource = any, TContext = any>\n  implements GraphQLSchemaElement\n{\n  name: string;\n  description: Maybe<string>;\n  isTypeOf: Maybe<GraphQLIsTypeOfFn<TSource, TContext>>;\n  extensions: Readonly<GraphQLObjectTypeExtensions<TSource, TContext>>;\n  astNode: Maybe<ObjectTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<ObjectTypeExtensionNode>;\n\n  private _fields: ThunkObjMap<GraphQLField<TSource, TContext>>;\n  private _interfaces: ThunkReadonlyArray<GraphQLInterfaceType>;\n\n  constructor(config: Readonly<GraphQLObjectTypeConfig<TSource, TContext>>) {\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.isTypeOf = config.isTypeOf;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes ?? [];\n    this._fields = (defineFieldMap<TSource, TContext>).bind(\n      undefined,\n      this,\n      config.fields,\n    );\n    this._interfaces = defineInterfaces.bind(undefined, config.interfaces);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLObjectType';\n  }\n\n  getFields(): GraphQLFieldMap<TSource, TContext> {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n    return this._fields;\n  }\n\n  getInterfaces(): ReadonlyArray<GraphQLInterfaceType> {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n    return this._interfaces;\n  }\n\n  toConfig(): GraphQLObjectTypeNormalizedConfig<TSource, TContext> {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: mapValue(this.getFields(), (field) => field.toConfig()),\n      isTypeOf: this.isTypeOf,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString(): string {\n    return this.name;\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\nfunction defineInterfaces(\n  interfaces: Maybe<ThunkReadonlyArray<GraphQLInterfaceType>>,\n): ReadonlyArray<GraphQLInterfaceType> {\n  return resolveReadonlyArrayThunk(interfaces ?? []);\n}\n\nfunction defineFieldMap<TSource, TContext>(\n  parentType:\n    | GraphQLObjectType<TSource, TContext>\n    | GraphQLInterfaceType<TSource, TContext>,\n  fields: ThunkObjMap<GraphQLFieldConfig<TSource, TContext>>,\n): GraphQLFieldMap<TSource, TContext> {\n  const fieldMap = resolveObjMapThunk(fields);\n\n  return mapValue(\n    fieldMap,\n    (fieldConfig, fieldName) =>\n      new GraphQLField(parentType, fieldName, fieldConfig),\n  );\n}\n\nexport interface GraphQLObjectTypeConfig<TSource, TContext> {\n  name: string;\n  description?: Maybe<string>;\n  interfaces?: ThunkReadonlyArray<GraphQLInterfaceType> | undefined;\n  fields: ThunkObjMap<GraphQLFieldConfig<TSource, TContext>>;\n  isTypeOf?: Maybe<GraphQLIsTypeOfFn<TSource, TContext>>;\n  extensions?: Maybe<Readonly<GraphQLObjectTypeExtensions<TSource, TContext>>>;\n  astNode?: Maybe<ObjectTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<ObjectTypeExtensionNode>>;\n}\n\nexport interface GraphQLObjectTypeNormalizedConfig<TSource, TContext>\n  extends GraphQLObjectTypeConfig<any, any> {\n  interfaces: ReadonlyArray<GraphQLInterfaceType>;\n  fields: GraphQLFieldNormalizedConfigMap<any, any>;\n  extensions: Readonly<GraphQLObjectTypeExtensions<TSource, TContext>>;\n  extensionASTNodes: ReadonlyArray<ObjectTypeExtensionNode>;\n}\n\nexport type GraphQLTypeResolver<TSource, TContext> = (\n  value: TSource,\n  context: TContext,\n  info: GraphQLResolveInfo,\n  abstractType: GraphQLAbstractType,\n) => PromiseOrValue<string | undefined>;\n\nexport type GraphQLIsTypeOfFn<TSource, TContext> = (\n  source: TSource,\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => PromiseOrValue<boolean>;\n\nexport type GraphQLFieldResolver<\n  TSource,\n  TContext,\n  TArgs = any,\n  TResult = unknown,\n> = (\n  source: TSource,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo,\n  abortSignal: AbortSignal | undefined,\n) => TResult;\n\nexport interface GraphQLResolveInfo {\n  readonly fieldName: string;\n  readonly fieldNodes: ReadonlyArray<FieldNode>;\n  readonly returnType: GraphQLOutputType;\n  readonly parentType: GraphQLObjectType;\n  readonly path: Path;\n  readonly schema: GraphQLSchema;\n  readonly fragments: ObjMap<FragmentDefinitionNode>;\n  readonly rootValue: unknown;\n  readonly operation: OperationDefinitionNode;\n  readonly variableValues: VariableValues;\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n *\n * We've provided these template arguments because this is an open type and\n * you may find them useful.\n */\nexport interface GraphQLFieldExtensions<_TSource, _TContext, _TArgs = any> {\n  [attributeName: string | symbol]: unknown;\n}\n\nexport interface GraphQLFieldConfig<TSource, TContext, TArgs = any> {\n  description?: Maybe<string>;\n  type: GraphQLOutputType;\n  args?: GraphQLFieldConfigArgumentMap | undefined;\n  resolve?: GraphQLFieldResolver<TSource, TContext, TArgs> | undefined;\n  subscribe?: GraphQLFieldResolver<TSource, TContext, TArgs> | undefined;\n  deprecationReason?: Maybe<string>;\n  extensions?: Maybe<\n    Readonly<GraphQLFieldExtensions<TSource, TContext, TArgs>>\n  >;\n  astNode?: Maybe<FieldDefinitionNode>;\n}\n\nexport interface GraphQLFieldNormalizedConfig<TSource, TContext, TArgs = any>\n  extends GraphQLFieldConfig<TSource, TContext, TArgs> {\n  args: GraphQLFieldNormalizedConfigArgumentMap;\n  extensions: Readonly<GraphQLFieldExtensions<TSource, TContext, TArgs>>;\n}\n\nexport type GraphQLFieldConfigArgumentMap = ObjMap<GraphQLArgumentConfig>;\n\nexport type GraphQLFieldNormalizedConfigArgumentMap =\n  ObjMap<GraphQLArgumentNormalizedConfig>;\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLArgumentExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\nexport interface GraphQLArgumentConfig {\n  description?: Maybe<string>;\n  type: GraphQLInputType;\n  defaultValue?: unknown;\n  defaultValueLiteral?: ConstValueNode | undefined;\n  deprecationReason?: Maybe<string>;\n  extensions?: Maybe<Readonly<GraphQLArgumentExtensions>>;\n  astNode?: Maybe<InputValueDefinitionNode>;\n}\n\nexport interface GraphQLArgumentNormalizedConfig extends GraphQLArgumentConfig {\n  extensions: Readonly<GraphQLArgumentExtensions>;\n}\n\nexport type GraphQLFieldConfigMap<TSource, TContext> = ObjMap<\n  GraphQLFieldConfig<TSource, TContext>\n>;\n\nexport type GraphQLFieldNormalizedConfigMap<TSource, TContext> = ObjMap<\n  GraphQLFieldNormalizedConfig<TSource, TContext>\n>;\n\nexport class GraphQLField<TSource = any, TContext = any, TArgs = any>\n  implements GraphQLSchemaElement\n{\n  parentType:\n    | GraphQLObjectType<TSource, TContext>\n    | GraphQLInterfaceType<TSource, TContext>\n    | undefined;\n  name: string;\n  description: Maybe<string>;\n  type: GraphQLOutputType;\n  args: ReadonlyArray<GraphQLArgument>;\n  resolve?: GraphQLFieldResolver<TSource, TContext, TArgs> | undefined;\n  subscribe?: GraphQLFieldResolver<TSource, TContext, TArgs> | undefined;\n  deprecationReason: Maybe<string>;\n  extensions: Readonly<GraphQLFieldExtensions<TSource, TContext, TArgs>>;\n  astNode: Maybe<FieldDefinitionNode>;\n\n  constructor(\n    parentType:\n      | GraphQLObjectType<TSource, TContext>\n      | GraphQLInterfaceType<TSource, TContext>\n      | undefined,\n    name: string,\n    config: GraphQLFieldConfig<TSource, TContext, TArgs>,\n  ) {\n    this.parentType = parentType;\n    this.name = assertName(name);\n    this.description = config.description;\n    this.type = config.type;\n\n    const argsConfig = config.args;\n    this.args = argsConfig\n      ? Object.entries(argsConfig).map(\n          ([argName, argConfig]) =>\n            new GraphQLArgument(this, argName, argConfig),\n        )\n      : [];\n\n    this.resolve = config.resolve;\n    this.subscribe = config.subscribe;\n    this.deprecationReason = config.deprecationReason;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLField';\n  }\n\n  toConfig(): GraphQLFieldNormalizedConfig<TSource, TContext, TArgs> {\n    return {\n      description: this.description,\n      type: this.type,\n      args: keyValMap(\n        this.args,\n        (arg) => arg.name,\n        (arg) => arg.toConfig(),\n      ),\n      resolve: this.resolve,\n      subscribe: this.subscribe,\n      deprecationReason: this.deprecationReason,\n      extensions: this.extensions,\n      astNode: this.astNode,\n    };\n  }\n\n  toString(): string {\n    return `${this.parentType ?? '<meta>'}.${this.name}`;\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\nexport class GraphQLArgument implements GraphQLSchemaElement {\n  parent: GraphQLField | GraphQLDirective;\n  name: string;\n  description: Maybe<string>;\n  type: GraphQLInputType;\n  defaultValue: GraphQLDefaultValueUsage | undefined;\n  deprecationReason: Maybe<string>;\n  extensions: Readonly<GraphQLArgumentExtensions>;\n  astNode: Maybe<InputValueDefinitionNode>;\n\n  constructor(\n    parent: GraphQLField | GraphQLDirective,\n    name: string,\n    config: GraphQLArgumentConfig,\n  ) {\n    this.parent = parent;\n    this.name = assertName(name);\n    this.description = config.description;\n    this.type = config.type;\n    this.defaultValue = defineDefaultValue(name, config);\n    this.deprecationReason = config.deprecationReason;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLArgument';\n  }\n\n  toConfig(): GraphQLArgumentNormalizedConfig {\n    return {\n      description: this.description,\n      type: this.type,\n      defaultValue: this.defaultValue?.value,\n      defaultValueLiteral: this.defaultValue?.literal,\n      deprecationReason: this.deprecationReason,\n      extensions: this.extensions,\n      astNode: this.astNode,\n    };\n  }\n\n  toString(): string {\n    return `${this.parent}(${this.name}:)`;\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\nexport function isRequiredArgument(\n  arg: GraphQLArgument | GraphQLVariableSignature,\n): boolean {\n  return isNonNullType(arg.type) && arg.defaultValue === undefined;\n}\n\nexport type GraphQLFieldMap<TSource, TContext> = ObjMap<\n  GraphQLField<TSource, TContext>\n>;\n\nexport type GraphQLDefaultValueUsage =\n  | { value: unknown; literal?: never }\n  | { literal: ConstValueNode; value?: never };\n\nexport function defineDefaultValue(\n  argName: string,\n  config: GraphQLArgumentConfig | GraphQLInputFieldConfig,\n): GraphQLDefaultValueUsage | undefined {\n  if (config.defaultValue === undefined && !config.defaultValueLiteral) {\n    return;\n  }\n  devAssert(\n    !(config.defaultValue !== undefined && config.defaultValueLiteral),\n    `Argument \"${argName}\" has both a defaultValue and a defaultValueLiteral property, but only one must be provided.`,\n  );\n  return config.defaultValueLiteral\n    ? { literal: config.defaultValueLiteral }\n    : { value: config.defaultValue };\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLInterfaceTypeExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n * ```ts\n * const EntityType = new GraphQLInterfaceType({\n *   name: 'Entity',\n *   fields: {\n *     name: { type: GraphQLString }\n *   }\n * });\n * ```\n */\nexport class GraphQLInterfaceType<TSource = any, TContext = any>\n  implements GraphQLSchemaElement\n{\n  name: string;\n  description: Maybe<string>;\n  resolveType: Maybe<GraphQLTypeResolver<TSource, TContext>>;\n  extensions: Readonly<GraphQLInterfaceTypeExtensions>;\n  astNode: Maybe<InterfaceTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<InterfaceTypeExtensionNode>;\n\n  private _fields: ThunkObjMap<GraphQLField<TSource, TContext>>;\n  private _interfaces: ThunkReadonlyArray<GraphQLInterfaceType>;\n\n  constructor(config: Readonly<GraphQLInterfaceTypeConfig<TSource, TContext>>) {\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes ?? [];\n    this._fields = (defineFieldMap<TSource, TContext>).bind(\n      undefined,\n      this,\n      config.fields,\n    );\n    this._interfaces = defineInterfaces.bind(undefined, config.interfaces);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLInterfaceType';\n  }\n\n  getFields(): GraphQLFieldMap<TSource, TContext> {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n    return this._fields;\n  }\n\n  getInterfaces(): ReadonlyArray<GraphQLInterfaceType> {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n    return this._interfaces;\n  }\n\n  toConfig(): GraphQLInterfaceTypeNormalizedConfig<TSource, TContext> {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: mapValue(this.getFields(), (field) => field.toConfig()),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString(): string {\n    return this.name;\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\nexport interface GraphQLInterfaceTypeConfig<TSource, TContext> {\n  name: string;\n  description?: Maybe<string>;\n  interfaces?: ThunkReadonlyArray<GraphQLInterfaceType> | undefined;\n  fields: ThunkObjMap<GraphQLFieldConfig<TSource, TContext>>;\n  /**\n   * Optionally provide a custom type resolver function. If one is not provided,\n   * the default implementation will call `isTypeOf` on each implementing\n   * Object type.\n   */\n  resolveType?: Maybe<GraphQLTypeResolver<TSource, TContext>>;\n  extensions?: Maybe<Readonly<GraphQLInterfaceTypeExtensions>>;\n  astNode?: Maybe<InterfaceTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<InterfaceTypeExtensionNode>>;\n}\n\nexport interface GraphQLInterfaceTypeNormalizedConfig<TSource, TContext>\n  extends GraphQLInterfaceTypeConfig<any, any> {\n  interfaces: ReadonlyArray<GraphQLInterfaceType>;\n  fields: GraphQLFieldNormalizedConfigMap<TSource, TContext>;\n  extensions: Readonly<GraphQLInterfaceTypeExtensions>;\n  extensionASTNodes: ReadonlyArray<InterfaceTypeExtensionNode>;\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLUnionTypeExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n * ```ts\n * const PetType = new GraphQLUnionType({\n *   name: 'Pet',\n *   types: [ DogType, CatType ],\n *   resolveType(value) {\n *     if (value instanceof Dog) {\n *       return DogType;\n *     }\n *     if (value instanceof Cat) {\n *       return CatType;\n *     }\n *   }\n * });\n * ```\n */\nexport class GraphQLUnionType implements GraphQLSchemaElement {\n  name: string;\n  description: Maybe<string>;\n  resolveType: Maybe<GraphQLTypeResolver<any, any>>;\n  extensions: Readonly<GraphQLUnionTypeExtensions>;\n  astNode: Maybe<UnionTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<UnionTypeExtensionNode>;\n\n  private _types: ThunkReadonlyArray<GraphQLObjectType>;\n\n  constructor(config: Readonly<GraphQLUnionTypeConfig<any, any>>) {\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes ?? [];\n\n    this._types = defineTypes.bind(undefined, config.types);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLUnionType';\n  }\n\n  getTypes(): ReadonlyArray<GraphQLObjectType> {\n    if (typeof this._types === 'function') {\n      this._types = this._types();\n    }\n    return this._types;\n  }\n\n  toConfig(): GraphQLUnionTypeNormalizedConfig {\n    return {\n      name: this.name,\n      description: this.description,\n      types: this.getTypes(),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString(): string {\n    return this.name;\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\nfunction defineTypes(\n  types: ThunkReadonlyArray<GraphQLObjectType>,\n): ReadonlyArray<GraphQLObjectType> {\n  return resolveReadonlyArrayThunk(types);\n}\n\nexport interface GraphQLUnionTypeConfig<TSource, TContext> {\n  name: string;\n  description?: Maybe<string>;\n  types: ThunkReadonlyArray<GraphQLObjectType>;\n  /**\n   * Optionally provide a custom type resolver function. If one is not provided,\n   * the default implementation will call `isTypeOf` on each implementing\n   * Object type.\n   */\n  resolveType?: Maybe<GraphQLTypeResolver<TSource, TContext>>;\n  extensions?: Maybe<Readonly<GraphQLUnionTypeExtensions>>;\n  astNode?: Maybe<UnionTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<UnionTypeExtensionNode>>;\n}\n\nexport interface GraphQLUnionTypeNormalizedConfig\n  extends GraphQLUnionTypeConfig<any, any> {\n  types: ReadonlyArray<GraphQLObjectType>;\n  extensions: Readonly<GraphQLUnionTypeExtensions>;\n  extensionASTNodes: ReadonlyArray<UnionTypeExtensionNode>;\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLEnumTypeExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL coerces\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n * ```ts\n * const RGBType = new GraphQLEnumType({\n *   name: 'RGB',\n *   values: {\n *     RED: { value: 0 },\n *     GREEN: { value: 1 },\n *     BLUE: { value: 2 }\n *   }\n * });\n * ```\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\nexport class GraphQLEnumType /* <T> */ implements GraphQLSchemaElement {\n  name: string;\n  description: Maybe<string>;\n  extensions: Readonly<GraphQLEnumTypeExtensions>;\n  astNode: Maybe<EnumTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<EnumTypeExtensionNode>;\n\n  private _values:\n    | ReadonlyArray<GraphQLEnumValue /* <T> */>\n    | (() => GraphQLEnumValueConfigMap);\n\n  private _valueLookup: ReadonlyMap<any /* T */, GraphQLEnumValue> | null;\n  private _nameLookup: ObjMap<GraphQLEnumValue> | null;\n\n  constructor(config: Readonly<GraphQLEnumTypeConfig /* <T> */>) {\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes ?? [];\n\n    this._values =\n      typeof config.values === 'function'\n        ? config.values\n        : Object.entries(config.values).map(\n            ([valueName, valueConfig]) =>\n              new GraphQLEnumValue(this, valueName, valueConfig),\n          );\n    this._valueLookup = null;\n    this._nameLookup = null;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLEnumType';\n  }\n\n  getValues(): ReadonlyArray<GraphQLEnumValue /* <T> */> {\n    if (typeof this._values === 'function') {\n      this._values = Object.entries(this._values()).map(\n        ([valueName, valueConfig]) =>\n          new GraphQLEnumValue(this, valueName, valueConfig),\n      );\n    }\n    return this._values;\n  }\n\n  getValue(name: string): Maybe<GraphQLEnumValue> {\n    if (this._nameLookup === null) {\n      this._nameLookup = keyMap(this.getValues(), (value) => value.name);\n    }\n    return this._nameLookup[name];\n  }\n\n  /** @deprecated use `coerceOutputValue()` instead, `serialize()` will be removed in v18 */\n  serialize(outputValue: unknown /* T */): Maybe<string> {\n    return this.coerceOutputValue(outputValue);\n  }\n\n  coerceOutputValue(outputValue: unknown /* T */): Maybe<string> {\n    if (this._valueLookup === null) {\n      this._valueLookup = new Map(\n        this.getValues().map((enumValue) => [enumValue.value, enumValue]),\n      );\n    }\n    const enumValue = this._valueLookup.get(outputValue);\n    if (enumValue === undefined) {\n      throw new GraphQLError(\n        `Enum \"${this.name}\" cannot represent value: ${inspect(outputValue)}`,\n      );\n    }\n    return enumValue.name;\n  }\n\n  /** @deprecated use `coerceInputValue()` instead, `parseValue()` will be removed in v18 */\n  parseValue(\n    inputValue: unknown,\n    hideSuggestions?: Maybe<boolean>,\n  ): Maybe<any> /* T */ {\n    return this.coerceInputValue(inputValue, hideSuggestions);\n  }\n\n  coerceInputValue(\n    inputValue: unknown,\n    hideSuggestions?: Maybe<boolean>,\n  ): Maybe<any> /* T */ {\n    if (typeof inputValue !== 'string') {\n      const valueStr = inspect(inputValue);\n      throw new GraphQLError(\n        `Enum \"${this.name}\" cannot represent non-string value: ${valueStr}.` +\n          (hideSuggestions ? '' : didYouMeanEnumValue(this, valueStr)),\n      );\n    }\n\n    const enumValue = this.getValue(inputValue);\n    if (enumValue == null) {\n      throw new GraphQLError(\n        `Value \"${inputValue}\" does not exist in \"${this.name}\" enum.` +\n          (hideSuggestions ? '' : didYouMeanEnumValue(this, inputValue)),\n      );\n    }\n    return enumValue.value;\n  }\n\n  /** @deprecated use `coerceInputLiteral()` instead, `parseLiteral()` will be removed in v18 */\n  parseLiteral(\n    valueNode: ValueNode,\n    _variables: Maybe<ObjMap<unknown>>,\n    hideSuggestions?: Maybe<boolean>,\n  ): Maybe<any> /* T */ {\n    // Note: variables will be resolved to a value before calling this function.\n    return this.coerceInputLiteral(\n      valueNode as ConstValueNode,\n      hideSuggestions,\n    );\n  }\n\n  coerceInputLiteral(\n    valueNode: ConstValueNode,\n    hideSuggestions?: Maybe<boolean>,\n  ): Maybe<any> /* T */ {\n    if (valueNode.kind !== Kind.ENUM) {\n      const valueStr = print(valueNode);\n      throw new GraphQLError(\n        `Enum \"${this.name}\" cannot represent non-enum value: ${valueStr}.` +\n          (hideSuggestions ? '' : didYouMeanEnumValue(this, valueStr)),\n        { nodes: valueNode },\n      );\n    }\n\n    const enumValue = this.getValue(valueNode.value);\n    if (enumValue == null) {\n      const valueStr = print(valueNode);\n      throw new GraphQLError(\n        `Value \"${valueStr}\" does not exist in \"${this.name}\" enum.` +\n          (hideSuggestions ? '' : didYouMeanEnumValue(this, valueStr)),\n        { nodes: valueNode },\n      );\n    }\n    return enumValue.value;\n  }\n\n  valueToLiteral(value: unknown): ConstValueNode | undefined {\n    if (typeof value === 'string' && this.getValue(value)) {\n      return { kind: Kind.ENUM, value };\n    }\n  }\n\n  toConfig(): GraphQLEnumTypeNormalizedConfig {\n    return {\n      name: this.name,\n      description: this.description,\n      values: keyValMap(\n        this.getValues(),\n        (value) => value.name,\n        (value) => value.toConfig(),\n      ),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString(): string {\n    return this.name;\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\nfunction didYouMeanEnumValue(\n  enumType: GraphQLEnumType,\n  unknownValueStr: string,\n): string {\n  const allNames = enumType.getValues().map((value) => value.name);\n  const suggestedValues = suggestionList(unknownValueStr, allNames);\n\n  return didYouMean('the enum value', suggestedValues);\n}\n\nexport interface GraphQLEnumTypeConfig {\n  name: string;\n  description?: Maybe<string>;\n  values: ThunkObjMap<GraphQLEnumValueConfig /* <T> */>;\n  extensions?: Maybe<Readonly<GraphQLEnumTypeExtensions>>;\n  astNode?: Maybe<EnumTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<EnumTypeExtensionNode>>;\n}\n\nexport interface GraphQLEnumTypeNormalizedConfig extends GraphQLEnumTypeConfig {\n  values: GraphQLEnumValueNormalizedConfigMap;\n  extensions: Readonly<GraphQLEnumTypeExtensions>;\n  extensionASTNodes: ReadonlyArray<EnumTypeExtensionNode>;\n}\n\nexport type GraphQLEnumValueConfigMap /* <T> */ =\n  ObjMap<GraphQLEnumValueConfig /* <T> */>;\n\nexport type GraphQLEnumValueNormalizedConfigMap /* <T> */ =\n  ObjMap<GraphQLEnumValueNormalizedConfig /* <T> */>;\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLEnumValueExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\nexport interface GraphQLEnumValueConfig {\n  description?: Maybe<string>;\n  value?: any /* T */;\n  deprecationReason?: Maybe<string>;\n  extensions?: Maybe<Readonly<GraphQLEnumValueExtensions>>;\n  astNode?: Maybe<EnumValueDefinitionNode>;\n}\n\nexport interface GraphQLEnumValueNormalizedConfig\n  extends GraphQLEnumValueConfig {\n  extensions: Readonly<GraphQLEnumValueExtensions>;\n}\n\nexport class GraphQLEnumValue implements GraphQLSchemaElement {\n  parentEnum: GraphQLEnumType;\n  name: string;\n  description: Maybe<string>;\n  value: any /* T */;\n  deprecationReason: Maybe<string>;\n  extensions: Readonly<GraphQLEnumValueExtensions>;\n  astNode: Maybe<EnumValueDefinitionNode>;\n\n  constructor(\n    parentEnum: GraphQLEnumType,\n    name: string,\n    config: GraphQLEnumValueConfig,\n  ) {\n    this.parentEnum = parentEnum;\n    this.name = assertEnumValueName(name);\n    this.description = config.description;\n    this.value = config.value !== undefined ? config.value : name;\n    this.deprecationReason = config.deprecationReason;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLEnumValue';\n  }\n\n  toConfig(): GraphQLEnumValueNormalizedConfig {\n    return {\n      description: this.description,\n      value: this.value,\n      deprecationReason: this.deprecationReason,\n      extensions: this.extensions,\n      astNode: this.astNode,\n    };\n  }\n\n  toString(): string {\n    return `${this.parentEnum.name}.${this.name}`;\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLInputObjectTypeExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n * ```ts\n * const GeoPoint = new GraphQLInputObjectType({\n *   name: 'GeoPoint',\n *   fields: {\n *     lat: { type: new GraphQLNonNull(GraphQLFloat) },\n *     lon: { type: new GraphQLNonNull(GraphQLFloat) },\n *     alt: { type: GraphQLFloat, defaultValue: 0 },\n *   }\n * });\n * ```\n */\nexport class GraphQLInputObjectType implements GraphQLSchemaElement {\n  name: string;\n  description: Maybe<string>;\n  extensions: Readonly<GraphQLInputObjectTypeExtensions>;\n  astNode: Maybe<InputObjectTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<InputObjectTypeExtensionNode>;\n  isOneOf: boolean;\n\n  private _fields: ThunkObjMap<GraphQLInputField>;\n\n  constructor(config: Readonly<GraphQLInputObjectTypeConfig>) {\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes ?? [];\n    this.isOneOf = config.isOneOf ?? false;\n\n    this._fields = defineInputFieldMap.bind(undefined, this, config.fields);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLInputObjectType';\n  }\n\n  getFields(): GraphQLInputFieldMap {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n    return this._fields;\n  }\n\n  toConfig(): GraphQLInputObjectTypeNormalizedConfig {\n    return {\n      name: this.name,\n      description: this.description,\n      fields: mapValue(this.getFields(), (field) => field.toConfig()),\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n      isOneOf: this.isOneOf,\n    };\n  }\n\n  toString(): string {\n    return this.name;\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\nfunction defineInputFieldMap(\n  parentType: GraphQLInputObjectType,\n  fields: ThunkObjMap<GraphQLInputFieldConfig>,\n): GraphQLInputFieldMap {\n  const fieldMap = resolveObjMapThunk(fields);\n  return mapValue(\n    fieldMap,\n    (fieldConfig, fieldName) =>\n      new GraphQLInputField(parentType, fieldName, fieldConfig),\n  );\n}\n\nexport interface GraphQLInputObjectTypeConfig {\n  name: string;\n  description?: Maybe<string>;\n  fields: ThunkObjMap<GraphQLInputFieldConfig>;\n  extensions?: Maybe<Readonly<GraphQLInputObjectTypeExtensions>>;\n  astNode?: Maybe<InputObjectTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<InputObjectTypeExtensionNode>>;\n  isOneOf?: boolean;\n}\n\nexport interface GraphQLInputObjectTypeNormalizedConfig\n  extends GraphQLInputObjectTypeConfig {\n  fields: GraphQLInputFieldNormalizedConfigMap;\n  extensions: Readonly<GraphQLInputObjectTypeExtensions>;\n  extensionASTNodes: ReadonlyArray<InputObjectTypeExtensionNode>;\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLInputFieldExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\nexport interface GraphQLInputFieldConfig {\n  description?: Maybe<string>;\n  type: GraphQLInputType;\n  defaultValue?: unknown;\n  defaultValueLiteral?: ConstValueNode | undefined;\n  deprecationReason?: Maybe<string>;\n  extensions?: Maybe<Readonly<GraphQLInputFieldExtensions>>;\n  astNode?: Maybe<InputValueDefinitionNode>;\n}\n\nexport type GraphQLInputFieldConfigMap = ObjMap<GraphQLInputFieldConfig>;\n\nexport interface GraphQLInputFieldNormalizedConfig\n  extends GraphQLInputFieldConfig {\n  extensions: Readonly<GraphQLInputFieldExtensions>;\n}\n\nexport type GraphQLInputFieldNormalizedConfigMap =\n  ObjMap<GraphQLInputFieldNormalizedConfig>;\n\nexport class GraphQLInputField implements GraphQLSchemaElement {\n  parentType: GraphQLInputObjectType;\n  name: string;\n  description: Maybe<string>;\n  type: GraphQLInputType;\n  defaultValue: GraphQLDefaultValueUsage | undefined;\n  deprecationReason: Maybe<string>;\n  extensions: Readonly<GraphQLInputFieldExtensions>;\n  astNode: Maybe<InputValueDefinitionNode>;\n\n  constructor(\n    parentType: GraphQLInputObjectType,\n    name: string,\n    config: GraphQLInputFieldConfig,\n  ) {\n    devAssert(\n      !('resolve' in config),\n      `${parentType}.${name} field has a resolve property, but Input Types cannot define resolvers.`,\n    );\n\n    this.parentType = parentType;\n    this.name = assertName(name);\n    this.description = config.description;\n    this.type = config.type;\n    this.defaultValue = defineDefaultValue(name, config);\n    this.deprecationReason = config.deprecationReason;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLInputField';\n  }\n\n  toConfig(): GraphQLInputFieldNormalizedConfig {\n    return {\n      description: this.description,\n      type: this.type,\n      defaultValue: this.defaultValue?.value,\n      defaultValueLiteral: this.defaultValue?.literal,\n      deprecationReason: this.deprecationReason,\n      extensions: this.extensions,\n      astNode: this.astNode,\n    };\n  }\n\n  toString(): string {\n    return `${this.parentType}.${this.name}`;\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\nexport function isRequiredInputField(field: GraphQLInputField): boolean {\n  return isNonNullType(field.type) && field.defaultValue === undefined;\n}\n\nexport type GraphQLInputFieldMap = ObjMap<GraphQLInputField>;\n"]}