{"version":3,"file":"definition.js","sourceRoot":"","sources":["../../src/type/definition.ts"],"names":[],"mappings":"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","sourcesContent":["import { devAssert } from '../jsutils/devAssert.js';\nimport { didYouMean } from '../jsutils/didYouMean.js';\nimport { identityFunc } from '../jsutils/identityFunc.js';\nimport { inspect } from '../jsutils/inspect.js';\nimport { instanceOf } from '../jsutils/instanceOf.js';\nimport { keyMap } from '../jsutils/keyMap.js';\nimport { keyValMap } from '../jsutils/keyValMap.js';\nimport { mapValue } from '../jsutils/mapValue.js';\nimport type { Maybe } from '../jsutils/Maybe.js';\nimport type { ObjMap } from '../jsutils/ObjMap.js';\nimport type { Path } from '../jsutils/Path.js';\nimport type { PromiseOrValue } from '../jsutils/PromiseOrValue.js';\nimport { suggestionList } from '../jsutils/suggestionList.js';\nimport { toObjMapWithSymbols } from '../jsutils/toObjMap.js';\n\nimport { GraphQLError } from '../error/GraphQLError.js';\n\nimport type {\n  ConstValueNode,\n  EnumTypeDefinitionNode,\n  EnumTypeExtensionNode,\n  EnumValueDefinitionNode,\n  FieldDefinitionNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  InputObjectTypeDefinitionNode,\n  InputObjectTypeExtensionNode,\n  InputValueDefinitionNode,\n  InterfaceTypeDefinitionNode,\n  InterfaceTypeExtensionNode,\n  ObjectTypeDefinitionNode,\n  ObjectTypeExtensionNode,\n  OperationDefinitionNode,\n  ScalarTypeDefinitionNode,\n  ScalarTypeExtensionNode,\n  UnionTypeDefinitionNode,\n  UnionTypeExtensionNode,\n  ValueNode,\n} from '../language/ast.js';\nimport { Kind } from '../language/kinds.js';\nimport { print } from '../language/printer.js';\n\nimport type { GraphQLVariableSignature } from '../execution/getVariableSignature.js';\nimport type { VariableValues } from '../execution/values.js';\n\nimport { valueFromASTUntyped } from '../utilities/valueFromASTUntyped.js';\n\nimport { assertEnumValueName, assertName } from './assertName.js';\nimport type { GraphQLSchema } from './schema.js';\n\n// Predicates & Assertions\n\n/**\n * These are all of the possible kinds of types.\n */\nexport type GraphQLType = GraphQLNamedType | GraphQLWrappingType;\n\nexport function isType(type: unknown): type is GraphQLType {\n  return (\n    isScalarType(type) ||\n    isObjectType(type) ||\n    isInterfaceType(type) ||\n    isUnionType(type) ||\n    isEnumType(type) ||\n    isInputObjectType(type) ||\n    isListType(type) ||\n    isNonNullType(type)\n  );\n}\n\nexport function assertType(type: unknown): GraphQLType {\n  if (!isType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL type.`);\n  }\n  return type;\n}\n\n/**\n * There are predicates for each kind of GraphQL type.\n */\nexport function isScalarType(type: unknown): type is GraphQLScalarType {\n  return instanceOf(type, GraphQLScalarType);\n}\n\nexport function assertScalarType(type: unknown): GraphQLScalarType {\n  if (!isScalarType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Scalar type.`);\n  }\n  return type;\n}\n\nexport function isObjectType(type: unknown): type is GraphQLObjectType {\n  return instanceOf(type, GraphQLObjectType);\n}\n\nexport function assertObjectType(type: unknown): GraphQLObjectType {\n  if (!isObjectType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Object type.`);\n  }\n  return type;\n}\n\nexport function isInterfaceType(type: unknown): type is GraphQLInterfaceType {\n  return instanceOf(type, GraphQLInterfaceType);\n}\n\nexport function assertInterfaceType(type: unknown): GraphQLInterfaceType {\n  if (!isInterfaceType(type)) {\n    throw new Error(\n      `Expected ${inspect(type)} to be a GraphQL Interface type.`,\n    );\n  }\n  return type;\n}\n\nexport function isUnionType(type: unknown): type is GraphQLUnionType {\n  return instanceOf(type, GraphQLUnionType);\n}\n\nexport function assertUnionType(type: unknown): GraphQLUnionType {\n  if (!isUnionType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Union type.`);\n  }\n  return type;\n}\n\nexport function isEnumType(type: unknown): type is GraphQLEnumType {\n  return instanceOf(type, GraphQLEnumType);\n}\n\nexport function assertEnumType(type: unknown): GraphQLEnumType {\n  if (!isEnumType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Enum type.`);\n  }\n  return type;\n}\n\nexport function isInputObjectType(\n  type: unknown,\n): type is GraphQLInputObjectType {\n  return instanceOf(type, GraphQLInputObjectType);\n}\n\nexport function assertInputObjectType(type: unknown): GraphQLInputObjectType {\n  if (!isInputObjectType(type)) {\n    throw new Error(\n      `Expected ${inspect(type)} to be a GraphQL Input Object type.`,\n    );\n  }\n  return type;\n}\n\nexport function isListType(\n  type: GraphQLInputType,\n): type is GraphQLList<GraphQLInputType>;\nexport function isListType(\n  type: GraphQLOutputType,\n): type is GraphQLList<GraphQLOutputType>;\nexport function isListType(type: unknown): type is GraphQLList<GraphQLType>;\nexport function isListType(type: unknown): type is GraphQLList<GraphQLType> {\n  return instanceOf(type, GraphQLList);\n}\n\nexport function assertListType(type: unknown): GraphQLList<GraphQLType> {\n  if (!isListType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL List type.`);\n  }\n  return type;\n}\n\nexport function isNonNullType(\n  type: GraphQLInputType,\n): type is GraphQLNonNull<GraphQLNullableInputType>;\nexport function isNonNullType(\n  type: GraphQLOutputType,\n): type is GraphQLNonNull<GraphQLNullableOutputType>;\nexport function isNonNullType(\n  type: unknown,\n): type is GraphQLNonNull<GraphQLNullableType>;\nexport function isNonNullType(\n  type: unknown,\n): type is GraphQLNonNull<GraphQLNullableType> {\n  return instanceOf(type, GraphQLNonNull);\n}\n\nexport function assertNonNullType(\n  type: unknown,\n): GraphQLNonNull<GraphQLNullableType> {\n  if (!isNonNullType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL Non-Null type.`);\n  }\n  return type;\n}\n\n/**\n * These types may be used as input types for arguments and directives.\n */\nexport type GraphQLNullableInputType =\n  | GraphQLNamedInputType\n  | GraphQLList<GraphQLInputType>;\n\nexport type GraphQLInputType =\n  | GraphQLNullableInputType\n  | GraphQLNonNull<GraphQLNullableInputType>;\n\nexport function isInputType(type: unknown): type is GraphQLInputType {\n  return (\n    isScalarType(type) ||\n    isEnumType(type) ||\n    isInputObjectType(type) ||\n    (isWrappingType(type) && isInputType(type.ofType))\n  );\n}\n\nexport function assertInputType(type: unknown): GraphQLInputType {\n  if (!isInputType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL input type.`);\n  }\n  return type;\n}\n\n/**\n * These types may be used as output types as the result of fields.\n */\nexport type GraphQLNullableOutputType =\n  | GraphQLNamedOutputType\n  | GraphQLList<GraphQLOutputType>;\n\nexport type GraphQLOutputType =\n  | GraphQLNullableOutputType\n  | GraphQLNonNull<GraphQLNullableOutputType>;\n\nexport function isOutputType(type: unknown): type is GraphQLOutputType {\n  return (\n    isScalarType(type) ||\n    isObjectType(type) ||\n    isInterfaceType(type) ||\n    isUnionType(type) ||\n    isEnumType(type) ||\n    (isWrappingType(type) && isOutputType(type.ofType))\n  );\n}\n\nexport function assertOutputType(type: unknown): GraphQLOutputType {\n  if (!isOutputType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL output type.`);\n  }\n  return type;\n}\n\n/**\n * These types may describe types which may be leaf values.\n */\nexport type GraphQLLeafType = GraphQLScalarType | GraphQLEnumType;\n\nexport function isLeafType(type: unknown): type is GraphQLLeafType {\n  return isScalarType(type) || isEnumType(type);\n}\n\nexport function assertLeafType(type: unknown): GraphQLLeafType {\n  if (!isLeafType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL leaf type.`);\n  }\n  return type;\n}\n\n/**\n * These types may describe the parent context of a selection set.\n */\nexport type GraphQLCompositeType =\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLUnionType;\n\nexport function isCompositeType(type: unknown): type is GraphQLCompositeType {\n  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);\n}\n\nexport function assertCompositeType(type: unknown): GraphQLCompositeType {\n  if (!isCompositeType(type)) {\n    throw new Error(\n      `Expected ${inspect(type)} to be a GraphQL composite type.`,\n    );\n  }\n  return type;\n}\n\n/**\n * These types may describe the parent context of a selection set.\n */\nexport type GraphQLAbstractType = GraphQLInterfaceType | GraphQLUnionType;\n\nexport function isAbstractType(type: unknown): type is GraphQLAbstractType {\n  return isInterfaceType(type) || isUnionType(type);\n}\n\nexport function assertAbstractType(type: unknown): GraphQLAbstractType {\n  if (!isAbstractType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL abstract type.`);\n  }\n  return type;\n}\n\n/**\n * List Type Wrapper\n *\n * A list is a wrapping type which points to another type.\n * Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n * ```ts\n * const PersonType = new GraphQLObjectType({\n *   name: 'Person',\n *   fields: () => ({\n *     parents: { type: new GraphQLList(PersonType) },\n *     children: { type: new GraphQLList(PersonType) },\n *   })\n * })\n * ```\n */\nexport class GraphQLList<T extends GraphQLType> {\n  readonly ofType: T;\n\n  constructor(ofType: T) {\n    this.ofType = ofType;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLList';\n  }\n\n  toString(): string {\n    return '[' + String(this.ofType) + ']';\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\n/**\n * Non-Null Type Wrapper\n *\n * A non-null is a wrapping type which points to another type.\n * Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n * ```ts\n * const RowType = new GraphQLObjectType({\n *   name: 'Row',\n *   fields: () => ({\n *     id: { type: new GraphQLNonNull(GraphQLString) },\n *   })\n * })\n * ```\n * Note: the enforcement of non-nullability occurs within the executor.\n */\nexport class GraphQLNonNull<T extends GraphQLNullableType> {\n  readonly ofType: T;\n\n  constructor(ofType: T) {\n    this.ofType = ofType;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLNonNull';\n  }\n\n  toString(): string {\n    return String(this.ofType) + '!';\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\n/**\n * These types wrap and modify other types\n */\n\nexport type GraphQLWrappingType =\n  | GraphQLList<GraphQLType>\n  | GraphQLNonNull<GraphQLNullableType>;\n\nexport function isWrappingType(type: unknown): type is GraphQLWrappingType {\n  return isListType(type) || isNonNullType(type);\n}\n\nexport function assertWrappingType(type: unknown): GraphQLWrappingType {\n  if (!isWrappingType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL wrapping type.`);\n  }\n  return type;\n}\n\n/**\n * These types can all accept null as a value.\n */\nexport type GraphQLNullableType = GraphQLNamedType | GraphQLList<GraphQLType>;\n\nexport function isNullableType(type: unknown): type is GraphQLNullableType {\n  return isType(type) && !isNonNullType(type);\n}\n\nexport function assertNullableType(type: unknown): GraphQLNullableType {\n  if (!isNullableType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL nullable type.`);\n  }\n  return type;\n}\n\nexport function getNullableType(type: undefined | null): void;\nexport function getNullableType<T extends GraphQLNullableType>(\n  type: T | GraphQLNonNull<T>,\n): T;\nexport function getNullableType(\n  type: Maybe<GraphQLType>,\n): GraphQLNullableType | undefined;\nexport function getNullableType(\n  type: Maybe<GraphQLType>,\n): GraphQLNullableType | undefined {\n  if (type) {\n    return isNonNullType(type) ? type.ofType : type;\n  }\n}\n\n/**\n * These named types do not include modifiers like List or NonNull.\n */\nexport type GraphQLNamedType = GraphQLNamedInputType | GraphQLNamedOutputType;\n\nexport type GraphQLNamedInputType =\n  | GraphQLScalarType\n  | GraphQLEnumType\n  | GraphQLInputObjectType;\n\nexport type GraphQLNamedOutputType =\n  | GraphQLScalarType\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLUnionType\n  | GraphQLEnumType;\n\nexport function isNamedType(type: unknown): type is GraphQLNamedType {\n  return (\n    isScalarType(type) ||\n    isObjectType(type) ||\n    isInterfaceType(type) ||\n    isUnionType(type) ||\n    isEnumType(type) ||\n    isInputObjectType(type)\n  );\n}\n\nexport function assertNamedType(type: unknown): GraphQLNamedType {\n  if (!isNamedType(type)) {\n    throw new Error(`Expected ${inspect(type)} to be a GraphQL named type.`);\n  }\n  return type;\n}\n\nexport function getNamedType(type: undefined | null): void;\nexport function getNamedType(type: GraphQLInputType): GraphQLNamedInputType;\nexport function getNamedType(type: GraphQLOutputType): GraphQLNamedOutputType;\nexport function getNamedType(type: GraphQLType): GraphQLNamedType;\nexport function getNamedType(\n  type: Maybe<GraphQLType>,\n): GraphQLNamedType | undefined;\nexport function getNamedType(\n  type: Maybe<GraphQLType>,\n): GraphQLNamedType | undefined {\n  if (type) {\n    let unwrappedType = type;\n    while (isWrappingType(unwrappedType)) {\n      unwrappedType = unwrappedType.ofType;\n    }\n    return unwrappedType;\n  }\n}\n\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\nexport type ThunkReadonlyArray<T> = (() => ReadonlyArray<T>) | ReadonlyArray<T>;\nexport type ThunkObjMap<T> = (() => ObjMap<T>) | ObjMap<T>;\n\nexport function resolveReadonlyArrayThunk<T>(\n  thunk: ThunkReadonlyArray<T>,\n): ReadonlyArray<T> {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n\nexport function resolveObjMapThunk<T>(thunk: ThunkObjMap<T>): ObjMap<T> {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLScalarTypeExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * If a type's coerceOutputValue function returns `null` or does not return a\n * value (i.e. it returns `undefined`) then an error will be raised and a\n * `null` value will be returned in the response. It is always better to\n * validate.\n *\n * Example:\n *\n * ```ts\n * function ensureOdd(value) {\n *   if (!Number.isFinite(value)) {\n *     throw new Error(\n *       `Scalar \"Odd\" cannot represent \"${value}\" since it is not a finite number.`,\n *     );\n *   }\n *\n *   if (value % 2 === 0) {\n *     throw new Error(`Scalar \"Odd\" cannot represent \"${value}\" since it is even.`);\n *   }\n * }\n *\n * const OddType = new GraphQLScalarType({\n *   name: 'Odd',\n *   coerceOutputValue(value) {\n *     return ensureOdd(value);\n *   },\n *   coerceInputValue(value) {\n *     return ensureOdd(value);\n *   }\n *   valueToLiteral(value) {\n *    return parse(`${ensureOdd(value)`);\n *   }\n * });\n * ```\n *\n * Custom scalars behavior is defined via the following functions:\n *\n *  - coerceOutputValue(value): Implements \"Result Coercion\". Given an internal value,\n *    produces an external value valid for this type. Returns undefined or\n *    throws an error to indicate invalid values.\n *\n *  - coerceInputValue(value): Implements \"Input Coercion\" for values. Given an\n *    external value (for example, variable values), produces an internal value\n *    valid for this type. Returns undefined or throws an error to indicate\n *    invalid values.\n *\n *  - coerceInputLiteral(ast): Implements \"Input Coercion\" for constant literals.\n *    Given an GraphQL literal (AST) (for example, an argument value), produces\n *    an internal value valid for this type. Returns undefined or throws an\n *    error to indicate invalid values.\n *\n *  - valueToLiteral(value): Converts an external value to a GraphQL\n *    literal (AST). Returns undefined or throws an error to indicate\n *    invalid values.\n *\n *  Deprecated, to be removed in v18:\n *\n *  - serialize(value): Implements \"Result Coercion\". Renamed to\n *    `coerceOutputValue()`.\n *\n *  - parseValue(value): Implements \"Input Coercion\" for values. Renamed to\n *    `coerceInputValue()`.\n *\n *  - parseLiteral(ast): Implements \"Input Coercion\" for literals including\n *    non-specified replacement of variables embedded within complex scalars.\n *    Replaced by the combination of the `replaceVariables()` utility and the\n *    `coerceInputLiteral()` method.\n *\n */\nexport class GraphQLScalarType<TInternal = unknown, TExternal = TInternal> {\n  name: string;\n  description: Maybe<string>;\n  specifiedByURL: Maybe<string>;\n  /** @deprecated use `coerceOutputValue()` instead, `serialize()` will be removed in v18 */\n  serialize: GraphQLScalarSerializer<TExternal>;\n  /** @deprecated use `coerceInputValue()` instead, `parseValue()` will be removed in v18 */\n  parseValue: GraphQLScalarValueParser<TInternal>;\n  /** @deprecated use `replaceVariables()` and `coerceInputLiteral()` instead, `parseLiteral()` will be removed in v18 */\n  parseLiteral: GraphQLScalarLiteralParser<TInternal>;\n  coerceOutputValue: GraphQLScalarOutputValueCoercer<TExternal>;\n  coerceInputValue: GraphQLScalarInputValueCoercer<TInternal>;\n  coerceInputLiteral: GraphQLScalarInputLiteralCoercer<TInternal> | undefined;\n  valueToLiteral: GraphQLScalarValueToLiteral | undefined;\n  extensions: Readonly<GraphQLScalarTypeExtensions>;\n  astNode: Maybe<ScalarTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<ScalarTypeExtensionNode>;\n\n  constructor(config: Readonly<GraphQLScalarTypeConfig<TInternal, TExternal>>) {\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.specifiedByURL = config.specifiedByURL;\n    this.serialize =\n      config.serialize ??\n      config.coerceOutputValue ??\n      (identityFunc as GraphQLScalarSerializer<TExternal>);\n    this.parseValue =\n      config.parseValue ??\n      config.coerceInputValue ??\n      (identityFunc as GraphQLScalarValueParser<TInternal>);\n    this.parseLiteral =\n      config.parseLiteral ??\n      ((node, variables) =>\n        this.coerceInputValue(valueFromASTUntyped(node, variables)));\n    this.coerceOutputValue = config.coerceOutputValue ?? this.serialize;\n    this.coerceInputValue = config.coerceInputValue ?? this.parseValue;\n    this.coerceInputLiteral = config.coerceInputLiteral;\n    this.valueToLiteral = config.valueToLiteral;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes ?? [];\n\n    if (config.parseLiteral) {\n      devAssert(\n        typeof config.parseValue === 'function' &&\n          typeof config.parseLiteral === 'function',\n        `${this.name} must provide both \"parseValue\" and \"parseLiteral\" functions.`,\n      );\n    }\n\n    if (config.coerceInputLiteral) {\n      devAssert(\n        typeof config.coerceInputValue === 'function' &&\n          typeof config.coerceInputLiteral === 'function',\n        `${this.name} must provide both \"coerceInputValue\" and \"coerceInputLiteral\" functions.`,\n      );\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLScalarType';\n  }\n\n  toConfig(): GraphQLScalarTypeNormalizedConfig<TInternal, TExternal> {\n    return {\n      name: this.name,\n      description: this.description,\n      specifiedByURL: this.specifiedByURL,\n      serialize: this.serialize,\n      parseValue: this.parseValue,\n      parseLiteral: this.parseLiteral,\n      coerceOutputValue: this.coerceOutputValue,\n      coerceInputValue: this.coerceInputValue,\n      coerceInputLiteral: this.coerceInputLiteral,\n      valueToLiteral: this.valueToLiteral,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString(): string {\n    return this.name;\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\n/* @deprecated in favor of GraphQLScalarOutputValueCoercer, will be removed in v18 */\nexport type GraphQLScalarSerializer<TExternal> = (\n  outputValue: unknown,\n) => TExternal;\n\nexport type GraphQLScalarOutputValueCoercer<TExternal> = (\n  outputValue: unknown,\n) => TExternal;\n\n/* @deprecated in favor of GraphQLScalarInputValueCoercer, will be removed in v18 */\nexport type GraphQLScalarValueParser<TInternal> = (\n  inputValue: unknown,\n) => TInternal;\n\nexport type GraphQLScalarInputValueCoercer<TInternal> = (\n  inputValue: unknown,\n) => TInternal;\n\n/* @deprecated in favor of GraphQLScalarInputLiteralCoercer, will be removed in v18 */\nexport type GraphQLScalarLiteralParser<TInternal> = (\n  valueNode: ValueNode,\n  variables: Maybe<ObjMap<unknown>>,\n) => Maybe<TInternal>;\n\nexport type GraphQLScalarInputLiteralCoercer<TInternal> = (\n  valueNode: ConstValueNode,\n) => Maybe<TInternal>;\n\nexport type GraphQLScalarValueToLiteral = (\n  inputValue: unknown,\n) => ConstValueNode | undefined;\n\nexport interface GraphQLScalarTypeConfig<TInternal, TExternal> {\n  name: string;\n  description?: Maybe<string>;\n  specifiedByURL?: Maybe<string>;\n  /** Serializes an internal value to include in a response. */\n  /** @deprecated use `coerceOutputValue()` instead, `serialize()` will be removed in v18 */\n  serialize?: GraphQLScalarSerializer<TExternal> | undefined;\n  /** Parses an externally provided value to use as an input. */\n  /** @deprecated use `coerceInputValue()` instead, `parseValue()` will be removed in v18 */\n  parseValue?: GraphQLScalarValueParser<TInternal> | undefined;\n  /** Parses an externally provided literal value to use as an input. */\n  /** @deprecated use `replaceVariables()` and `coerceInputLiteral()` instead, `parseLiteral()` will be removed in v18 */\n  parseLiteral?: GraphQLScalarLiteralParser<TInternal> | undefined;\n  /** Coerces an externally provided value to use as an input. */\n  coerceOutputValue?: GraphQLScalarOutputValueCoercer<TExternal> | undefined;\n  /** Coerces an internal value to include in a response. */\n  coerceInputValue?: GraphQLScalarInputValueCoercer<TInternal> | undefined;\n  /** Coerces an externally provided const literal value to use as an input. */\n  coerceInputLiteral?: GraphQLScalarInputLiteralCoercer<TInternal> | undefined;\n  /** Translates an externally provided value to a literal (AST). */\n  valueToLiteral?: GraphQLScalarValueToLiteral | undefined;\n  extensions?: Maybe<Readonly<GraphQLScalarTypeExtensions>>;\n  astNode?: Maybe<ScalarTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<ScalarTypeExtensionNode>>;\n}\n\ninterface GraphQLScalarTypeNormalizedConfig<TInternal, TExternal>\n  extends GraphQLScalarTypeConfig<TInternal, TExternal> {\n  serialize: GraphQLScalarSerializer<TExternal>;\n  parseValue: GraphQLScalarValueParser<TInternal>;\n  parseLiteral: GraphQLScalarLiteralParser<TInternal>;\n  coerceOutputValue: GraphQLScalarOutputValueCoercer<TExternal>;\n  coerceInputValue: GraphQLScalarInputValueCoercer<TInternal>;\n  coerceInputLiteral: GraphQLScalarInputLiteralCoercer<TInternal> | undefined;\n  extensions: Readonly<GraphQLScalarTypeExtensions>;\n  extensionASTNodes: ReadonlyArray<ScalarTypeExtensionNode>;\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n *\n * We've provided these template arguments because this is an open type and\n * you may find them useful.\n */\nexport interface GraphQLObjectTypeExtensions<_TSource = any, _TContext = any> {\n  [attributeName: string | symbol]: unknown;\n}\n\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n * ```ts\n * const AddressType = new GraphQLObjectType({\n *   name: 'Address',\n *   fields: {\n *     street: { type: GraphQLString },\n *     number: { type: GraphQLInt },\n *     formatted: {\n *       type: GraphQLString,\n *       resolve(obj) {\n *         return obj.number + ' ' + obj.street\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n * ```ts\n * const PersonType = new GraphQLObjectType({\n *   name: 'Person',\n *   fields: () => ({\n *     name: { type: GraphQLString },\n *     bestFriend: { type: PersonType },\n *   })\n * });\n * ```\n */\nexport class GraphQLObjectType<TSource = any, TContext = any> {\n  name: string;\n  description: Maybe<string>;\n  isTypeOf: Maybe<GraphQLIsTypeOfFn<TSource, TContext>>;\n  extensions: Readonly<GraphQLObjectTypeExtensions<TSource, TContext>>;\n  astNode: Maybe<ObjectTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<ObjectTypeExtensionNode>;\n\n  private _fields: ThunkObjMap<GraphQLField<TSource, TContext>>;\n  private _interfaces: ThunkReadonlyArray<GraphQLInterfaceType>;\n\n  constructor(config: Readonly<GraphQLObjectTypeConfig<TSource, TContext>>) {\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.isTypeOf = config.isTypeOf;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes ?? [];\n    this._fields = (defineFieldMap<TSource, TContext>).bind(\n      undefined,\n      config.fields,\n    );\n    this._interfaces = defineInterfaces.bind(undefined, config.interfaces);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLObjectType';\n  }\n\n  getFields(): GraphQLFieldMap<TSource, TContext> {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n    return this._fields;\n  }\n\n  getInterfaces(): ReadonlyArray<GraphQLInterfaceType> {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n    return this._interfaces;\n  }\n\n  toConfig(): GraphQLObjectTypeNormalizedConfig<TSource, TContext> {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      isTypeOf: this.isTypeOf,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString(): string {\n    return this.name;\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\nfunction defineInterfaces(\n  interfaces: Maybe<ThunkReadonlyArray<GraphQLInterfaceType>>,\n): ReadonlyArray<GraphQLInterfaceType> {\n  return resolveReadonlyArrayThunk(interfaces ?? []);\n}\n\nfunction defineFieldMap<TSource, TContext>(\n  fields: ThunkObjMap<GraphQLFieldConfig<TSource, TContext>>,\n): GraphQLFieldMap<TSource, TContext> {\n  const fieldMap = resolveObjMapThunk(fields);\n\n  return mapValue(fieldMap, (fieldConfig, fieldName) => {\n    const argsConfig = fieldConfig.args ?? {};\n    return {\n      name: assertName(fieldName),\n      description: fieldConfig.description,\n      type: fieldConfig.type,\n      args: defineArguments(argsConfig),\n      resolve: fieldConfig.resolve,\n      subscribe: fieldConfig.subscribe,\n      deprecationReason: fieldConfig.deprecationReason,\n      extensions: toObjMapWithSymbols(fieldConfig.extensions),\n      astNode: fieldConfig.astNode,\n    };\n  });\n}\n\nexport function defineArguments(\n  args: GraphQLFieldConfigArgumentMap,\n): ReadonlyArray<GraphQLArgument> {\n  return Object.entries(args).map(([argName, argConfig]) => ({\n    name: assertName(argName),\n    description: argConfig.description,\n    type: argConfig.type,\n    defaultValue: defineDefaultValue(argName, argConfig),\n    deprecationReason: argConfig.deprecationReason,\n    extensions: toObjMapWithSymbols(argConfig.extensions),\n    astNode: argConfig.astNode,\n  }));\n}\n\nfunction fieldsToFieldsConfig<TSource, TContext>(\n  fields: GraphQLFieldMap<TSource, TContext>,\n): GraphQLFieldConfigMap<TSource, TContext> {\n  return mapValue(fields, (field) => ({\n    description: field.description,\n    type: field.type,\n    args: argsToArgsConfig(field.args),\n    resolve: field.resolve,\n    subscribe: field.subscribe,\n    deprecationReason: field.deprecationReason,\n    extensions: field.extensions,\n    astNode: field.astNode,\n  }));\n}\n\n/**\n * @internal\n */\nexport function argsToArgsConfig(\n  args: ReadonlyArray<GraphQLArgument>,\n): GraphQLFieldConfigArgumentMap {\n  return keyValMap(\n    args,\n    (arg) => arg.name,\n    (arg) => ({\n      description: arg.description,\n      type: arg.type,\n      defaultValue: arg.defaultValue?.value,\n      defaultValueLiteral: arg.defaultValue?.literal,\n      deprecationReason: arg.deprecationReason,\n      extensions: arg.extensions,\n      astNode: arg.astNode,\n    }),\n  );\n}\n\nexport interface GraphQLObjectTypeConfig<TSource, TContext> {\n  name: string;\n  description?: Maybe<string>;\n  interfaces?: ThunkReadonlyArray<GraphQLInterfaceType> | undefined;\n  fields: ThunkObjMap<GraphQLFieldConfig<TSource, TContext>>;\n  isTypeOf?: Maybe<GraphQLIsTypeOfFn<TSource, TContext>>;\n  extensions?: Maybe<Readonly<GraphQLObjectTypeExtensions<TSource, TContext>>>;\n  astNode?: Maybe<ObjectTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<ObjectTypeExtensionNode>>;\n}\n\ninterface GraphQLObjectTypeNormalizedConfig<TSource, TContext>\n  extends GraphQLObjectTypeConfig<any, any> {\n  interfaces: ReadonlyArray<GraphQLInterfaceType>;\n  fields: GraphQLFieldConfigMap<any, any>;\n  extensions: Readonly<GraphQLObjectTypeExtensions<TSource, TContext>>;\n  extensionASTNodes: ReadonlyArray<ObjectTypeExtensionNode>;\n}\n\nexport type GraphQLTypeResolver<TSource, TContext> = (\n  value: TSource,\n  context: TContext,\n  info: GraphQLResolveInfo,\n  abstractType: GraphQLAbstractType,\n) => PromiseOrValue<string | undefined>;\n\nexport type GraphQLIsTypeOfFn<TSource, TContext> = (\n  source: TSource,\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => PromiseOrValue<boolean>;\n\nexport type GraphQLFieldResolver<\n  TSource,\n  TContext,\n  TArgs = any,\n  TResult = unknown,\n> = (\n  source: TSource,\n  args: TArgs,\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => TResult;\n\nexport interface GraphQLResolveInfo {\n  readonly fieldName: string;\n  readonly fieldNodes: ReadonlyArray<FieldNode>;\n  readonly returnType: GraphQLOutputType;\n  readonly parentType: GraphQLObjectType;\n  readonly path: Path;\n  readonly schema: GraphQLSchema;\n  readonly fragments: ObjMap<FragmentDefinitionNode>;\n  readonly rootValue: unknown;\n  readonly operation: OperationDefinitionNode;\n  readonly variableValues: VariableValues;\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n *\n * We've provided these template arguments because this is an open type and\n * you may find them useful.\n */\nexport interface GraphQLFieldExtensions<_TSource, _TContext, _TArgs = any> {\n  [attributeName: string | symbol]: unknown;\n}\n\nexport interface GraphQLFieldConfig<TSource, TContext, TArgs = any> {\n  description?: Maybe<string>;\n  type: GraphQLOutputType;\n  args?: GraphQLFieldConfigArgumentMap | undefined;\n  resolve?: GraphQLFieldResolver<TSource, TContext, TArgs> | undefined;\n  subscribe?: GraphQLFieldResolver<TSource, TContext, TArgs> | undefined;\n  deprecationReason?: Maybe<string>;\n  extensions?: Maybe<\n    Readonly<GraphQLFieldExtensions<TSource, TContext, TArgs>>\n  >;\n  astNode?: Maybe<FieldDefinitionNode>;\n}\n\nexport type GraphQLFieldConfigArgumentMap = ObjMap<GraphQLArgumentConfig>;\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLArgumentExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\nexport interface GraphQLArgumentConfig {\n  description?: Maybe<string>;\n  type: GraphQLInputType;\n  defaultValue?: unknown;\n  defaultValueLiteral?: ConstValueNode | undefined;\n  deprecationReason?: Maybe<string>;\n  extensions?: Maybe<Readonly<GraphQLArgumentExtensions>>;\n  astNode?: Maybe<InputValueDefinitionNode>;\n}\n\nexport type GraphQLFieldConfigMap<TSource, TContext> = ObjMap<\n  GraphQLFieldConfig<TSource, TContext>\n>;\n\nexport interface GraphQLField<TSource, TContext, TArgs = any> {\n  name: string;\n  description: Maybe<string>;\n  type: GraphQLOutputType;\n  args: ReadonlyArray<GraphQLArgument>;\n  resolve?: GraphQLFieldResolver<TSource, TContext, TArgs> | undefined;\n  subscribe?: GraphQLFieldResolver<TSource, TContext, TArgs> | undefined;\n  deprecationReason: Maybe<string>;\n  extensions: Readonly<GraphQLFieldExtensions<TSource, TContext, TArgs>>;\n  astNode: Maybe<FieldDefinitionNode>;\n}\n\nexport interface GraphQLArgument {\n  name: string;\n  description: Maybe<string>;\n  type: GraphQLInputType;\n  defaultValue: GraphQLDefaultValueUsage | undefined;\n  deprecationReason: Maybe<string>;\n  extensions: Readonly<GraphQLArgumentExtensions>;\n  astNode: Maybe<InputValueDefinitionNode>;\n}\n\nexport function isRequiredArgument(\n  arg: GraphQLArgument | GraphQLVariableSignature,\n): boolean {\n  return isNonNullType(arg.type) && arg.defaultValue === undefined;\n}\n\nexport type GraphQLFieldMap<TSource, TContext> = ObjMap<\n  GraphQLField<TSource, TContext>\n>;\n\nexport type GraphQLDefaultValueUsage =\n  | { value: unknown; literal?: never }\n  | { literal: ConstValueNode; value?: never };\n\nexport function defineDefaultValue(\n  argName: string,\n  config: GraphQLArgumentConfig | GraphQLInputFieldConfig,\n): GraphQLDefaultValueUsage | undefined {\n  if (config.defaultValue === undefined && !config.defaultValueLiteral) {\n    return;\n  }\n  devAssert(\n    !(config.defaultValue !== undefined && config.defaultValueLiteral),\n    `Argument \"${argName}\" has both a defaultValue and a defaultValueLiteral property, but only one must be provided.`,\n  );\n  return config.defaultValueLiteral\n    ? { literal: config.defaultValueLiteral }\n    : { value: config.defaultValue };\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLInterfaceTypeExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n * ```ts\n * const EntityType = new GraphQLInterfaceType({\n *   name: 'Entity',\n *   fields: {\n *     name: { type: GraphQLString }\n *   }\n * });\n * ```\n */\nexport class GraphQLInterfaceType<TSource = any, TContext = any> {\n  name: string;\n  description: Maybe<string>;\n  resolveType: Maybe<GraphQLTypeResolver<TSource, TContext>>;\n  extensions: Readonly<GraphQLInterfaceTypeExtensions>;\n  astNode: Maybe<InterfaceTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<InterfaceTypeExtensionNode>;\n\n  private _fields: ThunkObjMap<GraphQLField<TSource, TContext>>;\n  private _interfaces: ThunkReadonlyArray<GraphQLInterfaceType>;\n\n  constructor(config: Readonly<GraphQLInterfaceTypeConfig<TSource, TContext>>) {\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes ?? [];\n    this._fields = (defineFieldMap<TSource, TContext>).bind(\n      undefined,\n      config.fields,\n    );\n    this._interfaces = defineInterfaces.bind(undefined, config.interfaces);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLInterfaceType';\n  }\n\n  getFields(): GraphQLFieldMap<TSource, TContext> {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n    return this._fields;\n  }\n\n  getInterfaces(): ReadonlyArray<GraphQLInterfaceType> {\n    if (typeof this._interfaces === 'function') {\n      this._interfaces = this._interfaces();\n    }\n    return this._interfaces;\n  }\n\n  toConfig(): GraphQLInterfaceTypeNormalizedConfig<TSource, TContext> {\n    return {\n      name: this.name,\n      description: this.description,\n      interfaces: this.getInterfaces(),\n      fields: fieldsToFieldsConfig(this.getFields()),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString(): string {\n    return this.name;\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\nexport interface GraphQLInterfaceTypeConfig<TSource, TContext> {\n  name: string;\n  description?: Maybe<string>;\n  interfaces?: ThunkReadonlyArray<GraphQLInterfaceType> | undefined;\n  fields: ThunkObjMap<GraphQLFieldConfig<TSource, TContext>>;\n  /**\n   * Optionally provide a custom type resolver function. If one is not provided,\n   * the default implementation will call `isTypeOf` on each implementing\n   * Object type.\n   */\n  resolveType?: Maybe<GraphQLTypeResolver<TSource, TContext>>;\n  extensions?: Maybe<Readonly<GraphQLInterfaceTypeExtensions>>;\n  astNode?: Maybe<InterfaceTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<InterfaceTypeExtensionNode>>;\n}\n\ninterface GraphQLInterfaceTypeNormalizedConfig<TSource, TContext>\n  extends GraphQLInterfaceTypeConfig<any, any> {\n  interfaces: ReadonlyArray<GraphQLInterfaceType>;\n  fields: GraphQLFieldConfigMap<TSource, TContext>;\n  extensions: Readonly<GraphQLInterfaceTypeExtensions>;\n  extensionASTNodes: ReadonlyArray<InterfaceTypeExtensionNode>;\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLUnionTypeExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n * ```ts\n * const PetType = new GraphQLUnionType({\n *   name: 'Pet',\n *   types: [ DogType, CatType ],\n *   resolveType(value) {\n *     if (value instanceof Dog) {\n *       return DogType;\n *     }\n *     if (value instanceof Cat) {\n *       return CatType;\n *     }\n *   }\n * });\n * ```\n */\nexport class GraphQLUnionType {\n  name: string;\n  description: Maybe<string>;\n  resolveType: Maybe<GraphQLTypeResolver<any, any>>;\n  extensions: Readonly<GraphQLUnionTypeExtensions>;\n  astNode: Maybe<UnionTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<UnionTypeExtensionNode>;\n\n  private _types: ThunkReadonlyArray<GraphQLObjectType>;\n\n  constructor(config: Readonly<GraphQLUnionTypeConfig<any, any>>) {\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.resolveType = config.resolveType;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes ?? [];\n\n    this._types = defineTypes.bind(undefined, config.types);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLUnionType';\n  }\n\n  getTypes(): ReadonlyArray<GraphQLObjectType> {\n    if (typeof this._types === 'function') {\n      this._types = this._types();\n    }\n    return this._types;\n  }\n\n  toConfig(): GraphQLUnionTypeNormalizedConfig {\n    return {\n      name: this.name,\n      description: this.description,\n      types: this.getTypes(),\n      resolveType: this.resolveType,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString(): string {\n    return this.name;\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\nfunction defineTypes(\n  types: ThunkReadonlyArray<GraphQLObjectType>,\n): ReadonlyArray<GraphQLObjectType> {\n  return resolveReadonlyArrayThunk(types);\n}\n\nexport interface GraphQLUnionTypeConfig<TSource, TContext> {\n  name: string;\n  description?: Maybe<string>;\n  types: ThunkReadonlyArray<GraphQLObjectType>;\n  /**\n   * Optionally provide a custom type resolver function. If one is not provided,\n   * the default implementation will call `isTypeOf` on each implementing\n   * Object type.\n   */\n  resolveType?: Maybe<GraphQLTypeResolver<TSource, TContext>>;\n  extensions?: Maybe<Readonly<GraphQLUnionTypeExtensions>>;\n  astNode?: Maybe<UnionTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<UnionTypeExtensionNode>>;\n}\n\ninterface GraphQLUnionTypeNormalizedConfig\n  extends GraphQLUnionTypeConfig<any, any> {\n  types: ReadonlyArray<GraphQLObjectType>;\n  extensions: Readonly<GraphQLUnionTypeExtensions>;\n  extensionASTNodes: ReadonlyArray<UnionTypeExtensionNode>;\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLEnumTypeExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\nfunction enumValuesFromConfig(values: GraphQLEnumValueConfigMap) {\n  return Object.entries(values).map(([valueName, valueConfig]) => ({\n    name: assertEnumValueName(valueName),\n    description: valueConfig.description,\n    value: valueConfig.value !== undefined ? valueConfig.value : valueName,\n    deprecationReason: valueConfig.deprecationReason,\n    extensions: toObjMapWithSymbols(valueConfig.extensions),\n    astNode: valueConfig.astNode,\n  }));\n}\n\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL coerces\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n * ```ts\n * const RGBType = new GraphQLEnumType({\n *   name: 'RGB',\n *   values: {\n *     RED: { value: 0 },\n *     GREEN: { value: 1 },\n *     BLUE: { value: 2 }\n *   }\n * });\n * ```\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\nexport class GraphQLEnumType /* <T> */ {\n  name: string;\n  description: Maybe<string>;\n  extensions: Readonly<GraphQLEnumTypeExtensions>;\n  astNode: Maybe<EnumTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<EnumTypeExtensionNode>;\n\n  private _values:\n    | ReadonlyArray<GraphQLEnumValue /* <T> */>\n    | (() => GraphQLEnumValueConfigMap);\n\n  private _valueLookup: ReadonlyMap<any /* T */, GraphQLEnumValue> | null;\n  private _nameLookup: ObjMap<GraphQLEnumValue> | null;\n\n  constructor(config: Readonly<GraphQLEnumTypeConfig /* <T> */>) {\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes ?? [];\n\n    this._values =\n      typeof config.values === 'function'\n        ? config.values\n        : enumValuesFromConfig(config.values);\n    this._valueLookup = null;\n    this._nameLookup = null;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLEnumType';\n  }\n\n  getValues(): ReadonlyArray<GraphQLEnumValue /* <T> */> {\n    if (typeof this._values === 'function') {\n      this._values = enumValuesFromConfig(this._values());\n    }\n    return this._values;\n  }\n\n  getValue(name: string): Maybe<GraphQLEnumValue> {\n    if (this._nameLookup === null) {\n      this._nameLookup = keyMap(this.getValues(), (value) => value.name);\n    }\n    return this._nameLookup[name];\n  }\n\n  /** @deprecated use `coerceOutputValue()` instead, `serialize()` will be removed in v18 */\n  serialize(outputValue: unknown /* T */): Maybe<string> {\n    return this.coerceOutputValue(outputValue);\n  }\n\n  coerceOutputValue(outputValue: unknown /* T */): Maybe<string> {\n    if (this._valueLookup === null) {\n      this._valueLookup = new Map(\n        this.getValues().map((enumValue) => [enumValue.value, enumValue]),\n      );\n    }\n    const enumValue = this._valueLookup.get(outputValue);\n    if (enumValue === undefined) {\n      throw new GraphQLError(\n        `Enum \"${this.name}\" cannot represent value: ${inspect(outputValue)}`,\n      );\n    }\n    return enumValue.name;\n  }\n\n  /** @deprecated use `coerceInputValue()` instead, `parseValue()` will be removed in v18 */\n  parseValue(\n    inputValue: unknown,\n    hideSuggestions?: Maybe<boolean>,\n  ): Maybe<any> /* T */ {\n    return this.coerceInputValue(inputValue, hideSuggestions);\n  }\n\n  coerceInputValue(\n    inputValue: unknown,\n    hideSuggestions?: Maybe<boolean>,\n  ): Maybe<any> /* T */ {\n    if (typeof inputValue !== 'string') {\n      const valueStr = inspect(inputValue);\n      throw new GraphQLError(\n        `Enum \"${this.name}\" cannot represent non-string value: ${valueStr}.` +\n          (hideSuggestions ? '' : didYouMeanEnumValue(this, valueStr)),\n      );\n    }\n\n    const enumValue = this.getValue(inputValue);\n    if (enumValue == null) {\n      throw new GraphQLError(\n        `Value \"${inputValue}\" does not exist in \"${this.name}\" enum.` +\n          (hideSuggestions ? '' : didYouMeanEnumValue(this, inputValue)),\n      );\n    }\n    return enumValue.value;\n  }\n\n  /** @deprecated use `coerceInputLiteral()` instead, `parseLiteral()` will be removed in v18 */\n  parseLiteral(\n    valueNode: ValueNode,\n    _variables: Maybe<ObjMap<unknown>>,\n    hideSuggestions?: Maybe<boolean>,\n  ): Maybe<any> /* T */ {\n    // Note: variables will be resolved to a value before calling this function.\n    return this.coerceInputLiteral(\n      valueNode as ConstValueNode,\n      hideSuggestions,\n    );\n  }\n\n  coerceInputLiteral(\n    valueNode: ConstValueNode,\n    hideSuggestions?: Maybe<boolean>,\n  ): Maybe<any> /* T */ {\n    if (valueNode.kind !== Kind.ENUM) {\n      const valueStr = print(valueNode);\n      throw new GraphQLError(\n        `Enum \"${this.name}\" cannot represent non-enum value: ${valueStr}.` +\n          (hideSuggestions ? '' : didYouMeanEnumValue(this, valueStr)),\n        { nodes: valueNode },\n      );\n    }\n\n    const enumValue = this.getValue(valueNode.value);\n    if (enumValue == null) {\n      const valueStr = print(valueNode);\n      throw new GraphQLError(\n        `Value \"${valueStr}\" does not exist in \"${this.name}\" enum.` +\n          (hideSuggestions ? '' : didYouMeanEnumValue(this, valueStr)),\n        { nodes: valueNode },\n      );\n    }\n    return enumValue.value;\n  }\n\n  valueToLiteral(value: unknown): ConstValueNode | undefined {\n    if (typeof value === 'string' && this.getValue(value)) {\n      return { kind: Kind.ENUM, value };\n    }\n  }\n\n  toConfig(): GraphQLEnumTypeNormalizedConfig {\n    const values = keyValMap(\n      this.getValues(),\n      (value) => value.name,\n      (value) => ({\n        description: value.description,\n        value: value.value,\n        deprecationReason: value.deprecationReason,\n        extensions: value.extensions,\n        astNode: value.astNode,\n      }),\n    );\n\n    return {\n      name: this.name,\n      description: this.description,\n      values,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n    };\n  }\n\n  toString(): string {\n    return this.name;\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\nfunction didYouMeanEnumValue(\n  enumType: GraphQLEnumType,\n  unknownValueStr: string,\n): string {\n  const allNames = enumType.getValues().map((value) => value.name);\n  const suggestedValues = suggestionList(unknownValueStr, allNames);\n\n  return didYouMean('the enum value', suggestedValues);\n}\n\nexport interface GraphQLEnumTypeConfig {\n  name: string;\n  description?: Maybe<string>;\n  values: ThunkObjMap<GraphQLEnumValueConfig /* <T> */>;\n  extensions?: Maybe<Readonly<GraphQLEnumTypeExtensions>>;\n  astNode?: Maybe<EnumTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<EnumTypeExtensionNode>>;\n}\n\ninterface GraphQLEnumTypeNormalizedConfig extends GraphQLEnumTypeConfig {\n  values: ObjMap<GraphQLEnumValueConfig /* <T> */>;\n  extensions: Readonly<GraphQLEnumTypeExtensions>;\n  extensionASTNodes: ReadonlyArray<EnumTypeExtensionNode>;\n}\n\nexport type GraphQLEnumValueConfigMap /* <T> */ =\n  ObjMap<GraphQLEnumValueConfig /* <T> */>;\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLEnumValueExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\nexport interface GraphQLEnumValueConfig {\n  description?: Maybe<string>;\n  value?: any /* T */;\n  deprecationReason?: Maybe<string>;\n  extensions?: Maybe<Readonly<GraphQLEnumValueExtensions>>;\n  astNode?: Maybe<EnumValueDefinitionNode>;\n}\n\nexport interface GraphQLEnumValue {\n  name: string;\n  description: Maybe<string>;\n  value: any /* T */;\n  deprecationReason: Maybe<string>;\n  extensions: Readonly<GraphQLEnumValueExtensions>;\n  astNode: Maybe<EnumValueDefinitionNode>;\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLInputObjectTypeExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n * ```ts\n * const GeoPoint = new GraphQLInputObjectType({\n *   name: 'GeoPoint',\n *   fields: {\n *     lat: { type: new GraphQLNonNull(GraphQLFloat) },\n *     lon: { type: new GraphQLNonNull(GraphQLFloat) },\n *     alt: { type: GraphQLFloat, defaultValue: 0 },\n *   }\n * });\n * ```\n */\nexport class GraphQLInputObjectType {\n  name: string;\n  description: Maybe<string>;\n  extensions: Readonly<GraphQLInputObjectTypeExtensions>;\n  astNode: Maybe<InputObjectTypeDefinitionNode>;\n  extensionASTNodes: ReadonlyArray<InputObjectTypeExtensionNode>;\n  isOneOf: boolean;\n\n  private _fields: ThunkObjMap<GraphQLInputField>;\n\n  constructor(config: Readonly<GraphQLInputObjectTypeConfig>) {\n    this.name = assertName(config.name);\n    this.description = config.description;\n    this.extensions = toObjMapWithSymbols(config.extensions);\n    this.astNode = config.astNode;\n    this.extensionASTNodes = config.extensionASTNodes ?? [];\n    this.isOneOf = config.isOneOf ?? false;\n\n    this._fields = defineInputFieldMap.bind(undefined, config.fields);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'GraphQLInputObjectType';\n  }\n\n  getFields(): GraphQLInputFieldMap {\n    if (typeof this._fields === 'function') {\n      this._fields = this._fields();\n    }\n    return this._fields;\n  }\n\n  toConfig(): GraphQLInputObjectTypeNormalizedConfig {\n    const fields = mapValue(this.getFields(), (field) => ({\n      description: field.description,\n      type: field.type,\n      defaultValue: field.defaultValue?.value,\n      defaultValueLiteral: field.defaultValue?.literal,\n      deprecationReason: field.deprecationReason,\n      extensions: field.extensions,\n      astNode: field.astNode,\n    }));\n\n    return {\n      name: this.name,\n      description: this.description,\n      fields,\n      extensions: this.extensions,\n      astNode: this.astNode,\n      extensionASTNodes: this.extensionASTNodes,\n      isOneOf: this.isOneOf,\n    };\n  }\n\n  toString(): string {\n    return this.name;\n  }\n\n  toJSON(): string {\n    return this.toString();\n  }\n}\n\nfunction defineInputFieldMap(\n  fields: ThunkObjMap<GraphQLInputFieldConfig>,\n): GraphQLInputFieldMap {\n  const fieldMap = resolveObjMapThunk(fields);\n  return mapValue(fieldMap, (fieldConfig, fieldName) => ({\n    name: assertName(fieldName),\n    description: fieldConfig.description,\n    type: fieldConfig.type,\n    defaultValue: defineDefaultValue(fieldName, fieldConfig),\n    deprecationReason: fieldConfig.deprecationReason,\n    extensions: toObjMapWithSymbols(fieldConfig.extensions),\n    astNode: fieldConfig.astNode,\n  }));\n}\n\nexport interface GraphQLInputObjectTypeConfig {\n  name: string;\n  description?: Maybe<string>;\n  fields: ThunkObjMap<GraphQLInputFieldConfig>;\n  extensions?: Maybe<Readonly<GraphQLInputObjectTypeExtensions>>;\n  astNode?: Maybe<InputObjectTypeDefinitionNode>;\n  extensionASTNodes?: Maybe<ReadonlyArray<InputObjectTypeExtensionNode>>;\n  isOneOf?: boolean;\n}\n\ninterface GraphQLInputObjectTypeNormalizedConfig\n  extends GraphQLInputObjectTypeConfig {\n  fields: GraphQLInputFieldConfigMap;\n  extensions: Readonly<GraphQLInputObjectTypeExtensions>;\n  extensionASTNodes: ReadonlyArray<InputObjectTypeExtensionNode>;\n}\n\n/**\n * Custom extensions\n *\n * @remarks\n * Use a unique identifier name for your extension, for example the name of\n * your library or project. Do not use a shortened identifier as this increases\n * the risk of conflicts. We recommend you add at most one extension field,\n * an object which can contain all the values you need.\n */\nexport interface GraphQLInputFieldExtensions {\n  [attributeName: string | symbol]: unknown;\n}\n\nexport interface GraphQLInputFieldConfig {\n  description?: Maybe<string>;\n  type: GraphQLInputType;\n  defaultValue?: unknown;\n  defaultValueLiteral?: ConstValueNode | undefined;\n  deprecationReason?: Maybe<string>;\n  extensions?: Maybe<Readonly<GraphQLInputFieldExtensions>>;\n  astNode?: Maybe<InputValueDefinitionNode>;\n}\n\nexport type GraphQLInputFieldConfigMap = ObjMap<GraphQLInputFieldConfig>;\n\nexport interface GraphQLInputField {\n  name: string;\n  description: Maybe<string>;\n  type: GraphQLInputType;\n  defaultValue: GraphQLDefaultValueUsage | undefined;\n  deprecationReason: Maybe<string>;\n  extensions: Readonly<GraphQLInputFieldExtensions>;\n  astNode: Maybe<InputValueDefinitionNode>;\n}\n\nexport function isRequiredInputField(field: GraphQLInputField): boolean {\n  return isNonNullType(field.type) && field.defaultValue === undefined;\n}\n\nexport type GraphQLInputFieldMap = ObjMap<GraphQLInputField>;\n"]}