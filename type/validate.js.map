{"version":3,"file":"validate.js","sourceRoot":"","sources":["../../src/type/validate.ts"],"names":[],"mappings":"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","sourcesContent":["import { AccumulatorMap } from '../jsutils/AccumulatorMap.js';\nimport { capitalize } from '../jsutils/capitalize.js';\nimport { andList } from '../jsutils/formatList.js';\nimport { inspect } from '../jsutils/inspect.js';\nimport { invariant } from '../jsutils/invariant.js';\nimport { isIterableObject } from '../jsutils/isIterableObject.js';\nimport { isObjectLike } from '../jsutils/isObjectLike.js';\nimport { keyMap } from '../jsutils/keyMap.js';\nimport { mapValue } from '../jsutils/mapValue.js';\nimport type { Maybe } from '../jsutils/Maybe.js';\nimport type { ObjMap } from '../jsutils/ObjMap.js';\nimport { printPathArray } from '../jsutils/printPathArray.js';\n\nimport { GraphQLError } from '../error/GraphQLError.js';\n\nimport type {\n  ASTNode,\n  ConstValueNode,\n  DirectiveNode,\n  InterfaceTypeDefinitionNode,\n  InterfaceTypeExtensionNode,\n  NamedTypeNode,\n  ObjectTypeDefinitionNode,\n  ObjectTypeExtensionNode,\n  UnionTypeDefinitionNode,\n  UnionTypeExtensionNode,\n} from '../language/ast.js';\nimport { OperationTypeNode } from '../language/ast.js';\nimport { Kind } from '../language/kinds.js';\n\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators.js';\nimport {\n  validateInputLiteral,\n  validateInputValue,\n} from '../utilities/validateInputValue.js';\n\nimport type {\n  GraphQLArgument,\n  GraphQLEnumType,\n  GraphQLInputField,\n  GraphQLInputObjectType,\n  GraphQLInputType,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLUnionType,\n} from './definition.js';\nimport {\n  assertLeafType,\n  getNamedType,\n  isEnumType,\n  isInputObjectType,\n  isInputType,\n  isInterfaceType,\n  isListType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isOutputType,\n  isRequiredArgument,\n  isRequiredInputField,\n  isUnionType,\n} from './definition.js';\nimport { GraphQLDeprecatedDirective, isDirective } from './directives.js';\nimport { isIntrospectionType } from './introspection.js';\nimport type { GraphQLSchema } from './schema.js';\nimport { assertSchema } from './schema.js';\n\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\nexport function validateSchema(\n  schema: GraphQLSchema,\n): ReadonlyArray<GraphQLError> {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema);\n\n  // If this Schema has already been validated, return the previous results.\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  }\n\n  // Validate the schema, producing a list of errors.\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context);\n\n  // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n  const errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\nexport function assertValidSchema(schema: GraphQLSchema): void {\n  const errors = validateSchema(schema);\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n\nclass SchemaValidationContext {\n  readonly _errors: Array<GraphQLError>;\n  readonly schema: GraphQLSchema;\n\n  constructor(schema: GraphQLSchema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  reportError(\n    message: string,\n    nodes?: ReadonlyArray<Maybe<ASTNode>> | Maybe<ASTNode>,\n  ): void {\n    const _nodes = Array.isArray(nodes)\n      ? (nodes.filter(Boolean) as ReadonlyArray<ASTNode>)\n      : (nodes as Maybe<ASTNode>);\n    this._errors.push(new GraphQLError(message, { nodes: _nodes }));\n  }\n\n  getErrors(): ReadonlyArray<GraphQLError> {\n    return this._errors;\n  }\n}\n\nfunction validateRootTypes(context: SchemaValidationContext): void {\n  const schema = context.schema;\n\n  if (schema.getQueryType() == null) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  }\n\n  const rootTypesMap = new AccumulatorMap<\n    GraphQLObjectType,\n    OperationTypeNode\n  >();\n  for (const operationType of Object.values(OperationTypeNode)) {\n    const rootType = schema.getRootType(operationType);\n\n    if (rootType != null) {\n      if (!isObjectType(rootType)) {\n        const operationTypeStr = capitalize(operationType);\n        const rootTypeStr = inspect(rootType);\n        context.reportError(\n          operationType === OperationTypeNode.QUERY\n            ? `${operationTypeStr} root type must be Object type, it cannot be ${rootTypeStr}.`\n            : `${operationTypeStr} root type must be Object type if provided, it cannot be ${rootTypeStr}.`,\n          getOperationTypeNode(schema, operationType) ??\n            (rootType as any).astNode,\n        );\n      } else {\n        rootTypesMap.add(rootType, operationType);\n      }\n    }\n  }\n\n  for (const [rootType, operationTypes] of rootTypesMap) {\n    if (operationTypes.length > 1) {\n      const operationList = andList(operationTypes);\n      context.reportError(\n        `All root types must be different, \"${rootType}\" type is used as ${operationList} root types.`,\n        operationTypes.map((operationType) =>\n          getOperationTypeNode(schema, operationType),\n        ),\n      );\n    }\n  }\n}\n\nfunction getOperationTypeNode(\n  schema: GraphQLSchema,\n  operation: OperationTypeNode,\n): Maybe<ASTNode> {\n  return [schema.astNode, ...schema.extensionASTNodes]\n    .flatMap((schemaNode) => schemaNode?.operationTypes ?? [])\n    .find((operationNode) => operationNode.operation === operation)?.type;\n}\n\nfunction validateDirectives(context: SchemaValidationContext): void {\n  for (const directive of context.schema.getDirectives()) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(\n        `Expected directive but got: ${inspect(directive)}.`,\n        (directive as any)?.astNode,\n      );\n      continue;\n    }\n\n    // Ensure they are named correctly.\n    validateName(context, directive);\n\n    if (directive.locations.length === 0) {\n      context.reportError(\n        `Directive ${directive} must include 1 or more locations.`,\n        directive.astNode,\n      );\n    }\n\n    // Ensure the arguments are valid.\n    for (const arg of directive.args) {\n      // Ensure they are named correctly.\n      validateName(context, arg);\n\n      const argStr = `${directive}(${arg.name}:)`;\n\n      // Ensure the type is an input type.\n      if (!isInputType(arg.type)) {\n        context.reportError(\n          `The type of ${argStr} must be Input Type ` +\n            `but got: ${inspect(arg.type)}.`,\n          arg.astNode,\n        );\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        context.reportError(\n          `Required argument ${argStr} cannot be deprecated.`,\n          [getDeprecatedDirectiveNode(arg.astNode), arg.astNode?.type],\n        );\n      }\n\n      validateDefaultValue(context, arg, argStr);\n    }\n  }\n}\n\nfunction validateDefaultValue(\n  context: SchemaValidationContext,\n  inputValue: GraphQLArgument | GraphQLInputField,\n  argStr: string,\n): void {\n  const defaultValue = inputValue.defaultValue;\n\n  if (!defaultValue) {\n    return;\n  }\n\n  if (defaultValue.literal) {\n    validateInputLiteral(\n      defaultValue.literal,\n      inputValue.type,\n      (error, path) => {\n        context.reportError(\n          `${argStr} has invalid default value${printPathArray(path)}: ${\n            error.message\n          }`,\n          error.nodes,\n        );\n      },\n    );\n  } else {\n    const errors: Array<[GraphQLError, ReadonlyArray<string | number>]> = [];\n    validateInputValue(defaultValue.value, inputValue.type, (error, path) => {\n      errors.push([error, path]);\n    });\n\n    // If there were validation errors, check to see if it can be \"uncoerced\"\n    // and then correctly validated. If so, report a clear error with a path\n    // to resolution.\n    if (errors.length > 0) {\n      try {\n        const uncoercedValue = uncoerceDefaultValue(\n          defaultValue.value,\n          inputValue.type,\n        );\n\n        const uncoercedErrors = [];\n        validateInputValue(uncoercedValue, inputValue.type, (error, path) => {\n          uncoercedErrors.push([error, path]);\n        });\n\n        if (uncoercedErrors.length === 0) {\n          context.reportError(\n            `${argStr} has invalid default value: ${inspect(\n              defaultValue.value,\n            )}. Did you mean: ${inspect(uncoercedValue)}?`,\n            inputValue.astNode?.defaultValue,\n          );\n          return;\n        }\n      } catch (_error) {\n        // ignore\n      }\n    }\n\n    // Otherwise report the original set of errors.\n    for (const [error, path] of errors) {\n      context.reportError(\n        `${argStr} has invalid default value${printPathArray(path)}: ${\n          error.message\n        }`,\n        inputValue.astNode?.defaultValue,\n      );\n    }\n  }\n}\n\n/**\n * Historically GraphQL.js allowed default values to be provided as\n * assumed-coerced \"internal\" values, however default values should be provided\n * as \"external\" pre-coerced values. `uncoerceDefaultValue()` will convert such\n * \"internal\" values to \"external\" values to display as part of validation.\n *\n * This performs the \"opposite\" of `coerceInputValue()`. Given an \"internal\"\n * coerced value, reverse the process to provide an \"external\" uncoerced value.\n */\nfunction uncoerceDefaultValue(value: unknown, type: GraphQLInputType): unknown {\n  if (isNonNullType(type)) {\n    return uncoerceDefaultValue(value, type.ofType);\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (isListType(type)) {\n    if (isIterableObject(value)) {\n      return Array.from(value, (itemValue) =>\n        uncoerceDefaultValue(itemValue, type.ofType),\n      );\n    }\n    return [uncoerceDefaultValue(value, type.ofType)];\n  }\n\n  if (isInputObjectType(type)) {\n    invariant(isObjectLike(value));\n    const fieldDefs = type.getFields();\n    return mapValue(value, (fieldValue, fieldName) => {\n      invariant(fieldName in fieldDefs);\n      return uncoerceDefaultValue(fieldValue, fieldDefs[fieldName].type);\n    });\n  }\n\n  assertLeafType(type);\n\n  // For most leaf types (Scalars, Enums), output value coercion (\"serialize\") is\n  // the inverse of input coercion (\"parseValue\") and will produce an\n  // \"external\" value. Historically, this method was also used as part of the\n  // now-deprecated \"astFromValue\" to perform the same behavior.\n  return type.coerceOutputValue(value);\n}\n\nfunction validateName(\n  context: SchemaValidationContext,\n  node: { readonly name: string; readonly astNode: Maybe<ASTNode> },\n): void {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(\n      `Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\n      node.astNode,\n    );\n  }\n}\n\nfunction validateTypes(context: SchemaValidationContext): void {\n  // Ensure Input Objects do not contain non-nullable circular references.\n  const validateInputObjectNonNullCircularRefs =\n    createInputObjectNonNullCircularRefsValidator(context);\n  const validateInputObjectDefaultValueCircularRefs =\n    createInputObjectDefaultValueCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n  for (const type of Object.values(typeMap)) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\n        `Expected GraphQL named type but got: ${inspect(type)}.`,\n        (type as any).astNode,\n      );\n      continue;\n    }\n\n    // Ensure it is named correctly (excluding introspection types).\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type);\n\n      // Ensure objects implement the interfaces they claim to.\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type);\n\n      // Ensure interfaces implement the interfaces they claim to.\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type);\n\n      // Ensure Input Objects do not contain invalid field circular references.\n      // Ensure Input Objects do not contain non-nullable circular references.\n      validateInputObjectNonNullCircularRefs(type);\n\n      // Ensure Input Objects do not contain invalid default value circular references.\n      validateInputObjectDefaultValueCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(\n  context: SchemaValidationContext,\n  type: GraphQLObjectType | GraphQLInterfaceType,\n): void {\n  const fields = Object.values(type.getFields());\n\n  // Objects and Interfaces both must define one or more fields.\n  if (fields.length === 0) {\n    context.reportError(`Type ${type} must define one or more fields.`, [\n      type.astNode,\n      ...type.extensionASTNodes,\n    ]);\n  }\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field);\n\n    // Ensure the type is an output type\n    if (!isOutputType(field.type)) {\n      context.reportError(\n        `The type of ${type}.${field.name} must be Output Type ` +\n          `but got: ${inspect(field.type)}.`,\n        field.astNode?.type,\n      );\n    }\n\n    // Ensure the arguments are valid\n    for (const arg of field.args) {\n      const argName = arg.name;\n\n      // Ensure they are named correctly.\n      validateName(context, arg);\n\n      const argStr = `${type}.${field.name}(${argName}:)`;\n\n      // Ensure the type is an input type\n      if (!isInputType(arg.type)) {\n        context.reportError(\n          `The type of ${argStr} must be Input Type but got: ${inspect(arg.type)}.`,\n          arg.astNode?.type,\n        );\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        context.reportError(\n          `Required argument ${type}.${field.name}(${argName}:) cannot be deprecated.`,\n          [getDeprecatedDirectiveNode(arg.astNode), arg.astNode?.type],\n        );\n      }\n\n      validateDefaultValue(context, arg, argStr);\n    }\n  }\n}\n\nfunction validateInterfaces(\n  context: SchemaValidationContext,\n  type: GraphQLObjectType | GraphQLInterfaceType,\n): void {\n  const ifaceTypeNames = new Set<string>();\n  for (const iface of type.getInterfaces()) {\n    if (!isInterfaceType(iface)) {\n      context.reportError(\n        `Type ${inspect(type)} must only implement Interface types, ` +\n          `it cannot implement ${inspect(iface)}.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(\n        `Type ${type} cannot implement itself because it would create a circular reference.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (ifaceTypeNames.has(iface.name)) {\n      context.reportError(\n        `Type ${type} can only implement ${iface.name} once.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    ifaceTypeNames.add(iface.name);\n\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(\n  context: SchemaValidationContext,\n  type: GraphQLObjectType | GraphQLInterfaceType,\n  iface: GraphQLInterfaceType,\n): void {\n  const typeFieldMap = type.getFields();\n\n  // Assert each interface field is implemented.\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName];\n\n    // Assert interface field exists on type.\n    if (typeField == null) {\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expected but ${type} does not provide it.`,\n        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes],\n      );\n      continue;\n    }\n\n    // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expects type ` +\n          `${inspect(ifaceField.type)} but ${type}.${fieldName} ` +\n          `is type ${inspect(typeField.type)}.`,\n        [ifaceField.astNode?.type, typeField.astNode?.type],\n      );\n    }\n\n    // Assert each interface field arg is implemented.\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find((arg) => arg.name === argName);\n\n      // Assert interface field arg exists on object field.\n      if (!typeArg) {\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type}.${fieldName} does not provide it.`,\n          [ifaceArg.astNode, typeField.astNode],\n        );\n        continue;\n      }\n\n      // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) ` +\n            `expects type ${inspect(ifaceArg.type)} but ` +\n            `${type}.${fieldName}(${argName}:) is type ` +\n            `${inspect(typeArg.type)}.`,\n          [ifaceArg.astNode?.type, typeArg.astNode?.type],\n        );\n      }\n    }\n\n    // Assert additional arguments must not be required.\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(\n          `Argument \"${type}.${fieldName}(${argName}:)\" must not be required type \"${inspect(\n            typeArg.type,\n          )}\" if not provided by the Interface field \"${\n            iface.name\n          }.${fieldName}\".`,\n          [typeArg.astNode, ifaceField.astNode],\n        );\n      }\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(\n  context: SchemaValidationContext,\n  type: GraphQLObjectType | GraphQLInterfaceType,\n  iface: GraphQLInterfaceType,\n): void {\n  const ifaceInterfaces = type.getInterfaces();\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(\n        transitive === type\n          ? `Type ${type} cannot implement ${iface.name} because it would create a circular reference.`\n          : `Type ${type} must implement ${transitive.name} because it is implemented by ${iface.name}.`,\n        [\n          ...getAllImplementsInterfaceNodes(iface, transitive),\n          ...getAllImplementsInterfaceNodes(type, iface),\n        ],\n      );\n    }\n  }\n}\n\nfunction validateUnionMembers(\n  context: SchemaValidationContext,\n  union: GraphQLUnionType,\n): void {\n  const memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\n      `Union type ${union.name} must define one or more member types.`,\n      [union.astNode, ...union.extensionASTNodes],\n    );\n  }\n\n  const includedTypeNames = new Set<string>();\n  for (const memberType of memberTypes) {\n    if (includedTypeNames.has(memberType.name)) {\n      context.reportError(\n        `Union type ${union.name} can only include type ${memberType} once.`,\n        getUnionMemberTypeNodes(union, memberType.name),\n      );\n      continue;\n    }\n    includedTypeNames.add(memberType.name);\n    if (!isObjectType(memberType)) {\n      context.reportError(\n        `Union type ${union.name} can only include Object types, ` +\n          `it cannot include ${inspect(memberType)}.`,\n        getUnionMemberTypeNodes(union, String(memberType)),\n      );\n    }\n  }\n}\n\nfunction validateEnumValues(\n  context: SchemaValidationContext,\n  enumType: GraphQLEnumType,\n): void {\n  const enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\n      `Enum type ${enumType} must define one or more values.`,\n      [enumType.astNode, ...enumType.extensionASTNodes],\n    );\n  }\n\n  for (const enumValue of enumValues) {\n    // Ensure valid name.\n    validateName(context, enumValue);\n  }\n}\n\nfunction validateInputFields(\n  context: SchemaValidationContext,\n  inputObj: GraphQLInputObjectType,\n): void {\n  const fields = Object.values(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\n      `Input Object type ${inputObj.name} must define one or more fields.`,\n      [inputObj.astNode, ...inputObj.extensionASTNodes],\n    );\n  }\n\n  // Ensure the input fields are valid\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field);\n\n    // Ensure the type is an input type\n    if (!isInputType(field.type)) {\n      context.reportError(\n        `The type of ${inputObj.name}.${field.name} must be Input Type ` +\n          `but got: ${inspect(field.type)}.`,\n        field.astNode?.type,\n      );\n    }\n\n    const fieldStr = `${inputObj.name}.${field.name}`;\n\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      context.reportError(\n        `Required input field ${fieldStr} cannot be deprecated.`,\n        [getDeprecatedDirectiveNode(field.astNode), field.astNode?.type],\n      );\n    }\n\n    validateDefaultValue(context, field, fieldStr);\n\n    if (inputObj.isOneOf) {\n      validateOneOfInputObjectField(inputObj, field, context);\n    }\n  }\n}\n\nfunction validateOneOfInputObjectField(\n  type: GraphQLInputObjectType,\n  field: GraphQLInputField,\n  context: SchemaValidationContext,\n): void {\n  if (isNonNullType(field.type)) {\n    context.reportError(\n      `OneOf input field ${type}.${field.name} must be nullable.`,\n      field.astNode?.type,\n    );\n  }\n\n  if (field.defaultValue !== undefined) {\n    context.reportError(\n      `OneOf input field ${type}.${field.name} cannot have a default value.`,\n      field.astNode,\n    );\n  }\n}\n\nfunction createInputObjectNonNullCircularRefsValidator(\n  context: SchemaValidationContext,\n): (inputObj: GraphQLInputObjectType) => void {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedTypes = new Set<GraphQLInputObjectType>();\n\n  // Array of types nodes used to produce meaningful errors\n  const fieldPath: Array<{ fieldStr: string; astNode: Maybe<ASTNode> }> = [];\n\n  // Position in the type path\n  const fieldPathIndexByTypeName: ObjMap<number | undefined> =\n    Object.create(null);\n\n  return detectCycleRecursive;\n\n  // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n  function detectCycleRecursive(inputObj: GraphQLInputObjectType): void {\n    if (visitedTypes.has(inputObj)) {\n      return;\n    }\n\n    visitedTypes.add(inputObj);\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n\n    const fields = Object.values(inputObj.getFields());\n    for (const field of fields) {\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n\n        fieldPath.push({\n          fieldStr: `${inputObj}.${field.name}`,\n          astNode: field.astNode,\n        });\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath\n            .map((fieldObj) => fieldObj.fieldStr)\n            .join(', ');\n          context.reportError(\n            `Invalid circular reference. The Input Object ${fieldType} references itself ${\n              cyclePath.length > 1\n                ? 'via the non-null fields:'\n                : 'in the non-null field'\n            } ${pathStr}.`,\n            cyclePath.map((fieldObj) => fieldObj.astNode),\n          );\n        }\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction createInputObjectDefaultValueCircularRefsValidator(\n  context: SchemaValidationContext,\n): (inputObj: GraphQLInputObjectType) => void {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedFields = Object.create(null);\n\n  // Array of keys for fields and default values used to produce meaningful errors.\n  const fieldPath: Array<\n    [fieldStr: string, defaultValue: ConstValueNode | undefined]\n  > = [];\n\n  // Position in the path\n  const fieldPathIndex: ObjMap<number | undefined> = Object.create(null);\n\n  // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n  return function validateInputObjectDefaultValueCircularRefs(\n    inputObj: GraphQLInputObjectType,\n  ): void {\n    // Start with an empty object as a way to visit every field in this input\n    // object type and apply every default value.\n    return detectValueDefaultValueCycle(inputObj, {});\n  };\n\n  function detectValueDefaultValueCycle(\n    inputObj: GraphQLInputObjectType,\n    defaultValue: unknown,\n  ): void {\n    // If the value is a List, recursively check each entry for a cycle.\n    // Otherwise, only object values can contain a cycle.\n    if (isIterableObject(defaultValue)) {\n      for (const itemValue of defaultValue) {\n        detectValueDefaultValueCycle(inputObj, itemValue);\n      }\n      return;\n    } else if (!isObjectLike(defaultValue)) {\n      return;\n    }\n\n    // Check each defined field for a cycle.\n    for (const field of Object.values(inputObj.getFields())) {\n      const namedFieldType = getNamedType(field.type);\n\n      // Only input object type fields can result in a cycle.\n      if (!isInputObjectType(namedFieldType)) {\n        continue;\n      }\n\n      if (Object.hasOwn(defaultValue, field.name)) {\n        // If the provided value has this field defined, recursively check it\n        // for cycles.\n        detectValueDefaultValueCycle(namedFieldType, defaultValue[field.name]);\n      } else {\n        // Otherwise check this field's default value for cycles.\n        detectFieldDefaultValueCycle(\n          field,\n          namedFieldType,\n          `${inputObj}.${field.name}`,\n        );\n      }\n    }\n  }\n\n  function detectLiteralDefaultValueCycle(\n    inputObj: GraphQLInputObjectType,\n    defaultValue: ConstValueNode,\n  ): void {\n    // If the value is a List, recursively check each entry for a cycle.\n    // Otherwise, only object values can contain a cycle.\n    if (defaultValue.kind === Kind.LIST) {\n      for (const itemLiteral of defaultValue.values) {\n        detectLiteralDefaultValueCycle(inputObj, itemLiteral);\n      }\n      return;\n    } else if (defaultValue.kind !== Kind.OBJECT) {\n      return;\n    }\n\n    // Check each defined field for a cycle.\n    const fieldNodes = keyMap(defaultValue.fields, (field) => field.name.value);\n    for (const field of Object.values(inputObj.getFields())) {\n      const namedFieldType = getNamedType(field.type);\n\n      // Only input object type fields can result in a cycle.\n      if (!isInputObjectType(namedFieldType)) {\n        continue;\n      }\n\n      if (Object.hasOwn(fieldNodes, field.name)) {\n        // If the provided value has this field defined, recursively check it\n        // for cycles.\n        detectLiteralDefaultValueCycle(\n          namedFieldType,\n          fieldNodes[field.name].value,\n        );\n      } else {\n        // Otherwise check this field's default value for cycles.\n        detectFieldDefaultValueCycle(\n          field,\n          namedFieldType,\n          `${inputObj}.${field.name}`,\n        );\n      }\n    }\n  }\n\n  function detectFieldDefaultValueCycle(\n    field: GraphQLInputField,\n    fieldType: GraphQLInputObjectType,\n    fieldStr: string,\n  ): void {\n    // Only a field with a default value can result in a cycle.\n    const defaultValue = field.defaultValue;\n    if (defaultValue === undefined) {\n      return;\n    }\n\n    // Check to see if there is cycle.\n    const cycleIndex = fieldPathIndex[fieldStr];\n    if (cycleIndex !== undefined && cycleIndex > 0) {\n      context.reportError(\n        `Invalid circular reference. The default value of Input Object field ${fieldStr} references itself${\n          cycleIndex < fieldPath.length\n            ? ` via the default values of: ${fieldPath\n                .slice(cycleIndex)\n                .map(([stringForMessage]) => stringForMessage)\n                .join(', ')}`\n            : ''\n        }.`,\n        fieldPath.slice(cycleIndex - 1).map(([, node]) => node),\n      );\n      return;\n    }\n\n    // Recurse into this field's default value once, tracking the path.\n    if (visitedFields[fieldStr] === undefined) {\n      visitedFields[fieldStr] = true;\n      fieldPathIndex[fieldStr] = fieldPath.push([\n        fieldStr,\n        field.astNode?.defaultValue,\n      ]);\n      if (defaultValue.literal) {\n        detectLiteralDefaultValueCycle(fieldType, defaultValue.literal);\n      } else {\n        detectValueDefaultValueCycle(fieldType, defaultValue.value);\n      }\n      fieldPath.pop();\n      fieldPathIndex[fieldStr] = undefined;\n    }\n  }\n}\n\nfunction getAllImplementsInterfaceNodes(\n  type: GraphQLObjectType | GraphQLInterfaceType,\n  iface: GraphQLInterfaceType,\n): ReadonlyArray<NamedTypeNode> {\n  const { astNode, extensionASTNodes } = type;\n  const nodes: ReadonlyArray<\n    | ObjectTypeDefinitionNode\n    | ObjectTypeExtensionNode\n    | InterfaceTypeDefinitionNode\n    | InterfaceTypeExtensionNode\n  > = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;\n\n  return nodes\n    .flatMap((typeNode) => typeNode.interfaces ?? [])\n    .filter((ifaceNode) => ifaceNode.name.value === iface.name);\n}\n\nfunction getUnionMemberTypeNodes(\n  union: GraphQLUnionType,\n  typeName: string,\n): ReadonlyArray<NamedTypeNode> {\n  const { astNode, extensionASTNodes } = union;\n  const nodes: ReadonlyArray<UnionTypeDefinitionNode | UnionTypeExtensionNode> =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;\n\n  return nodes\n    .flatMap((unionNode) => /* c8 ignore next */ unionNode.types ?? [])\n    .filter((typeNode) => typeNode.name.value === typeName);\n}\n\nfunction getDeprecatedDirectiveNode(\n  definitionNode: Maybe<{\n    readonly directives?: ReadonlyArray<DirectiveNode> | undefined;\n  }>,\n): Maybe<DirectiveNode> {\n  return definitionNode?.directives?.find(\n    (node) => node.name.value === GraphQLDeprecatedDirective.name,\n  );\n}\n"]}