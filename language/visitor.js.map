{"version":3,"file":"visitor.js","sourceRoot":"","sources":["../../src/language/visitor.ts"],"names":[],"mappings":";;;AAgLA,sBA8HC;AAQD,0CA2DC;AAKD,oDAmBC;AAzYD,0DAAoD;AACpD,sDAAgD;AAGhD,qCAAqD;AACrD,yCAAkC;AAiFrB,QAAA,KAAK,GAAY,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AA0FhD,SAAgB,KAAK,CACnB,IAAa,EACb,OAAqC,EACrC,cAAgC,0BAAiB;IAEjD,MAAM,aAAa,GAAG,IAAI,GAAG,EAAoC,CAAC;IAClE,KAAK,MAAM,IAAI,IAAI,MAAM,CAAC,MAAM,CAAC,eAAI,CAAC,EAAE,CAAC;QACvC,aAAa,CAAC,GAAG,CAAC,IAAI,EAAE,oBAAoB,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC;IAC/D,CAAC;IAED,kCAAkC;IAClC,IAAI,KAAK,GAAQ,SAAS,CAAC;IAC3B,IAAI,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IAClC,IAAI,IAAI,GAAQ,CAAC,IAAI,CAAC,CAAC;IACvB,IAAI,KAAK,GAAG,CAAC,CAAC,CAAC;IACf,IAAI,KAAK,GAAG,EAAE,CAAC;IACf,IAAI,IAAI,GAAQ,IAAI,CAAC;IACrB,IAAI,GAAG,GAAQ,SAAS,CAAC;IACzB,IAAI,MAAM,GAAQ,SAAS,CAAC;IAC5B,MAAM,IAAI,GAAQ,EAAE,CAAC;IACrB,MAAM,SAAS,GAAG,EAAE,CAAC;IACrB,iCAAiC;IAEjC,GAAG,CAAC;QACF,KAAK,EAAE,CAAC;QACR,MAAM,SAAS,GAAG,KAAK,KAAK,IAAI,CAAC,MAAM,CAAC;QACxC,MAAM,QAAQ,GAAG,SAAS,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC;QACjD,IAAI,SAAS,EAAE,CAAC;YACd,GAAG,GAAG,SAAS,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YACjE,IAAI,GAAG,MAAM,CAAC;YACd,MAAM,GAAG,SAAS,CAAC,GAAG,EAAE,CAAC;YACzB,IAAI,QAAQ,EAAE,CAAC;gBACb,IAAI,OAAO,EAAE,CAAC;oBACZ,IAAI,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC;oBAEpB,IAAI,UAAU,GAAG,CAAC,CAAC;oBACnB,KAAK,MAAM,CAAC,OAAO,EAAE,SAAS,CAAC,IAAI,KAAK,EAAE,CAAC;wBACzC,MAAM,QAAQ,GAAG,OAAO,GAAG,UAAU,CAAC;wBACtC,IAAI,SAAS,KAAK,IAAI,EAAE,CAAC;4BACvB,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;4BACzB,UAAU,EAAE,CAAC;wBACf,CAAC;6BAAM,CAAC;4BACN,IAAI,CAAC,QAAQ,CAAC,GAAG,SAAS,CAAC;wBAC7B,CAAC;oBACH,CAAC;gBACH,CAAC;qBAAM,CAAC;oBACN,IAAI,GAAG,MAAM,CAAC,gBAAgB,CAC5B,EAAE,EACF,MAAM,CAAC,yBAAyB,CAAC,IAAI,CAAC,CACvC,CAAC;oBACF,KAAK,MAAM,CAAC,OAAO,EAAE,SAAS,CAAC,IAAI,KAAK,EAAE,CAAC;wBACzC,IAAI,CAAC,OAAO,CAAC,GAAG,SAAS,CAAC;oBAC5B,CAAC;gBACH,CAAC;YACH,CAAC;YACD,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;YACpB,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;YAClB,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;YACpB,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;YACxB,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC;QACrB,CAAC;aAAM,IAAI,MAAM,IAAI,IAAI,EAAE,CAAC;YAC1B,GAAG,GAAG,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACpC,IAAI,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;YACnB,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,SAAS,EAAE,CAAC;gBACxC,SAAS;YACX,CAAC;YACD,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACjB,CAAC;QAED,IAAI,MAAM,CAAC;QACX,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC;YACzB,CAAU,IAAA,eAAM,EAAC,IAAI,CAAC,SAAtB,wBAAS,SAAe,qBAAqB,IAAA,oBAAO,EAAC,IAAI,CAAC,GAAG,EAAE;YAE/D,MAAM,OAAO,GAAG,SAAS;gBACvB,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,KAAK;gBACrC,CAAC,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC;YAExC,MAAM,GAAG,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;YAEpE,IAAI,MAAM,KAAK,aAAK,EAAE,CAAC;gBACrB,MAAM;YACR,CAAC;YAED,IAAI,MAAM,KAAK,KAAK,EAAE,CAAC;gBACrB,IAAI,CAAC,SAAS,EAAE,CAAC;oBACf,IAAI,CAAC,GAAG,EAAE,CAAC;oBACX,SAAS;gBACX,CAAC;YACH,CAAC;iBAAM,IAAI,MAAM,KAAK,SAAS,EAAE,CAAC;gBAChC,KAAK,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC,CAAC;gBAC1B,IAAI,CAAC,SAAS,EAAE,CAAC;oBACf,IAAI,IAAA,eAAM,EAAC,MAAM,CAAC,EAAE,CAAC;wBACnB,IAAI,GAAG,MAAM,CAAC;oBAChB,CAAC;yBAAM,CAAC;wBACN,IAAI,CAAC,GAAG,EAAE,CAAC;wBACX,SAAS;oBACX,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC;QAED,IAAI,MAAM,KAAK,SAAS,IAAI,QAAQ,EAAE,CAAC;YACrC,KAAK,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC;QAC1B,CAAC;QAED,IAAI,SAAS,EAAE,CAAC;YACd,IAAI,CAAC,GAAG,EAAE,CAAC;QACb,CAAC;aAAM,CAAC;YACN,KAAK,GAAG,EAAE,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC;YACrD,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC9B,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAE,WAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;YAChE,KAAK,GAAG,CAAC,CAAC,CAAC;YACX,KAAK,GAAG,EAAE,CAAC;YACX,IAAI,MAAM,IAAI,IAAI,EAAE,CAAC;gBACnB,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACzB,CAAC;YACD,MAAM,GAAG,IAAI,CAAC;QAChB,CAAC;IACH,CAAC,QAAQ,KAAK,KAAK,SAAS,EAAE;IAE9B,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACvB,WAAW;QACX,OAAO,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACzB,CAAC;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;;;;GAKG;AACH,SAAgB,eAAe,CAC7B,QAAmC;IAEnC,MAAM,QAAQ,GAAG,IAAI,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACvD,MAAM,aAAa,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAE1C,KAAK,MAAM,IAAI,IAAI,MAAM,CAAC,MAAM,CAAC,eAAI,CAAC,EAAE,CAAC;QACvC,IAAI,UAAU,GAAG,KAAK,CAAC;QACvB,MAAM,SAAS,GAAG,IAAI,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAC7D,MAAM,SAAS,GAAG,IAAI,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;QAE7D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,CAAC;YACzC,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,oBAAoB,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;YACjE,UAAU,KAAK,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,CAAC;YAC9C,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;YACrB,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;QACvB,CAAC;QAED,IAAI,CAAC,UAAU,EAAE,CAAC;YAChB,SAAS;QACX,CAAC;QAED,MAAM,gBAAgB,GAA+B;YACnD,KAAK,CAAC,GAAG,IAAI;gBACX,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBACzC,IAAI,QAAQ,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;wBACzB,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;wBACtD,IAAI,MAAM,KAAK,KAAK,EAAE,CAAC;4BACrB,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;wBACrB,CAAC;6BAAM,IAAI,MAAM,KAAK,aAAK,EAAE,CAAC;4BAC5B,QAAQ,CAAC,CAAC,CAAC,GAAG,aAAK,CAAC;wBACtB,CAAC;6BAAM,IAAI,MAAM,KAAK,SAAS,EAAE,CAAC;4BAChC,OAAO,MAAM,CAAC;wBAChB,CAAC;oBACH,CAAC;gBACH,CAAC;YACH,CAAC;YACD,KAAK,CAAC,GAAG,IAAI;gBACX,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;gBACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBACzC,IAAI,QAAQ,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;wBACzB,MAAM,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;wBACtD,IAAI,MAAM,KAAK,aAAK,EAAE,CAAC;4BACrB,QAAQ,CAAC,CAAC,CAAC,GAAG,aAAK,CAAC;wBACtB,CAAC;6BAAM,IAAI,MAAM,KAAK,SAAS,IAAI,MAAM,KAAK,KAAK,EAAE,CAAC;4BACpD,OAAO,MAAM,CAAC;wBAChB,CAAC;oBACH,CAAC;yBAAM,IAAI,QAAQ,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;wBAChC,QAAQ,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;oBACrB,CAAC;gBACH,CAAC;YACH,CAAC;SACF,CAAC;QAEF,aAAa,CAAC,IAAI,CAAC,GAAG,gBAAgB,CAAC;IACzC,CAAC;IAED,OAAO,aAAa,CAAC;AACvB,CAAC;AAED;;GAEG;AACH,SAAgB,oBAAoB,CAClC,OAAmB,EACnB,IAAU;IAEV,MAAM,WAAW,GAGA,OAAe,CAAC,IAAI,CAAC,CAAC;IAEvC,IAAI,OAAO,WAAW,KAAK,QAAQ,EAAE,CAAC;QACpC,uCAAuC;QACvC,OAAO,WAAW,CAAC;IACrB,CAAC;SAAM,IAAI,OAAO,WAAW,KAAK,UAAU,EAAE,CAAC;QAC7C,gBAAgB;QAChB,OAAO,EAAE,KAAK,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,EAAE,CAAC;IAClD,CAAC;IAED,6BAA6B;IAC7B,OAAO,EAAE,KAAK,EAAG,OAAe,CAAC,KAAK,EAAE,KAAK,EAAG,OAAe,CAAC,KAAK,EAAE,CAAC;AAC1E,CAAC","sourcesContent":["import { devAssert } from '../jsutils/devAssert.js';\nimport { inspect } from '../jsutils/inspect.js';\n\nimport type { ASTNode } from './ast.js';\nimport { isNode, QueryDocumentKeys } from './ast.js';\nimport { Kind } from './kinds.js';\n\n/**\n * A visitor is provided to visit, it contains the collection of\n * relevant functions to be called during the visitor's traversal.\n */\nexport type ASTVisitor = EnterLeaveVisitor<ASTNode> | KindVisitor;\n\ntype KindVisitor = {\n  readonly [NodeT in ASTNode as NodeT['kind']]?:\n    | ASTVisitFn<NodeT>\n    | EnterLeaveVisitor<NodeT>;\n};\n\ninterface EnterLeaveVisitor<TVisitedNode extends ASTNode> {\n  readonly enter?: ASTVisitFn<TVisitedNode> | undefined;\n  readonly leave?: ASTVisitFn<TVisitedNode> | undefined;\n}\n\n/**\n * A visitor is comprised of visit functions, which are called on each node\n * during the visitor's traversal.\n */\nexport type ASTVisitFn<TVisitedNode extends ASTNode> = (\n  /** The current node being visiting. */\n  node: TVisitedNode,\n  /** The index or key to this node from the parent node or Array. */\n  key: string | number | undefined,\n  /** The parent immediately above this node, which may be an Array. */\n  parent: ASTNode | ReadonlyArray<ASTNode> | undefined,\n  /** The key path to get to this node from the root node. */\n  path: ReadonlyArray<string | number>,\n  /**\n   * All nodes and Arrays visited before reaching parent of this node.\n   * These correspond to array indices in `path`.\n   * Note: ancestors includes arrays which contain the parent of visited node.\n   */\n  ancestors: ReadonlyArray<ASTNode | ReadonlyArray<ASTNode>>,\n) => any;\n\n/**\n * A reducer is comprised of reducer functions which convert AST nodes into\n * another form.\n */\nexport type ASTReducer<R> = {\n  readonly [NodeT in ASTNode as NodeT['kind']]?: {\n    readonly enter?: ASTVisitFn<NodeT>;\n    readonly leave: ASTReducerFn<NodeT, R>;\n  };\n};\n\ntype ASTReducerFn<TReducedNode extends ASTNode, R> = (\n  /** The current node being visiting. */\n  node: { [K in keyof TReducedNode]: ReducedField<TReducedNode[K], R> },\n  /** The index or key to this node from the parent node or Array. */\n  key: string | number | undefined,\n  /** The parent immediately above this node, which may be an Array. */\n  parent: ASTNode | ReadonlyArray<ASTNode> | undefined,\n  /** The key path to get to this node from the root node. */\n  path: ReadonlyArray<string | number>,\n  /**\n   * All nodes and Arrays visited before reaching parent of this node.\n   * These correspond to array indices in `path`.\n   * Note: ancestors includes arrays which contain the parent of visited node.\n   */\n  ancestors: ReadonlyArray<ASTNode | ReadonlyArray<ASTNode>>,\n) => R;\n\ntype ReducedField<T, R> = T extends ASTNode\n  ? R\n  : T extends ReadonlyArray<ASTNode>\n    ? ReadonlyArray<R>\n    : T;\n\n/**\n * A KeyMap describes each the traversable properties of each kind of node.\n */\nexport type ASTVisitorKeyMap = {\n  [NodeT in ASTNode as NodeT['kind']]?: ReadonlyArray<keyof NodeT>;\n};\n\nexport const BREAK: unknown = Object.freeze({});\n\n/**\n * visit() will walk through an AST using a depth-first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n * ```ts\n * const editedAST = visit(ast, {\n *   enter(node, key, parent, path, ancestors) {\n *     // @return\n *     //   undefined: no action\n *     //   false: skip visiting this node\n *     //   visitor.BREAK: stop visiting altogether\n *     //   null: delete this node\n *     //   any value: replace this node with the returned value\n *   },\n *   leave(node, key, parent, path, ancestors) {\n *     // @return\n *     //   undefined: no action\n *     //   false: no action\n *     //   visitor.BREAK: stop visiting altogether\n *     //   null: delete this node\n *     //   any value: replace this node with the returned value\n *   }\n * });\n * ```\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to three permutations of the\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node of a specific kind.\n *\n * ```ts\n * visit(ast, {\n *   Kind(node) {\n *     // enter the \"Kind\" node\n *   }\n * })\n * ```\n *\n * 2) Named visitors that trigger upon entering and leaving a node of a specific kind.\n *\n * ```ts\n * visit(ast, {\n *   Kind: {\n *     enter(node) {\n *       // enter the \"Kind\" node\n *     }\n *     leave(node) {\n *       // leave the \"Kind\" node\n *     }\n *   }\n * })\n * ```\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n * ```ts\n * visit(ast, {\n *   enter(node) {\n *     // enter any node\n *   },\n *   leave(node) {\n *     // leave any node\n *   }\n * })\n * ```\n */\nexport function visit<N extends ASTNode>(\n  root: N,\n  visitor: ASTVisitor,\n  visitorKeys?: ASTVisitorKeyMap,\n): N;\nexport function visit<R>(\n  root: ASTNode,\n  visitor: ASTReducer<R>,\n  visitorKeys?: ASTVisitorKeyMap,\n): R;\nexport function visit(\n  root: ASTNode,\n  visitor: ASTVisitor | ASTReducer<any>,\n  visitorKeys: ASTVisitorKeyMap = QueryDocumentKeys,\n): any {\n  const enterLeaveMap = new Map<Kind, EnterLeaveVisitor<ASTNode>>();\n  for (const kind of Object.values(Kind)) {\n    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));\n  }\n\n  /* eslint-disable no-undef-init */\n  let stack: any = undefined;\n  let inArray = Array.isArray(root);\n  let keys: any = [root];\n  let index = -1;\n  let edits = [];\n  let node: any = root;\n  let key: any = undefined;\n  let parent: any = undefined;\n  const path: any = [];\n  const ancestors = [];\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    const isLeaving = index === keys.length;\n    const isEdited = isLeaving && edits.length !== 0;\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n\n          let editOffset = 0;\n          for (const [editKey, editValue] of edits) {\n            const arrayKey = editKey - editOffset;\n            if (editValue === null) {\n              node.splice(arrayKey, 1);\n              editOffset++;\n            } else {\n              node[arrayKey] = editValue;\n            }\n          }\n        } else {\n          node = Object.defineProperties(\n            {},\n            Object.getOwnPropertyDescriptors(node),\n          );\n          for (const [editKey, editValue] of edits) {\n            node[editKey] = editValue;\n          }\n        }\n      }\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else if (parent != null) {\n      key = inArray ? index : keys[index];\n      node = parent[key];\n      if (node === null || node === undefined) {\n        continue;\n      }\n      path.push(key);\n    }\n\n    let result;\n    if (!Array.isArray(node)) {\n      devAssert(isNode(node), `Invalid AST Node: ${inspect(node)}.`);\n\n      const visitFn = isLeaving\n        ? enterLeaveMap.get(node.kind)?.leave\n        : enterLeaveMap.get(node.kind)?.enter;\n\n      result = visitFn?.call(visitor, node, key, parent, path, ancestors);\n\n      if (result === BREAK) {\n        break;\n      }\n\n      if (result === false) {\n        if (!isLeaving) {\n          path.pop();\n          continue;\n        }\n      } else if (result !== undefined) {\n        edits.push([key, result]);\n        if (!isLeaving) {\n          if (isNode(result)) {\n            node = result;\n          } else {\n            path.pop();\n            continue;\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      stack = { inArray, index, keys, edits, prev: stack };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : ((visitorKeys as any)[node.kind] ?? []);\n      index = -1;\n      edits = [];\n      if (parent != null) {\n        ancestors.push(parent);\n      }\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    // New root\n    return edits.at(-1)[1];\n  }\n\n  return root;\n}\n\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\nexport function visitInParallel(\n  visitors: ReadonlyArray<ASTVisitor>,\n): ASTVisitor {\n  const skipping = new Array(visitors.length).fill(null);\n  const mergedVisitor = Object.create(null);\n\n  for (const kind of Object.values(Kind)) {\n    let hasVisitor = false;\n    const enterList = new Array(visitors.length).fill(undefined);\n    const leaveList = new Array(visitors.length).fill(undefined);\n\n    for (let i = 0; i < visitors.length; ++i) {\n      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind);\n      hasVisitor ||= enter != null || leave != null;\n      enterList[i] = enter;\n      leaveList[i] = leave;\n    }\n\n    if (!hasVisitor) {\n      continue;\n    }\n\n    const mergedEnterLeave: EnterLeaveVisitor<ASTNode> = {\n      enter(...args) {\n        const node = args[0];\n        for (let i = 0; i < visitors.length; i++) {\n          if (skipping[i] === null) {\n            const result = enterList[i]?.apply(visitors[i], args);\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      },\n      leave(...args) {\n        const node = args[0];\n        for (let i = 0; i < visitors.length; i++) {\n          if (skipping[i] === null) {\n            const result = leaveList[i]?.apply(visitors[i], args);\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          } else if (skipping[i] === node) {\n            skipping[i] = null;\n          }\n        }\n      },\n    };\n\n    mergedVisitor[kind] = mergedEnterLeave;\n  }\n\n  return mergedVisitor;\n}\n\n/**\n * Given a visitor instance and a node kind, return EnterLeaveVisitor for that kind.\n */\nexport function getEnterLeaveForKind(\n  visitor: ASTVisitor,\n  kind: Kind,\n): EnterLeaveVisitor<ASTNode> {\n  const kindVisitor:\n    | ASTVisitFn<ASTNode>\n    | EnterLeaveVisitor<ASTNode>\n    | undefined = (visitor as any)[kind];\n\n  if (typeof kindVisitor === 'object') {\n    // { Kind: { enter() {}, leave() {} } }\n    return kindVisitor;\n  } else if (typeof kindVisitor === 'function') {\n    // { Kind() {} }\n    return { enter: kindVisitor, leave: undefined };\n  }\n\n  // { enter() {}, leave() {} }\n  return { enter: (visitor as any).enter, leave: (visitor as any).leave };\n}\n"]}