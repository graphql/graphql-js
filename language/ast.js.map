{"version":3,"file":"ast.js","sourceRoot":"","sources":["../../src/language/ast.ts"],"names":[],"mappings":";;;AAuSA,wBAGC;AAtSD;;;GAGG;AACH,MAAa,QAAQ;IA0BnB,YAAY,UAAiB,EAAE,QAAe,EAAE,MAAc;QAC5D,IAAI,CAAC,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC;QAC9B,IAAI,CAAC,GAAG,GAAG,QAAQ,CAAC,GAAG,CAAC;QACxB,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IAED,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC;QACtB,OAAO,UAAU,CAAC;IACpB,CAAC;IAED,MAAM;QACJ,OAAO,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,GAAG,EAAE,IAAI,CAAC,GAAG,EAAE,CAAC;IAC9C,CAAC;CACF;AAzCD,4BAyCC;AAED;;;GAGG;AACH,MAAa,KAAK;IA0ChB,yDAAyD;IACzD,YACE,IAAe,EACf,KAAa,EACb,GAAW,EACX,IAAY,EACZ,MAAc,EACd,KAAc;QAEd,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,oEAAoE;QACpE,IAAI,CAAC,KAAK,GAAG,KAAM,CAAC;QACpB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;IACnB,CAAC;IAED,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC;QACtB,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,MAAM;QAMJ,OAAO;YACL,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,MAAM,EAAE,IAAI,CAAC,MAAM;SACpB,CAAC;IACJ,CAAC;CACF;AA/ED,sBA+EC;AA0DD;;GAEG;AACU,QAAA,iBAAiB,GAE1B;IACF,IAAI,EAAE,EAAE;IAER,QAAQ,EAAE,CAAC,aAAa,CAAC;IACzB,mBAAmB,EAAE;QACnB,MAAM;QACN,qBAAqB;QACrB,YAAY;QACZ,cAAc;KACf;IACD,kBAAkB,EAAE,CAAC,UAAU,EAAE,MAAM,EAAE,cAAc,EAAE,YAAY,CAAC;IACtE,QAAQ,EAAE,CAAC,MAAM,CAAC;IAClB,YAAY,EAAE,CAAC,YAAY,CAAC;IAC5B,KAAK,EAAE,CAAC,OAAO,EAAE,MAAM,EAAE,WAAW,EAAE,YAAY,EAAE,cAAc,CAAC;IACnE,QAAQ,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC;IAC3B,gBAAgB,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC;IAEnC,cAAc,EAAE;QACd,MAAM;QACN,0EAA0E;QAC1E,iBAAiB;QACjB,WAAW;QACX,YAAY;KACb;IACD,cAAc,EAAE,CAAC,eAAe,EAAE,YAAY,EAAE,cAAc,CAAC;IAC/D,kBAAkB,EAAE;QAClB,MAAM;QACN,0EAA0E;QAC1E,iBAAiB;QACjB,qBAAqB;QACrB,eAAe;QACf,YAAY;QACZ,cAAc;KACf;IAED,QAAQ,EAAE,EAAE;IACZ,UAAU,EAAE,EAAE;IACd,WAAW,EAAE,EAAE;IACf,YAAY,EAAE,EAAE;IAChB,SAAS,EAAE,EAAE;IACb,SAAS,EAAE,EAAE;IACb,SAAS,EAAE,CAAC,QAAQ,CAAC;IACrB,WAAW,EAAE,CAAC,QAAQ,CAAC;IACvB,WAAW,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC;IAE9B,SAAS,EAAE,CAAC,MAAM,EAAE,WAAW,CAAC;IAEhC,SAAS,EAAE,CAAC,MAAM,CAAC;IACnB,QAAQ,EAAE,CAAC,MAAM,CAAC;IAClB,WAAW,EAAE,CAAC,MAAM,CAAC;IAErB,gBAAgB,EAAE,CAAC,aAAa,EAAE,YAAY,EAAE,gBAAgB,CAAC;IACjE,uBAAuB,EAAE,CAAC,MAAM,CAAC;IAEjC,oBAAoB,EAAE,CAAC,aAAa,EAAE,MAAM,EAAE,YAAY,CAAC;IAC3D,oBAAoB,EAAE;QACpB,aAAa;QACb,MAAM;QACN,YAAY;QACZ,YAAY;QACZ,QAAQ;KACT;IACD,eAAe,EAAE,CAAC,aAAa,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,YAAY,CAAC;IAC3E,oBAAoB,EAAE;QACpB,aAAa;QACb,MAAM;QACN,MAAM;QACN,cAAc;QACd,YAAY;KACb;IACD,uBAAuB,EAAE;QACvB,aAAa;QACb,MAAM;QACN,YAAY;QACZ,YAAY;QACZ,QAAQ;KACT;IACD,mBAAmB,EAAE,CAAC,aAAa,EAAE,MAAM,EAAE,YAAY,EAAE,OAAO,CAAC;IACnE,kBAAkB,EAAE,CAAC,aAAa,EAAE,MAAM,EAAE,YAAY,EAAE,QAAQ,CAAC;IACnE,mBAAmB,EAAE,CAAC,aAAa,EAAE,MAAM,EAAE,YAAY,CAAC;IAC1D,yBAAyB,EAAE,CAAC,aAAa,EAAE,MAAM,EAAE,YAAY,EAAE,QAAQ,CAAC;IAE1E,mBAAmB,EAAE,CAAC,aAAa,EAAE,MAAM,EAAE,WAAW,EAAE,WAAW,CAAC;IAEtE,eAAe,EAAE,CAAC,YAAY,EAAE,gBAAgB,CAAC;IAEjD,mBAAmB,EAAE,CAAC,MAAM,EAAE,YAAY,CAAC;IAC3C,mBAAmB,EAAE,CAAC,MAAM,EAAE,YAAY,EAAE,YAAY,EAAE,QAAQ,CAAC;IACnE,sBAAsB,EAAE,CAAC,MAAM,EAAE,YAAY,EAAE,YAAY,EAAE,QAAQ,CAAC;IACtE,kBAAkB,EAAE,CAAC,MAAM,EAAE,YAAY,EAAE,OAAO,CAAC;IACnD,iBAAiB,EAAE,CAAC,MAAM,EAAE,YAAY,EAAE,QAAQ,CAAC;IACnD,wBAAwB,EAAE,CAAC,MAAM,EAAE,YAAY,EAAE,QAAQ,CAAC;CAC3D,CAAC;AAEF,MAAM,UAAU,GAAG,IAAI,GAAG,CAAS,MAAM,CAAC,IAAI,CAAC,yBAAiB,CAAC,CAAC,CAAC;AACnE;;GAEG;AACH,SAAgB,MAAM,CAAC,SAAc;IACnC,MAAM,SAAS,GAAG,SAAS,EAAE,IAAI,CAAC;IAClC,OAAO,OAAO,SAAS,KAAK,QAAQ,IAAI,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;AACpE,CAAC;AAwCY,QAAA,iBAAiB,GAAG;IAC/B,KAAK,EAAE,OAAgB;IACvB,QAAQ,EAAE,UAAmB;IAC7B,YAAY,EAAE,cAAuB;CAC7B,CAAC","sourcesContent":["import type { Kind } from './kinds.js';\nimport type { Source } from './source.js';\nimport type { TokenKind } from './tokenKind.js';\n\n/**\n * Contains a range of UTF-8 character offsets and token references that\n * identify the region of the source from which the AST derived.\n */\nexport class Location {\n  /**\n   * The character offset at which this Node begins.\n   */\n  readonly start: number;\n\n  /**\n   * The character offset at which this Node ends.\n   */\n  readonly end: number;\n\n  /**\n   * The Token at which this Node begins.\n   */\n  readonly startToken: Token;\n\n  /**\n   * The Token at which this Node ends.\n   */\n  readonly endToken: Token;\n\n  /**\n   * The Source document the AST represents.\n   */\n  readonly source: Source;\n\n  constructor(startToken: Token, endToken: Token, source: Source) {\n    this.start = startToken.start;\n    this.end = endToken.end;\n    this.startToken = startToken;\n    this.endToken = endToken;\n    this.source = source;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Location';\n  }\n\n  toJSON(): { start: number; end: number } {\n    return { start: this.start, end: this.end };\n  }\n}\n\n/**\n * Represents a range of characters represented by a lexical token\n * within a Source.\n */\nexport class Token {\n  /**\n   * The kind of Token.\n   */\n  readonly kind: TokenKind;\n\n  /**\n   * The character offset at which this Node begins.\n   */\n  readonly start: number;\n\n  /**\n   * The character offset at which this Node ends.\n   */\n  readonly end: number;\n\n  /**\n   * The 1-indexed line number on which this Token appears.\n   */\n  readonly line: number;\n\n  /**\n   * The 1-indexed column number at which this Token begins.\n   */\n  readonly column: number;\n\n  /**\n   * For non-punctuation tokens, represents the interpreted value of the token.\n   *\n   * Note: is undefined for punctuation tokens, but typed as string for\n   * convenience in the parser.\n   */\n  readonly value: string;\n\n  /**\n   * Tokens exist as nodes in a double-linked-list amongst all tokens\n   * including ignored tokens. <SOF> is always the first node and <EOF>\n   * the last.\n   */\n  readonly prev: Token | null;\n  readonly next: Token | null;\n\n  // eslint-disable-next-line @typescript-eslint/max-params\n  constructor(\n    kind: TokenKind,\n    start: number,\n    end: number,\n    line: number,\n    column: number,\n    value?: string,\n  ) {\n    this.kind = kind;\n    this.start = start;\n    this.end = end;\n    this.line = line;\n    this.column = column;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.value = value!;\n    this.prev = null;\n    this.next = null;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Token';\n  }\n\n  toJSON(): {\n    kind: TokenKind;\n    value?: string;\n    line: number;\n    column: number;\n  } {\n    return {\n      kind: this.kind,\n      value: this.value,\n      line: this.line,\n      column: this.column,\n    };\n  }\n}\n\n/**\n * The list of all possible AST node types.\n */\nexport type ASTNode =\n  | NameNode\n  | DocumentNode\n  | OperationDefinitionNode\n  | VariableDefinitionNode\n  | VariableNode\n  | SelectionSetNode\n  | FieldNode\n  | ArgumentNode\n  | FragmentArgumentNode\n  | FragmentSpreadNode\n  | InlineFragmentNode\n  | FragmentDefinitionNode\n  | IntValueNode\n  | FloatValueNode\n  | StringValueNode\n  | BooleanValueNode\n  | NullValueNode\n  | EnumValueNode\n  | ListValueNode\n  | ObjectValueNode\n  | ObjectFieldNode\n  | DirectiveNode\n  | NamedTypeNode\n  | ListTypeNode\n  | NonNullTypeNode\n  | SchemaDefinitionNode\n  | OperationTypeDefinitionNode\n  | ScalarTypeDefinitionNode\n  | ObjectTypeDefinitionNode\n  | FieldDefinitionNode\n  | InputValueDefinitionNode\n  | InterfaceTypeDefinitionNode\n  | UnionTypeDefinitionNode\n  | EnumTypeDefinitionNode\n  | EnumValueDefinitionNode\n  | InputObjectTypeDefinitionNode\n  | DirectiveDefinitionNode\n  | SchemaExtensionNode\n  | ScalarTypeExtensionNode\n  | ObjectTypeExtensionNode\n  | InterfaceTypeExtensionNode\n  | UnionTypeExtensionNode\n  | EnumTypeExtensionNode\n  | InputObjectTypeExtensionNode;\n\n/**\n * Utility type listing all nodes indexed by their kind.\n */\nexport type ASTKindToNode = {\n  [NodeT in ASTNode as NodeT['kind']]: NodeT;\n};\n\n/**\n * @internal\n */\nexport const QueryDocumentKeys: {\n  [NodeT in ASTNode as NodeT['kind']]: ReadonlyArray<keyof NodeT>;\n} = {\n  Name: [],\n\n  Document: ['definitions'],\n  OperationDefinition: [\n    'name',\n    'variableDefinitions',\n    'directives',\n    'selectionSet',\n  ],\n  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n  FragmentArgument: ['name', 'value'],\n\n  FragmentSpread: [\n    'name',\n    // Note: Fragment arguments are experimental and may be changed or removed\n    // in the future.\n    'arguments',\n    'directives',\n  ],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: [\n    'name',\n    // Note: Fragment variables are experimental and may be changed or removed\n    // in the future.\n    'variableDefinitions',\n    'typeCondition',\n    'directives',\n    'selectionSet',\n  ],\n\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n\n  Directive: ['name', 'arguments'],\n\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n\n  SchemaDefinition: ['description', 'directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: [\n    'description',\n    'name',\n    'interfaces',\n    'directives',\n    'fields',\n  ],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: [\n    'description',\n    'name',\n    'type',\n    'defaultValue',\n    'directives',\n  ],\n  InterfaceTypeDefinition: [\n    'description',\n    'name',\n    'interfaces',\n    'directives',\n    'fields',\n  ],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],\n\n  SchemaExtension: ['directives', 'operationTypes'],\n\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields'],\n};\n\nconst kindValues = new Set<string>(Object.keys(QueryDocumentKeys));\n/**\n * @internal\n */\nexport function isNode(maybeNode: any): maybeNode is ASTNode {\n  const maybeKind = maybeNode?.kind;\n  return typeof maybeKind === 'string' && kindValues.has(maybeKind);\n}\n\n/** Name */\n\nexport interface NameNode {\n  readonly kind: typeof Kind.NAME;\n  readonly loc?: Location | undefined;\n  readonly value: string;\n}\n\n/** Document */\n\nexport interface DocumentNode {\n  readonly kind: typeof Kind.DOCUMENT;\n  readonly loc?: Location | undefined;\n  readonly definitions: ReadonlyArray<DefinitionNode>;\n  readonly tokenCount?: number | undefined;\n}\n\nexport type DefinitionNode =\n  | ExecutableDefinitionNode\n  | TypeSystemDefinitionNode\n  | TypeSystemExtensionNode;\n\nexport type ExecutableDefinitionNode =\n  | OperationDefinitionNode\n  | FragmentDefinitionNode;\n\nexport interface OperationDefinitionNode {\n  readonly kind: typeof Kind.OPERATION_DEFINITION;\n  readonly loc?: Location | undefined;\n  readonly operation: OperationTypeNode;\n  readonly name?: NameNode | undefined;\n  readonly variableDefinitions?:\n    | ReadonlyArray<VariableDefinitionNode>\n    | undefined;\n  readonly directives?: ReadonlyArray<DirectiveNode> | undefined;\n  readonly selectionSet: SelectionSetNode;\n}\n\nexport const OperationTypeNode = {\n  QUERY: 'query' as const,\n  MUTATION: 'mutation' as const,\n  SUBSCRIPTION: 'subscription' as const,\n} as const;\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport type OperationTypeNode =\n  (typeof OperationTypeNode)[keyof typeof OperationTypeNode];\n\nexport interface VariableDefinitionNode {\n  readonly kind: typeof Kind.VARIABLE_DEFINITION;\n  readonly loc?: Location | undefined;\n  readonly variable: VariableNode;\n  readonly type: TypeNode;\n  readonly defaultValue?: ConstValueNode | undefined;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n}\n\nexport interface VariableNode {\n  readonly kind: typeof Kind.VARIABLE;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n}\n\nexport interface SelectionSetNode {\n  kind: typeof Kind.SELECTION_SET;\n  loc?: Location | undefined;\n  selections: ReadonlyArray<SelectionNode>;\n}\n\nexport type SelectionNode = FieldNode | FragmentSpreadNode | InlineFragmentNode;\n\nexport interface FieldNode {\n  readonly kind: typeof Kind.FIELD;\n  readonly loc?: Location | undefined;\n  readonly alias?: NameNode | undefined;\n  readonly name: NameNode;\n  readonly arguments?: ReadonlyArray<ArgumentNode> | undefined;\n  readonly directives?: ReadonlyArray<DirectiveNode> | undefined;\n  readonly selectionSet?: SelectionSetNode | undefined;\n}\n\nexport interface ArgumentNode {\n  readonly kind: typeof Kind.ARGUMENT;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n  readonly value: ValueNode;\n}\n\nexport interface ConstArgumentNode {\n  readonly kind: typeof Kind.ARGUMENT;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n  readonly value: ConstValueNode;\n}\n\nexport interface FragmentArgumentNode {\n  readonly kind: typeof Kind.FRAGMENT_ARGUMENT;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n  readonly value: ValueNode;\n}\n\n/** Fragments */\n\nexport interface FragmentSpreadNode {\n  readonly kind: typeof Kind.FRAGMENT_SPREAD;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n  readonly arguments?: ReadonlyArray<FragmentArgumentNode> | undefined;\n  readonly directives?: ReadonlyArray<DirectiveNode> | undefined;\n}\n\nexport interface InlineFragmentNode {\n  readonly kind: typeof Kind.INLINE_FRAGMENT;\n  readonly loc?: Location | undefined;\n  readonly typeCondition?: NamedTypeNode | undefined;\n  readonly directives?: ReadonlyArray<DirectiveNode> | undefined;\n  readonly selectionSet: SelectionSetNode;\n}\n\nexport interface FragmentDefinitionNode {\n  readonly kind: typeof Kind.FRAGMENT_DEFINITION;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n  readonly variableDefinitions?:\n    | ReadonlyArray<VariableDefinitionNode>\n    | undefined;\n  readonly typeCondition: NamedTypeNode;\n  readonly directives?: ReadonlyArray<DirectiveNode> | undefined;\n  readonly selectionSet: SelectionSetNode;\n}\n\n/** Values */\n\nexport type ValueNode =\n  | VariableNode\n  | IntValueNode\n  | FloatValueNode\n  | StringValueNode\n  | BooleanValueNode\n  | NullValueNode\n  | EnumValueNode\n  | ListValueNode\n  | ObjectValueNode;\n\nexport type ConstValueNode =\n  | IntValueNode\n  | FloatValueNode\n  | StringValueNode\n  | BooleanValueNode\n  | NullValueNode\n  | EnumValueNode\n  | ConstListValueNode\n  | ConstObjectValueNode;\n\nexport interface IntValueNode {\n  readonly kind: typeof Kind.INT;\n  readonly loc?: Location | undefined;\n  readonly value: string;\n}\n\nexport interface FloatValueNode {\n  readonly kind: typeof Kind.FLOAT;\n  readonly loc?: Location | undefined;\n  readonly value: string;\n}\n\nexport interface StringValueNode {\n  readonly kind: typeof Kind.STRING;\n  readonly loc?: Location | undefined;\n  readonly value: string;\n  readonly block?: boolean | undefined;\n}\n\nexport interface BooleanValueNode {\n  readonly kind: typeof Kind.BOOLEAN;\n  readonly loc?: Location | undefined;\n  readonly value: boolean;\n}\n\nexport interface NullValueNode {\n  readonly kind: typeof Kind.NULL;\n  readonly loc?: Location | undefined;\n}\n\nexport interface EnumValueNode {\n  readonly kind: typeof Kind.ENUM;\n  readonly loc?: Location | undefined;\n  readonly value: string;\n}\n\nexport interface ListValueNode {\n  readonly kind: typeof Kind.LIST;\n  readonly loc?: Location | undefined;\n  readonly values: ReadonlyArray<ValueNode>;\n}\n\nexport interface ConstListValueNode {\n  readonly kind: typeof Kind.LIST;\n  readonly loc?: Location | undefined;\n  readonly values: ReadonlyArray<ConstValueNode>;\n}\n\nexport interface ObjectValueNode {\n  readonly kind: typeof Kind.OBJECT;\n  readonly loc?: Location | undefined;\n  readonly fields: ReadonlyArray<ObjectFieldNode>;\n}\n\nexport interface ConstObjectValueNode {\n  readonly kind: typeof Kind.OBJECT;\n  readonly loc?: Location | undefined;\n  readonly fields: ReadonlyArray<ConstObjectFieldNode>;\n}\n\nexport interface ObjectFieldNode {\n  readonly kind: typeof Kind.OBJECT_FIELD;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n  readonly value: ValueNode;\n}\n\nexport interface ConstObjectFieldNode {\n  readonly kind: typeof Kind.OBJECT_FIELD;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n  readonly value: ConstValueNode;\n}\n\n/** Directives */\n\nexport interface DirectiveNode {\n  readonly kind: typeof Kind.DIRECTIVE;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n  readonly arguments?: ReadonlyArray<ArgumentNode> | undefined;\n}\n\nexport interface ConstDirectiveNode {\n  readonly kind: typeof Kind.DIRECTIVE;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n  readonly arguments?: ReadonlyArray<ConstArgumentNode> | undefined;\n}\n\n/** Type Reference */\n\nexport type TypeNode = NamedTypeNode | ListTypeNode | NonNullTypeNode;\n\nexport interface NamedTypeNode {\n  readonly kind: typeof Kind.NAMED_TYPE;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n}\n\nexport interface ListTypeNode {\n  readonly kind: typeof Kind.LIST_TYPE;\n  readonly loc?: Location | undefined;\n  readonly type: TypeNode;\n}\n\nexport interface NonNullTypeNode {\n  readonly kind: typeof Kind.NON_NULL_TYPE;\n  readonly loc?: Location | undefined;\n  readonly type: NamedTypeNode | ListTypeNode;\n}\n\n/** Type System Definition */\n\nexport type TypeSystemDefinitionNode =\n  | SchemaDefinitionNode\n  | TypeDefinitionNode\n  | DirectiveDefinitionNode;\n\nexport interface SchemaDefinitionNode {\n  readonly kind: typeof Kind.SCHEMA_DEFINITION;\n  readonly loc?: Location | undefined;\n  readonly description?: StringValueNode | undefined;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n  readonly operationTypes: ReadonlyArray<OperationTypeDefinitionNode>;\n}\n\nexport interface OperationTypeDefinitionNode {\n  readonly kind: typeof Kind.OPERATION_TYPE_DEFINITION;\n  readonly loc?: Location | undefined;\n  readonly operation: OperationTypeNode;\n  readonly type: NamedTypeNode;\n}\n\n/** Type Definition */\n\nexport type TypeDefinitionNode =\n  | ScalarTypeDefinitionNode\n  | ObjectTypeDefinitionNode\n  | InterfaceTypeDefinitionNode\n  | UnionTypeDefinitionNode\n  | EnumTypeDefinitionNode\n  | InputObjectTypeDefinitionNode;\n\nexport interface ScalarTypeDefinitionNode {\n  readonly kind: typeof Kind.SCALAR_TYPE_DEFINITION;\n  readonly loc?: Location | undefined;\n  readonly description?: StringValueNode | undefined;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n}\n\nexport interface ObjectTypeDefinitionNode {\n  readonly kind: typeof Kind.OBJECT_TYPE_DEFINITION;\n  readonly loc?: Location | undefined;\n  readonly description?: StringValueNode | undefined;\n  readonly name: NameNode;\n  readonly interfaces?: ReadonlyArray<NamedTypeNode> | undefined;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n  readonly fields?: ReadonlyArray<FieldDefinitionNode> | undefined;\n}\n\nexport interface FieldDefinitionNode {\n  readonly kind: typeof Kind.FIELD_DEFINITION;\n  readonly loc?: Location | undefined;\n  readonly description?: StringValueNode | undefined;\n  readonly name: NameNode;\n  readonly arguments?: ReadonlyArray<InputValueDefinitionNode> | undefined;\n  readonly type: TypeNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n}\n\nexport interface InputValueDefinitionNode {\n  readonly kind: typeof Kind.INPUT_VALUE_DEFINITION;\n  readonly loc?: Location | undefined;\n  readonly description?: StringValueNode | undefined;\n  readonly name: NameNode;\n  readonly type: TypeNode;\n  readonly defaultValue?: ConstValueNode | undefined;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n}\n\nexport interface InterfaceTypeDefinitionNode {\n  readonly kind: typeof Kind.INTERFACE_TYPE_DEFINITION;\n  readonly loc?: Location | undefined;\n  readonly description?: StringValueNode | undefined;\n  readonly name: NameNode;\n  readonly interfaces?: ReadonlyArray<NamedTypeNode> | undefined;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n  readonly fields?: ReadonlyArray<FieldDefinitionNode> | undefined;\n}\n\nexport interface UnionTypeDefinitionNode {\n  readonly kind: typeof Kind.UNION_TYPE_DEFINITION;\n  readonly loc?: Location | undefined;\n  readonly description?: StringValueNode | undefined;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n  readonly types?: ReadonlyArray<NamedTypeNode> | undefined;\n}\n\nexport interface EnumTypeDefinitionNode {\n  readonly kind: typeof Kind.ENUM_TYPE_DEFINITION;\n  readonly loc?: Location | undefined;\n  readonly description?: StringValueNode | undefined;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n  readonly values?: ReadonlyArray<EnumValueDefinitionNode> | undefined;\n}\n\nexport interface EnumValueDefinitionNode {\n  readonly kind: typeof Kind.ENUM_VALUE_DEFINITION;\n  readonly loc?: Location | undefined;\n  readonly description?: StringValueNode | undefined;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n}\n\nexport interface InputObjectTypeDefinitionNode {\n  readonly kind: typeof Kind.INPUT_OBJECT_TYPE_DEFINITION;\n  readonly loc?: Location | undefined;\n  readonly description?: StringValueNode | undefined;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n  readonly fields?: ReadonlyArray<InputValueDefinitionNode> | undefined;\n}\n\n/** Directive Definitions */\n\nexport interface DirectiveDefinitionNode {\n  readonly kind: typeof Kind.DIRECTIVE_DEFINITION;\n  readonly loc?: Location | undefined;\n  readonly description?: StringValueNode | undefined;\n  readonly name: NameNode;\n  readonly arguments?: ReadonlyArray<InputValueDefinitionNode> | undefined;\n  readonly repeatable: boolean;\n  readonly locations: ReadonlyArray<NameNode>;\n}\n\n/** Type System Extensions */\n\nexport type TypeSystemExtensionNode = SchemaExtensionNode | TypeExtensionNode;\n\nexport interface SchemaExtensionNode {\n  readonly kind: typeof Kind.SCHEMA_EXTENSION;\n  readonly loc?: Location | undefined;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n  readonly operationTypes?:\n    | ReadonlyArray<OperationTypeDefinitionNode>\n    | undefined;\n}\n\n/** Type Extensions */\n\nexport type TypeExtensionNode =\n  | ScalarTypeExtensionNode\n  | ObjectTypeExtensionNode\n  | InterfaceTypeExtensionNode\n  | UnionTypeExtensionNode\n  | EnumTypeExtensionNode\n  | InputObjectTypeExtensionNode;\n\nexport interface ScalarTypeExtensionNode {\n  readonly kind: typeof Kind.SCALAR_TYPE_EXTENSION;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n}\n\nexport interface ObjectTypeExtensionNode {\n  readonly kind: typeof Kind.OBJECT_TYPE_EXTENSION;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n  readonly interfaces?: ReadonlyArray<NamedTypeNode> | undefined;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n  readonly fields?: ReadonlyArray<FieldDefinitionNode> | undefined;\n}\n\nexport interface InterfaceTypeExtensionNode {\n  readonly kind: typeof Kind.INTERFACE_TYPE_EXTENSION;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n  readonly interfaces?: ReadonlyArray<NamedTypeNode> | undefined;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n  readonly fields?: ReadonlyArray<FieldDefinitionNode> | undefined;\n}\n\nexport interface UnionTypeExtensionNode {\n  readonly kind: typeof Kind.UNION_TYPE_EXTENSION;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n  readonly types?: ReadonlyArray<NamedTypeNode> | undefined;\n}\n\nexport interface EnumTypeExtensionNode {\n  readonly kind: typeof Kind.ENUM_TYPE_EXTENSION;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n  readonly values?: ReadonlyArray<EnumValueDefinitionNode> | undefined;\n}\n\nexport interface InputObjectTypeExtensionNode {\n  readonly kind: typeof Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  readonly loc?: Location | undefined;\n  readonly name: NameNode;\n  readonly directives?: ReadonlyArray<ConstDirectiveNode> | undefined;\n  readonly fields?: ReadonlyArray<InputValueDefinitionNode> | undefined;\n}\n"]}