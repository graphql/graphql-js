{"version":3,"file":"lexer.js","sourceRoot":"","sources":["../../src/language/lexer.ts"],"names":[],"mappings":"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","sourcesContent":["import { syntaxError } from '../error/syntaxError.js';\n\nimport { Token } from './ast.js';\nimport { dedentBlockStringLines } from './blockString.js';\nimport { isDigit, isNameContinue, isNameStart } from './characterClasses.js';\nimport type { Source } from './source.js';\nimport { TokenKind } from './tokenKind.js';\n\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\nexport class Lexer {\n  source: Source;\n\n  /**\n   * The previously focused non-ignored token.\n   */\n  lastToken: Token;\n\n  /**\n   * The currently focused non-ignored token.\n   */\n  token: Token;\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n  line: number;\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  lineStart: number;\n\n  constructor(source: Source) {\n    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);\n\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Lexer';\n  }\n\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n  advance(): Token {\n    this.lastToken = this.token;\n    const token = (this.token = this.lookahead());\n    return token;\n  }\n\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the current Lexer token.\n   */\n  lookahead(): Token {\n    let token = this.token;\n    if (token.kind !== TokenKind.EOF) {\n      do {\n        if (token.next) {\n          token = token.next;\n        } else {\n          // Read the next token and form a link in the token linked-list.\n          const nextToken = readNextToken(this, token.end);\n          // @ts-expect-error next is only mutable during parsing.\n          token.next = nextToken;\n          // @ts-expect-error prev is only mutable during parsing.\n          nextToken.prev = token;\n          token = nextToken;\n        }\n      } while (token.kind === TokenKind.COMMENT);\n    }\n    return token;\n  }\n}\n\n/**\n * @internal\n */\nexport function isPunctuatorTokenKind(kind: TokenKind): boolean {\n  return (\n    kind === TokenKind.BANG ||\n    kind === TokenKind.DOLLAR ||\n    kind === TokenKind.AMP ||\n    kind === TokenKind.PAREN_L ||\n    kind === TokenKind.PAREN_R ||\n    kind === TokenKind.SPREAD ||\n    kind === TokenKind.COLON ||\n    kind === TokenKind.EQUALS ||\n    kind === TokenKind.AT ||\n    kind === TokenKind.BRACKET_L ||\n    kind === TokenKind.BRACKET_R ||\n    kind === TokenKind.BRACE_L ||\n    kind === TokenKind.PIPE ||\n    kind === TokenKind.BRACE_R\n  );\n}\n\n/**\n * A Unicode scalar value is any Unicode code point except surrogate code\n * points. In other words, the inclusive ranges of values 0x0000 to 0xD7FF and\n * 0xE000 to 0x10FFFF.\n *\n * SourceCharacter ::\n *   - \"Any Unicode scalar value\"\n */\nfunction isUnicodeScalarValue(code: number): boolean {\n  return (\n    (code >= 0x0000 && code <= 0xd7ff) || (code >= 0xe000 && code <= 0x10ffff)\n  );\n}\n\n/**\n * The GraphQL specification defines source text as a sequence of unicode scalar\n * values (which Unicode defines to exclude surrogate code points). However\n * JavaScript defines strings as a sequence of UTF-16 code units which may\n * include surrogates. A surrogate pair is a valid source character as it\n * encodes a supplementary code point (above U+FFFF), but unpaired surrogate\n * code points are not valid source characters.\n */\nfunction isSupplementaryCodePoint(body: string, location: number): boolean {\n  return (\n    isLeadingSurrogate(body.charCodeAt(location)) &&\n    isTrailingSurrogate(body.charCodeAt(location + 1))\n  );\n}\n\nfunction isLeadingSurrogate(code: number): boolean {\n  return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction isTrailingSurrogate(code: number): boolean {\n  return code >= 0xdc00 && code <= 0xdfff;\n}\n\n/**\n * Prints the code point (or end of file reference) at a given location in a\n * source for use in error messages.\n *\n * Printable ASCII is printed quoted, while other points are printed in Unicode\n * code point form (ie. U+1234).\n */\nfunction printCodePointAt(lexer: Lexer, location: number): string {\n  const code = lexer.source.body.codePointAt(location);\n\n  if (code === undefined) {\n    return TokenKind.EOF;\n  } else if (code >= 0x0020 && code <= 0x007e) {\n    // Printable ASCII\n    const char = String.fromCodePoint(code);\n    return char === '\"' ? \"'\\\"'\" : `\"${char}\"`;\n  }\n\n  // Unicode code point\n  return 'U+' + code.toString(16).toUpperCase().padStart(4, '0');\n}\n\n/**\n * Create a token with line and column location information.\n */\nfunction createToken(\n  lexer: Lexer,\n  kind: TokenKind,\n  start: number,\n  end: number,\n  value?: string,\n): Token {\n  const line = lexer.line;\n  const col = 1 + start - lexer.lineStart;\n  return new Token(kind, start, end, line, col, value);\n}\n\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\nfunction readNextToken(lexer: Lexer, start: number): Token {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    // SourceCharacter\n    switch (code) {\n      // Ignored ::\n      //   - UnicodeBOM\n      //   - WhiteSpace\n      //   - LineTerminator\n      //   - Comment\n      //   - Comma\n      //\n      // UnicodeBOM :: \"Byte Order Mark (U+FEFF)\"\n      //\n      // WhiteSpace ::\n      //   - \"Horizontal Tab (U+0009)\"\n      //   - \"Space (U+0020)\"\n      //\n      // Comma :: ,\n      case 0xfeff: // <BOM>\n      case 0x0009: // \\t\n      case 0x0020: // <space>\n      case 0x002c: // ,\n        ++position;\n        continue;\n      // LineTerminator ::\n      //   - \"New Line (U+000A)\"\n      //   - \"Carriage Return (U+000D)\" [lookahead != \"New Line (U+000A)\"]\n      //   - \"Carriage Return (U+000D)\" \"New Line (U+000A)\"\n      case 0x000a: // \\n\n        ++position;\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      case 0x000d: // \\r\n        if (body.charCodeAt(position + 1) === 0x000a) {\n          position += 2;\n        } else {\n          ++position;\n        }\n        ++lexer.line;\n        lexer.lineStart = position;\n        continue;\n      // Comment\n      case 0x0023: // #\n        return readComment(lexer, position);\n      // Token ::\n      //   - Punctuator\n      //   - Name\n      //   - IntValue\n      //   - FloatValue\n      //   - StringValue\n      //\n      // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }\n      case 0x0021: // !\n        return createToken(lexer, TokenKind.BANG, position, position + 1);\n      case 0x0024: // $\n        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);\n      case 0x0026: // &\n        return createToken(lexer, TokenKind.AMP, position, position + 1);\n      case 0x0028: // (\n        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);\n      case 0x0029: // )\n        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);\n      case 0x002e: {\n        // .\n        const nextCode = body.charCodeAt(position + 1);\n        if (nextCode === 0x002e && body.charCodeAt(position + 2) === 0x002e) {\n          return createToken(lexer, TokenKind.SPREAD, position, position + 3);\n        }\n        if (nextCode === 0x002e) {\n          throw syntaxError(\n            lexer.source,\n            position,\n            'Unexpected \"..\", did you mean \"...\"?',\n          );\n        } else if (isDigit(nextCode)) {\n          const digits = lexer.source.body.slice(\n            position + 1,\n            readDigits(lexer, position + 1, nextCode),\n          );\n          throw syntaxError(\n            lexer.source,\n            position,\n            `Invalid number, expected digit before \".\", did you mean \"0.${digits}\"?`,\n          );\n        }\n        break;\n      }\n      case 0x003a: // :\n        return createToken(lexer, TokenKind.COLON, position, position + 1);\n      case 0x003d: // =\n        return createToken(lexer, TokenKind.EQUALS, position, position + 1);\n      case 0x0040: // @\n        return createToken(lexer, TokenKind.AT, position, position + 1);\n      case 0x005b: // [\n        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);\n      case 0x005d: // ]\n        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);\n      case 0x007b: // {\n        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);\n      case 0x007c: // |\n        return createToken(lexer, TokenKind.PIPE, position, position + 1);\n      case 0x007d: // }\n        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);\n      // StringValue\n      case 0x0022: // \"\n        if (\n          body.charCodeAt(position + 1) === 0x0022 &&\n          body.charCodeAt(position + 2) === 0x0022\n        ) {\n          return readBlockString(lexer, position);\n        }\n        return readString(lexer, position);\n    }\n\n    // IntValue | FloatValue (Digit | -)\n    if (isDigit(code) || code === 0x002d) {\n      return readNumber(lexer, position, code);\n    }\n\n    // Name\n    if (isNameStart(code)) {\n      return readName(lexer, position);\n    }\n\n    throw syntaxError(\n      lexer.source,\n      position,\n      code === 0x0027\n        ? 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?'\n        : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position)\n          ? `Unexpected character: ${printCodePointAt(lexer, position)}.`\n          : `Invalid character: ${printCodePointAt(lexer, position)}.`,\n    );\n  }\n\n  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);\n}\n\n/**\n * Reads a comment token from the source file.\n *\n * ```\n * Comment :: # CommentChar* [lookahead != CommentChar]\n *\n * CommentChar :: SourceCharacter but not LineTerminator\n * ```\n */\nfunction readComment(lexer: Lexer, start: number): Token {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    // LineTerminator (\\n | \\r)\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    }\n\n    // SourceCharacter\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.COMMENT,\n    start,\n    position,\n    body.slice(start + 1, position),\n  );\n}\n\n/**\n * Reads a number token from the source file, either a FloatValue or an IntValue\n * depending on whether a FractionalPart or ExponentPart is encountered.\n *\n * ```\n * IntValue :: IntegerPart [lookahead != {Digit, `.`, NameStart}]\n *\n * IntegerPart ::\n *   - NegativeSign? 0\n *   - NegativeSign? NonZeroDigit Digit*\n *\n * NegativeSign :: -\n *\n * NonZeroDigit :: Digit but not `0`\n *\n * FloatValue ::\n *   - IntegerPart FractionalPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart FractionalPart [lookahead != {Digit, `.`, NameStart}]\n *   - IntegerPart ExponentPart [lookahead != {Digit, `.`, NameStart}]\n *\n * FractionalPart :: . Digit+\n *\n * ExponentPart :: ExponentIndicator Sign? Digit+\n *\n * ExponentIndicator :: one of `e` `E`\n *\n * Sign :: one of + -\n * ```\n */\nfunction readNumber(lexer: Lexer, start: number, firstCode: number): Token {\n  const body = lexer.source.body;\n  let position = start;\n  let code = firstCode;\n  let isFloat = false;\n\n  // NegativeSign (-)\n  if (code === 0x002d) {\n    code = body.charCodeAt(++position);\n  }\n\n  // Zero (0)\n  if (code === 0x0030) {\n    code = body.charCodeAt(++position);\n    if (isDigit(code)) {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid number, unexpected digit after 0: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  } else {\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  // Full stop (.)\n  if (code === 0x002e) {\n    isFloat = true;\n\n    code = body.charCodeAt(++position);\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  // E e\n  if (code === 0x0045 || code === 0x0065) {\n    isFloat = true;\n\n    code = body.charCodeAt(++position);\n    // + -\n    if (code === 0x002b || code === 0x002d) {\n      code = body.charCodeAt(++position);\n    }\n    position = readDigits(lexer, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  // Numbers cannot be followed by . or NameStart\n  if (code === 0x002e || isNameStart(code)) {\n    throw syntaxError(\n      lexer.source,\n      position,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        position,\n      )}.`,\n    );\n  }\n\n  return createToken(\n    lexer,\n    isFloat ? TokenKind.FLOAT : TokenKind.INT,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n\n/**\n * Returns the new position in the source after reading one or more digits.\n */\nfunction readDigits(lexer: Lexer, start: number, firstCode: number): number {\n  if (!isDigit(firstCode)) {\n    throw syntaxError(\n      lexer.source,\n      start,\n      `Invalid number, expected digit but got: ${printCodePointAt(\n        lexer,\n        start,\n      )}.`,\n    );\n  }\n\n  const body = lexer.source.body;\n  let position = start + 1; // +1 to skip first firstCode\n\n  while (isDigit(body.charCodeAt(position))) {\n    ++position;\n  }\n\n  return position;\n}\n\n/**\n * Reads a single-quote string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"` [lookahead != `\"`]\n *   - `\"` StringCharacter+ `\"`\n *\n * StringCharacter ::\n *   - SourceCharacter but not `\"` or `\\` or LineTerminator\n *   - `\\u` EscapedUnicode\n *   - `\\` EscapedCharacter\n *\n * EscapedUnicode ::\n *   - `{` HexDigit+ `}`\n *   - HexDigit HexDigit HexDigit HexDigit\n *\n * EscapedCharacter :: one of `\"` `\\` `/` `b` `f` `n` `r` `t`\n * ```\n */\nfunction readString(lexer: Lexer, start: number): Token {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n  let chunkStart = position;\n  let value = '';\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    // Closing Quote (\")\n    if (code === 0x0022) {\n      value += body.slice(chunkStart, position);\n      return createToken(lexer, TokenKind.STRING, start, position + 1, value);\n    }\n\n    // Escape Sequence (\\)\n    if (code === 0x005c) {\n      value += body.slice(chunkStart, position);\n      const escape =\n        body.charCodeAt(position + 1) === 0x0075 // u\n          ? body.charCodeAt(position + 2) === 0x007b // {\n            ? readEscapedUnicodeVariableWidth(lexer, position)\n            : readEscapedUnicodeFixedWidth(lexer, position)\n          : readEscapedCharacter(lexer, position);\n      value += escape.value;\n      position += escape.size;\n      chunkStart = position;\n      continue;\n    }\n\n    // LineTerminator (\\n | \\r)\n    if (code === 0x000a || code === 0x000d) {\n      break;\n    }\n\n    // SourceCharacter\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n}\n\n// The string value and lexed size of an escape sequence.\ninterface EscapeSequence {\n  value: string;\n  size: number;\n}\n\nfunction readEscapedUnicodeVariableWidth(\n  lexer: Lexer,\n  position: number,\n): EscapeSequence {\n  const body = lexer.source.body;\n  let point = 0;\n  let size = 3;\n  // Cannot be larger than 12 chars (\\u{00000000}).\n  while (size < 12) {\n    const code = body.charCodeAt(position + size++);\n    // Closing Brace (})\n    if (code === 0x007d) {\n      // Must be at least 5 chars (\\u{0}) and encode a Unicode scalar value.\n      if (size < 5 || !isUnicodeScalarValue(point)) {\n        break;\n      }\n      return { value: String.fromCodePoint(point), size };\n    }\n    // Append this hex digit to the code point.\n    point = (point << 4) | readHexDigit(code);\n    if (point < 0) {\n      break;\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(\n      position,\n      position + size,\n    )}\".`,\n  );\n}\n\nfunction readEscapedUnicodeFixedWidth(\n  lexer: Lexer,\n  position: number,\n): EscapeSequence {\n  const body = lexer.source.body;\n  const code = read16BitHexCode(body, position + 2);\n\n  if (isUnicodeScalarValue(code)) {\n    return { value: String.fromCodePoint(code), size: 6 };\n  }\n\n  // GraphQL allows JSON-style surrogate pair escape sequences, but only when\n  // a valid pair is formed.\n  if (isLeadingSurrogate(code)) {\n    // \\u\n    if (\n      body.charCodeAt(position + 6) === 0x005c &&\n      body.charCodeAt(position + 7) === 0x0075\n    ) {\n      const trailingCode = read16BitHexCode(body, position + 8);\n      if (isTrailingSurrogate(trailingCode)) {\n        // JavaScript defines strings as a sequence of UTF-16 code units and\n        // encodes Unicode code points above U+FFFF using a surrogate pair of\n        // code units. Since this is a surrogate pair escape sequence, just\n        // include both codes into the JavaScript string value. Had JavaScript\n        // not been internally based on UTF-16, then this surrogate pair would\n        // be decoded to retrieve the supplementary code point.\n        return { value: String.fromCodePoint(code, trailingCode), size: 12 };\n      }\n    }\n  }\n\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid Unicode escape sequence: \"${body.slice(position, position + 6)}\".`,\n  );\n}\n\n/**\n * Reads four hexadecimal characters and returns the positive integer that 16bit\n * hexadecimal string represents. For example, \"000f\" will return 15, and \"dead\"\n * will return 57005.\n *\n * Returns a negative number if any char was not a valid hexadecimal digit.\n */\nfunction read16BitHexCode(body: string, position: number): number {\n  // readHexDigit() returns -1 on error. ORing a negative value with any other\n  // value always produces a negative value.\n  return (\n    (readHexDigit(body.charCodeAt(position)) << 12) |\n    (readHexDigit(body.charCodeAt(position + 1)) << 8) |\n    (readHexDigit(body.charCodeAt(position + 2)) << 4) |\n    readHexDigit(body.charCodeAt(position + 3))\n  );\n}\n\n/**\n * Reads a hexadecimal character and returns its positive integer value (0-15).\n *\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 if the provided character code was not a valid hexadecimal digit.\n *\n * HexDigit :: one of\n *   - `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\n *   - `A` `B` `C` `D` `E` `F`\n *   - `a` `b` `c` `d` `e` `f`\n */\nfunction readHexDigit(code: number): number {\n  return code >= 0x0030 && code <= 0x0039 // 0-9\n    ? code - 0x0030\n    : code >= 0x0041 && code <= 0x0046 // A-F\n      ? code - 0x0037\n      : code >= 0x0061 && code <= 0x0066 // a-f\n        ? code - 0x0057\n        : -1;\n}\n\n/**\n * | Escaped Character | Code Point | Character Name               |\n * | ----------------- | ---------- | ---------------------------- |\n * | `\"`               | U+0022     | double quote                 |\n * | `\\`               | U+005C     | reverse solidus (back slash) |\n * | `/`               | U+002F     | solidus (forward slash)      |\n * | `b`               | U+0008     | backspace                    |\n * | `f`               | U+000C     | form feed                    |\n * | `n`               | U+000A     | line feed (new line)         |\n * | `r`               | U+000D     | carriage return              |\n * | `t`               | U+0009     | horizontal tab               |\n */\nfunction readEscapedCharacter(lexer: Lexer, position: number): EscapeSequence {\n  const body = lexer.source.body;\n  const code = body.charCodeAt(position + 1);\n  switch (code) {\n    case 0x0022: // \"\n      return { value: '\\u0022', size: 2 };\n    case 0x005c: // \\\n      return { value: '\\u005c', size: 2 };\n    case 0x002f: // /\n      return { value: '\\u002f', size: 2 };\n    case 0x0062: // b\n      return { value: '\\u0008', size: 2 };\n    case 0x0066: // f\n      return { value: '\\u000c', size: 2 };\n    case 0x006e: // n\n      return { value: '\\u000a', size: 2 };\n    case 0x0072: // r\n      return { value: '\\u000d', size: 2 };\n    case 0x0074: // t\n      return { value: '\\u0009', size: 2 };\n  }\n  throw syntaxError(\n    lexer.source,\n    position,\n    `Invalid character escape sequence: \"${body.slice(\n      position,\n      position + 2,\n    )}\".`,\n  );\n}\n\n/**\n * Reads a block string token from the source file.\n *\n * ```\n * StringValue ::\n *   - `\"\"\"` BlockStringCharacter* `\"\"\"`\n *\n * BlockStringCharacter ::\n *   - SourceCharacter but not `\"\"\"` or `\\\"\"\"`\n *   - `\\\"\"\"`\n * ```\n */\nfunction readBlockString(lexer: Lexer, start: number): Token {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let lineStart = lexer.lineStart;\n\n  let position = start + 3;\n  let chunkStart = position;\n  let currentLine = '';\n\n  const blockLines = [];\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n\n    // Closing Triple-Quote (\"\"\")\n    if (\n      code === 0x0022 &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n\n      const token = createToken(\n        lexer,\n        TokenKind.BLOCK_STRING,\n        start,\n        position + 3,\n        // Return a string of the lines joined with U+000A.\n        dedentBlockStringLines(blockLines).join('\\n'),\n      );\n\n      lexer.line += blockLines.length - 1;\n      lexer.lineStart = lineStart;\n      return token;\n    }\n\n    // Escaped Triple-Quote (\\\"\"\")\n    if (\n      code === 0x005c &&\n      body.charCodeAt(position + 1) === 0x0022 &&\n      body.charCodeAt(position + 2) === 0x0022 &&\n      body.charCodeAt(position + 3) === 0x0022\n    ) {\n      currentLine += body.slice(chunkStart, position);\n      chunkStart = position + 1; // skip only slash\n      position += 4;\n      continue;\n    }\n\n    // LineTerminator\n    if (code === 0x000a || code === 0x000d) {\n      currentLine += body.slice(chunkStart, position);\n      blockLines.push(currentLine);\n\n      if (code === 0x000d && body.charCodeAt(position + 1) === 0x000a) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      currentLine = '';\n      chunkStart = position;\n      lineStart = position;\n      continue;\n    }\n\n    // SourceCharacter\n    if (isUnicodeScalarValue(code)) {\n      ++position;\n    } else if (isSupplementaryCodePoint(body, position)) {\n      position += 2;\n    } else {\n      throw syntaxError(\n        lexer.source,\n        position,\n        `Invalid character within String: ${printCodePointAt(\n          lexer,\n          position,\n        )}.`,\n      );\n    }\n  }\n\n  throw syntaxError(lexer.source, position, 'Unterminated string.');\n}\n\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * ```\n * Name ::\n *   - NameStart NameContinue* [lookahead != NameContinue]\n * ```\n */\nfunction readName(lexer: Lexer, start: number): Token {\n  const body = lexer.source.body;\n  const bodyLength = body.length;\n  let position = start + 1;\n\n  while (position < bodyLength) {\n    const code = body.charCodeAt(position);\n    if (isNameContinue(code)) {\n      ++position;\n    } else {\n      break;\n    }\n  }\n\n  return createToken(\n    lexer,\n    TokenKind.NAME,\n    start,\n    position,\n    body.slice(start, position),\n  );\n}\n"]}