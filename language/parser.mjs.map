{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../src/language/parser.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Maybe } from '../jsutils/Maybe.js';\n\nimport type { GraphQLError } from '../error/GraphQLError.js';\nimport { syntaxError } from '../error/syntaxError.js';\n\nimport type {\n  ArgumentNode,\n  BooleanValueNode,\n  ConstArgumentNode,\n  ConstDirectiveNode,\n  ConstListValueNode,\n  ConstObjectFieldNode,\n  ConstObjectValueNode,\n  ConstValueNode,\n  DefinitionNode,\n  DirectiveDefinitionNode,\n  DirectiveNode,\n  DocumentNode,\n  EnumTypeDefinitionNode,\n  EnumTypeExtensionNode,\n  EnumValueDefinitionNode,\n  EnumValueNode,\n  FieldDefinitionNode,\n  FieldNode,\n  FloatValueNode,\n  FragmentArgumentNode,\n  FragmentDefinitionNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n  InputObjectTypeDefinitionNode,\n  InputObjectTypeExtensionNode,\n  InputValueDefinitionNode,\n  InterfaceTypeDefinitionNode,\n  InterfaceTypeExtensionNode,\n  IntValueNode,\n  ListTypeNode,\n  ListValueNode,\n  NamedTypeNode,\n  NameNode,\n  NonNullTypeNode,\n  NullValueNode,\n  ObjectFieldNode,\n  ObjectTypeDefinitionNode,\n  ObjectTypeExtensionNode,\n  ObjectValueNode,\n  OperationDefinitionNode,\n  OperationTypeDefinitionNode,\n  ScalarTypeDefinitionNode,\n  ScalarTypeExtensionNode,\n  SchemaDefinitionNode,\n  SchemaExtensionNode,\n  SelectionNode,\n  SelectionSetNode,\n  StringValueNode,\n  Token,\n  TypeNode,\n  TypeSystemExtensionNode,\n  UnionTypeDefinitionNode,\n  UnionTypeExtensionNode,\n  ValueNode,\n  VariableDefinitionNode,\n  VariableNode,\n} from './ast.js';\nimport { Location, OperationTypeNode } from './ast.js';\nimport { DirectiveLocation } from './directiveLocation.js';\nimport { Kind } from './kinds.js';\nimport { isPunctuatorTokenKind, Lexer } from './lexer.js';\nimport { isSource, Source } from './source.js';\nimport { TokenKind } from './tokenKind.js';\n\n/**\n * Configuration options to control parser behavior\n */\nexport interface ParseOptions {\n  /**\n   * By default, the parser creates AST nodes that know the location\n   * in the source that they correspond to. This configuration flag\n   * disables that behavior for performance or testing.\n   */\n  noLocation?: boolean | undefined;\n\n  /**\n   * Parser CPU and memory usage is linear to the number of tokens in a document\n   * however in extreme cases it becomes quadratic due to memory exhaustion.\n   * Parsing happens before validation so even invalid queries can burn lots of\n   * CPU time and memory.\n   * To prevent this you can set a maximum number of tokens allowed within a document.\n   */\n  maxTokens?: number | undefined;\n\n  /**\n   * EXPERIMENTAL:\n   *\n   * If enabled, the parser will understand and parse fragment variable definitions\n   * and arguments on fragment spreads. Fragment variable definitions will be represented\n   * in the `variableDefinitions` field of the FragmentDefinitionNode.\n   * Fragment spread arguments will be represented in the `arguments` field of FragmentSpreadNode.\n   *\n   * For example:\n   *\n   * ```graphql\n   * {\n   *   t { ...A(var: true) }\n   * }\n   * fragment A($var: Boolean = false) on T {\n   *   ...B(x: $var)\n   * }\n   * ```\n   */\n  experimentalFragmentArguments?: boolean | undefined;\n}\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(\n  source: string | Source,\n  options?: ParseOptions | undefined,\n): DocumentNode {\n  const parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n */\nexport function parseValue(\n  source: string | Source,\n  options?: ParseOptions | undefined,\n): ValueNode {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n\n/**\n * Similar to parseValue(), but raises a parse error if it encounters a\n * variable. The return type will be a constant value.\n */\nexport function parseConstValue(\n  source: string | Source,\n  options?: ParseOptions | undefined,\n): ConstValueNode {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const value = parser.parseConstValueLiteral();\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\nexport function parseType(\n  source: string | Source,\n  options?: ParseOptions | undefined,\n): TypeNode {\n  const parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  const type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\nexport class Parser {\n  protected _options: ParseOptions;\n  protected _lexer: Lexer;\n  protected _tokenCounter: number;\n\n  constructor(source: string | Source, options: ParseOptions = {}) {\n    const sourceObj = isSource(source) ? source : new Source(source);\n\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n    this._tokenCounter = 0;\n  }\n\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n  parseName(): NameNode {\n    const token = this.expectToken(TokenKind.NAME);\n    return this.node<NameNode>(token, {\n      kind: Kind.NAME,\n      value: token.value,\n    });\n  }\n\n  // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n  parseDocument(): DocumentNode {\n    return this.node<DocumentNode>(this._lexer.token, {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(\n        TokenKind.SOF,\n        this.parseDefinition,\n        TokenKind.EOF,\n      ),\n    });\n  }\n\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   *\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n  parseDefinition(): DefinitionNode {\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    }\n\n    // Many definitions begin with a description and require a lookahead.\n    const hasDescription = this.peekDescription();\n    const keywordToken = hasDescription\n      ? this._lexer.lookahead()\n      : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n        case 'type':\n          return this.parseObjectTypeDefinition();\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n        case 'union':\n          return this.parseUnionTypeDefinition();\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n\n      if (hasDescription) {\n        throw syntaxError(\n          this._lexer.source,\n          this._lexer.token.start,\n          'Unexpected description, descriptions are supported only on type definitions.',\n        );\n      }\n\n      switch (keywordToken.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n        case 'fragment':\n          return this.parseFragmentDefinition();\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n\n  // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n  parseOperationDefinition(): OperationDefinitionNode {\n    const start = this._lexer.token;\n    if (this.peek(TokenKind.BRACE_L)) {\n      return this.node<OperationDefinitionNode>(start, {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: OperationTypeNode.QUERY,\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n    const operation = this.parseOperationType();\n    let name;\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n    return this.node<OperationDefinitionNode>(start, {\n      kind: Kind.OPERATION_DEFINITION,\n      operation,\n      name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n\n  /**\n   * OperationType : one of query mutation subscription\n   */\n  parseOperationType(): OperationTypeNode {\n    const operationToken = this.expectToken(TokenKind.NAME);\n    switch (operationToken.value) {\n      case 'query':\n        return OperationTypeNode.QUERY;\n      case 'mutation':\n        return OperationTypeNode.MUTATION;\n      case 'subscription':\n        return OperationTypeNode.SUBSCRIPTION;\n    }\n\n    throw this.unexpected(operationToken);\n  }\n\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n  parseVariableDefinitions(): Array<VariableDefinitionNode> {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseVariableDefinition,\n      TokenKind.PAREN_R,\n    );\n  }\n\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n  parseVariableDefinition(): VariableDefinitionNode {\n    return this.node<VariableDefinitionNode>(this._lexer.token, {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS)\n        ? this.parseConstValueLiteral()\n        : undefined,\n      directives: this.parseConstDirectives(),\n    });\n  }\n\n  /**\n   * Variable : $ Name\n   */\n  parseVariable(): VariableNode {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return this.node<VariableNode>(start, {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n    });\n  }\n\n  /**\n   * ```\n   * SelectionSet : { Selection+ }\n   * ```\n   */\n  parseSelectionSet(): SelectionSetNode {\n    return this.node<SelectionSetNode>(this._lexer.token, {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(\n        TokenKind.BRACE_L,\n        this.parseSelection,\n        TokenKind.BRACE_R,\n      ),\n    });\n  }\n\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n  parseSelection(): SelectionNode {\n    return this.peek(TokenKind.SPREAD)\n      ? this.parseFragment()\n      : this.parseField();\n  }\n\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n  parseField(): FieldNode {\n    const start = this._lexer.token;\n\n    const nameOrAlias = this.parseName();\n    let alias;\n    let name;\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return this.node<FieldNode>(start, {\n      kind: Kind.FIELD,\n      alias,\n      name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L)\n        ? this.parseSelectionSet()\n        : undefined,\n    });\n  }\n\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n  parseArguments(isConst: true): Array<ConstArgumentNode>;\n  parseArguments(isConst: boolean): Array<ArgumentNode>;\n  parseArguments(isConst: boolean): Array<ArgumentNode> {\n    const item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n\n  /* experimental */\n  parseFragmentArguments(): Array<FragmentArgumentNode> {\n    const item = this.parseFragmentArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n  parseArgument(isConst: true): ConstArgumentNode;\n  parseArgument(isConst?: boolean): ArgumentNode;\n  parseArgument(isConst: boolean = false): ArgumentNode {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    this.expectToken(TokenKind.COLON);\n    return this.node<ArgumentNode>(start, {\n      kind: Kind.ARGUMENT,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  parseConstArgument(): ConstArgumentNode {\n    return this.parseArgument(true);\n  }\n\n  /* experimental */\n  parseFragmentArgument(): FragmentArgumentNode {\n    const start = this._lexer.token;\n    const name = this.parseName();\n\n    this.expectToken(TokenKind.COLON);\n    return this.node<FragmentArgumentNode>(start, {\n      kind: Kind.FRAGMENT_ARGUMENT,\n      name,\n      value: this.parseValueLiteral(false),\n    });\n  }\n\n  // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Arguments? Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n  parseFragment(): FragmentSpreadNode | InlineFragmentNode {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n\n    const hasTypeCondition = this.expectOptionalKeyword('on');\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      const name = this.parseFragmentName();\n      if (\n        this.peek(TokenKind.PAREN_L) &&\n        this._options.experimentalFragmentArguments\n      ) {\n        return this.node<FragmentSpreadNode>(start, {\n          kind: Kind.FRAGMENT_SPREAD,\n          name,\n          arguments: this.parseFragmentArguments(),\n          directives: this.parseDirectives(false),\n        });\n      }\n      return this.node<FragmentSpreadNode>(start, {\n        kind: Kind.FRAGMENT_SPREAD,\n        name,\n        directives: this.parseDirectives(false),\n      });\n    }\n    return this.node<InlineFragmentNode>(start, {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n  parseFragmentDefinition(): FragmentDefinitionNode {\n    const start = this._lexer.token;\n    this.expectKeyword('fragment');\n    if (this._options.experimentalFragmentArguments === true) {\n      return this.node<FragmentDefinitionNode>(start, {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n      });\n    }\n    return this.node<FragmentDefinitionNode>(start, {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n    });\n  }\n\n  /**\n   * FragmentName : Name but not `on`\n   */\n  parseFragmentName(): NameNode {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n    return this.parseName();\n  }\n\n  // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n  parseValueLiteral(isConst: true): ConstValueNode;\n  parseValueLiteral(isConst: boolean): ValueNode;\n  parseValueLiteral(isConst: boolean): ValueNode {\n    const token = this._lexer.token;\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n      case TokenKind.INT:\n        this.advanceLexer();\n        return this.node<IntValueNode>(token, {\n          kind: Kind.INT,\n          value: token.value,\n        });\n      case TokenKind.FLOAT:\n        this.advanceLexer();\n        return this.node<FloatValueNode>(token, {\n          kind: Kind.FLOAT,\n          value: token.value,\n        });\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n      case TokenKind.NAME:\n        this.advanceLexer();\n        switch (token.value) {\n          case 'true':\n            return this.node<BooleanValueNode>(token, {\n              kind: Kind.BOOLEAN,\n              value: true,\n            });\n          case 'false':\n            return this.node<BooleanValueNode>(token, {\n              kind: Kind.BOOLEAN,\n              value: false,\n            });\n          case 'null':\n            return this.node<NullValueNode>(token, { kind: Kind.NULL });\n          default:\n            return this.node<EnumValueNode>(token, {\n              kind: Kind.ENUM,\n              value: token.value,\n            });\n        }\n      case TokenKind.DOLLAR:\n        if (isConst) {\n          this.expectToken(TokenKind.DOLLAR);\n          if (this._lexer.token.kind === TokenKind.NAME) {\n            const varName = this._lexer.token.value;\n            throw syntaxError(\n              this._lexer.source,\n              token.start,\n              `Unexpected variable \"$${varName}\" in constant value.`,\n            );\n          } else {\n            throw this.unexpected(token);\n          }\n        }\n        return this.parseVariable();\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseConstValueLiteral(): ConstValueNode {\n    return this.parseValueLiteral(true);\n  }\n\n  parseStringLiteral(): StringValueNode {\n    const token = this._lexer.token;\n    this.advanceLexer();\n    return this.node<StringValueNode>(token, {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n    });\n  }\n\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n  parseList(isConst: true): ConstListValueNode;\n  parseList(isConst: boolean): ListValueNode;\n  parseList(isConst: boolean): ListValueNode {\n    const item = () => this.parseValueLiteral(isConst);\n    return this.node<ListValueNode>(this._lexer.token, {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n    });\n  }\n\n  /**\n   * ```\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   * ```\n   */\n  parseObject(isConst: true): ConstObjectValueNode;\n  parseObject(isConst: boolean): ObjectValueNode;\n  parseObject(isConst: boolean): ObjectValueNode {\n    const item = () => this.parseObjectField(isConst);\n    return this.node<ObjectValueNode>(this._lexer.token, {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n    });\n  }\n\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n  parseObjectField(isConst: true): ConstObjectFieldNode;\n  parseObjectField(isConst: boolean): ObjectFieldNode;\n  parseObjectField(isConst: boolean): ObjectFieldNode {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return this.node<ObjectFieldNode>(start, {\n      kind: Kind.OBJECT_FIELD,\n      name,\n      value: this.parseValueLiteral(isConst),\n    });\n  }\n\n  // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n  parseDirectives(isConst: true): Array<ConstDirectiveNode>;\n  parseDirectives(isConst: boolean): Array<DirectiveNode>;\n  parseDirectives(isConst: boolean): Array<DirectiveNode> {\n    const directives = [];\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n    return directives;\n  }\n\n  parseConstDirectives(): Array<ConstDirectiveNode> {\n    return this.parseDirectives(true);\n  }\n\n  /**\n   * ```\n   * Directive[Const] : @ Name Arguments[?Const]?\n   * ```\n   */\n  parseDirective(isConst: true): ConstDirectiveNode;\n  parseDirective(isConst: boolean): DirectiveNode;\n  parseDirective(isConst: boolean): DirectiveNode {\n    const start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return this.node<DirectiveNode>(start, {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n    });\n  }\n\n  // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n  parseTypeReference(): TypeNode {\n    const start = this._lexer.token;\n    let type;\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      const innerType = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = this.node<ListTypeNode>(start, {\n        kind: Kind.LIST_TYPE,\n        type: innerType,\n      });\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return this.node<NonNullTypeNode>(start, {\n        kind: Kind.NON_NULL_TYPE,\n        type,\n      });\n    }\n\n    return type;\n  }\n\n  /**\n   * NamedType : Name\n   */\n  parseNamedType(): NamedTypeNode {\n    return this.node<NamedTypeNode>(this._lexer.token, {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n    });\n  }\n\n  // Implements the parsing rules in the Type Definition section.\n\n  peekDescription(): boolean {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n\n  /**\n   * Description : StringValue\n   */\n  parseDescription(): undefined | StringValueNode {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n\n  /**\n   * ```\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   * ```\n   */\n  parseSchemaDefinition(): SchemaDefinitionNode {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.many(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n    return this.node<SchemaDefinitionNode>(start, {\n      kind: Kind.SCHEMA_DEFINITION,\n      description,\n      directives,\n      operationTypes,\n    });\n  }\n\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n  parseOperationTypeDefinition(): OperationTypeDefinitionNode {\n    const start = this._lexer.token;\n    const operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseNamedType();\n    return this.node<OperationTypeDefinitionNode>(start, {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation,\n      type,\n    });\n  }\n\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n  parseScalarTypeDefinition(): ScalarTypeDefinitionNode {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    return this.node<ScalarTypeDefinitionNode>(start, {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n  parseObjectTypeDefinition(): ObjectTypeDefinitionNode {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node<ObjectTypeDefinitionNode>(start, {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n  parseImplementsInterfaces(): Array<NamedTypeNode> {\n    return this.expectOptionalKeyword('implements')\n      ? this.delimitedMany(TokenKind.AMP, this.parseNamedType)\n      : [];\n  }\n\n  /**\n   * ```\n   * FieldsDefinition : { FieldDefinition+ }\n   * ```\n   */\n  parseFieldsDefinition(): Array<FieldDefinitionNode> {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseFieldDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n  parseFieldDefinition(): FieldDefinitionNode {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    const directives = this.parseConstDirectives();\n    return this.node<FieldDefinitionNode>(start, {\n      kind: Kind.FIELD_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      type,\n      directives,\n    });\n  }\n\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n  parseArgumentDefs(): Array<InputValueDefinitionNode> {\n    return this.optionalMany(\n      TokenKind.PAREN_L,\n      this.parseInputValueDef,\n      TokenKind.PAREN_R,\n    );\n  }\n\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n  parseInputValueDef(): InputValueDefinitionNode {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    const type = this.parseTypeReference();\n    let defaultValue;\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseConstValueLiteral();\n    }\n    const directives = this.parseConstDirectives();\n    return this.node<InputValueDefinitionNode>(start, {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description,\n      name,\n      type,\n      defaultValue,\n      directives,\n    });\n  }\n\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n  parseInterfaceTypeDefinition(): InterfaceTypeDefinitionNode {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    return this.node<InterfaceTypeDefinitionNode>(start, {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n  parseUnionTypeDefinition(): UnionTypeDefinitionNode {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    return this.node<UnionTypeDefinitionNode>(start, {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      types,\n    });\n  }\n\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n  parseUnionMemberTypes(): Array<NamedTypeNode> {\n    return this.expectOptionalToken(TokenKind.EQUALS)\n      ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType)\n      : [];\n  }\n\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n  parseEnumTypeDefinition(): EnumTypeDefinitionNode {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    return this.node<EnumTypeDefinitionNode>(start, {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      values,\n    });\n  }\n\n  /**\n   * ```\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   * ```\n   */\n  parseEnumValuesDefinition(): Array<EnumValueDefinitionNode> {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseEnumValueDefinition,\n      TokenKind.BRACE_R,\n    );\n  }\n\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   */\n  parseEnumValueDefinition(): EnumValueDefinitionNode {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    const name = this.parseEnumValueName();\n    const directives = this.parseConstDirectives();\n    return this.node<EnumValueDefinitionNode>(start, {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description,\n      name,\n      directives,\n    });\n  }\n\n  /**\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n  parseEnumValueName(): NameNode {\n    if (\n      this._lexer.token.value === 'true' ||\n      this._lexer.token.value === 'false' ||\n      this._lexer.token.value === 'null'\n    ) {\n      throw syntaxError(\n        this._lexer.source,\n        this._lexer.token.start,\n        `${getTokenDesc(\n          this._lexer.token,\n        )} is reserved and cannot be used for an enum value.`,\n      );\n    }\n    return this.parseName();\n  }\n\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n  parseInputObjectTypeDefinition(): InputObjectTypeDefinitionNode {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    return this.node<InputObjectTypeDefinitionNode>(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description,\n      name,\n      directives,\n      fields,\n    });\n  }\n\n  /**\n   * ```\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   * ```\n   */\n  parseInputFieldsDefinition(): Array<InputValueDefinitionNode> {\n    return this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseInputValueDef,\n      TokenKind.BRACE_R,\n    );\n  }\n\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n  parseTypeSystemExtension(): TypeSystemExtensionNode {\n    const keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n        case 'type':\n          return this.parseObjectTypeExtension();\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n        case 'union':\n          return this.parseUnionTypeExtension();\n        case 'enum':\n          return this.parseEnumTypeExtension();\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n\n  /**\n   * ```\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   * ```\n   */\n  parseSchemaExtension(): SchemaExtensionNode {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    const directives = this.parseConstDirectives();\n    const operationTypes = this.optionalMany(\n      TokenKind.BRACE_L,\n      this.parseOperationTypeDefinition,\n      TokenKind.BRACE_R,\n    );\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node<SchemaExtensionNode>(start, {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives,\n      operationTypes,\n    });\n  }\n\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n  parseScalarTypeExtension(): ScalarTypeExtensionNode {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node<ScalarTypeExtensionNode>(start, {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name,\n      directives,\n    });\n  }\n\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n  parseObjectTypeExtension(): ObjectTypeExtensionNode {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n    return this.node<ObjectTypeExtensionNode>(start, {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n  parseInterfaceTypeExtension(): InterfaceTypeExtensionNode {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    const name = this.parseName();\n    const interfaces = this.parseImplementsInterfaces();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseFieldsDefinition();\n    if (\n      interfaces.length === 0 &&\n      directives.length === 0 &&\n      fields.length === 0\n    ) {\n      throw this.unexpected();\n    }\n    return this.node<InterfaceTypeExtensionNode>(start, {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name,\n      interfaces,\n      directives,\n      fields,\n    });\n  }\n\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n  parseUnionTypeExtension(): UnionTypeExtensionNode {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const types = this.parseUnionMemberTypes();\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node<UnionTypeExtensionNode>(start, {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name,\n      directives,\n      types,\n    });\n  }\n\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n  parseEnumTypeExtension(): EnumTypeExtensionNode {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const values = this.parseEnumValuesDefinition();\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node<EnumTypeExtensionNode>(start, {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name,\n      directives,\n      values,\n    });\n  }\n\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n  parseInputObjectTypeExtension(): InputObjectTypeExtensionNode {\n    const start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    const name = this.parseName();\n    const directives = this.parseConstDirectives();\n    const fields = this.parseInputFieldsDefinition();\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n    return this.node<InputObjectTypeExtensionNode>(start, {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name,\n      directives,\n      fields,\n    });\n  }\n\n  /**\n   * ```\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   * ```\n   */\n  parseDirectiveDefinition(): DirectiveDefinitionNode {\n    const start = this._lexer.token;\n    const description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    const name = this.parseName();\n    const args = this.parseArgumentDefs();\n    const repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    const locations = this.parseDirectiveLocations();\n    return this.node<DirectiveDefinitionNode>(start, {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description,\n      name,\n      arguments: args,\n      repeatable,\n      locations,\n    });\n  }\n\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n  parseDirectiveLocations(): Array<NameNode> {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n  parseDirectiveLocation(): NameNode {\n    const start = this._lexer.token;\n    const name = this.parseName();\n    if (Object.hasOwn(DirectiveLocation, name.value)) {\n      return name;\n    }\n    throw this.unexpected(start);\n  }\n\n  // Core parsing utility functions\n\n  /**\n   * Returns a node that, if configured to do so, sets a \"loc\" field as a\n   * location object, used to identify the place in the source that created a\n   * given parsed object.\n   */\n  node<T extends { loc?: Location | undefined }>(\n    startToken: Token,\n    node: T,\n  ): T {\n    if (this._options.noLocation !== true) {\n      node.loc = new Location(\n        startToken,\n        this._lexer.lastToken,\n        this._lexer.source,\n      );\n    }\n    return node;\n  }\n\n  /**\n   * Determines if the next token is of a given kind\n   */\n  peek(kind: TokenKind): boolean {\n    return this._lexer.token.kind === kind;\n  }\n\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  expectToken(kind: TokenKind): Token {\n    const token = this._lexer.token;\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return token;\n    }\n\n    throw syntaxError(\n      this._lexer.source,\n      token.start,\n      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`,\n    );\n  }\n\n  /**\n   * If the next token is of the given kind, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n  expectOptionalToken(kind: TokenKind): boolean {\n    const token = this._lexer.token;\n    if (token.kind === kind) {\n      this.advanceLexer();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  expectKeyword(value: string): void {\n    const token = this._lexer.token;\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n    } else {\n      throw syntaxError(\n        this._lexer.source,\n        token.start,\n        `Expected \"${value}\", found ${getTokenDesc(token)}.`,\n      );\n    }\n  }\n\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n  expectOptionalKeyword(value: string): boolean {\n    const token = this._lexer.token;\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this.advanceLexer();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n  unexpected(atToken?: Maybe<Token>): GraphQLError {\n    const token = atToken ?? this._lexer.token;\n    return syntaxError(\n      this._lexer.source,\n      token.start,\n      `Unexpected ${getTokenDesc(token)}.`,\n    );\n  }\n\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n  any<T>(\n    openKind: TokenKind,\n    parseFn: () => T,\n    closeKind: TokenKind,\n  ): Array<T> {\n    this.expectToken(openKind);\n    const nodes = [];\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n    return nodes;\n  }\n\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n  optionalMany<T>(\n    openKind: TokenKind,\n    parseFn: () => T,\n    closeKind: TokenKind,\n  ): Array<T> {\n    if (this.expectOptionalToken(openKind)) {\n      const nodes = [];\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n      return nodes;\n    }\n    return [];\n  }\n\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n  many<T>(\n    openKind: TokenKind,\n    parseFn: () => T,\n    closeKind: TokenKind,\n  ): Array<T> {\n    this.expectToken(openKind);\n    const nodes = [];\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n    return nodes;\n  }\n\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n  delimitedMany<T>(delimiterKind: TokenKind, parseFn: () => T): Array<T> {\n    this.expectOptionalToken(delimiterKind);\n\n    const nodes = [];\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n    return nodes;\n  }\n\n  advanceLexer(): void {\n    const { maxTokens } = this._options;\n    const token = this._lexer.advance();\n\n    if (maxTokens !== undefined && token.kind !== TokenKind.EOF) {\n      ++this._tokenCounter;\n      if (this._tokenCounter > maxTokens) {\n        throw syntaxError(\n          this._lexer.source,\n          token.start,\n          `Document contains more than ${maxTokens} tokens. Parsing aborted.`,\n        );\n      }\n    }\n  }\n}\n\n/**\n * A helper function to describe a token as a string for debugging.\n */\nfunction getTokenDesc(token: Token): string {\n  const value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? ` \"${value}\"` : '');\n}\n\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\nfunction getTokenKindDesc(kind: TokenKind): string {\n  return isPunctuatorTokenKind(kind) ? `\"${kind}\"` : kind;\n}\n"]}