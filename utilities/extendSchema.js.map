{"version":3,"file":"extendSchema.js","sourceRoot":"","sources":["../../src/utilities/extendSchema.ts"],"names":[],"mappings":"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","sourcesContent":["import { AccumulatorMap } from '../jsutils/AccumulatorMap.js';\nimport { invariant } from '../jsutils/invariant.js';\nimport type { Maybe } from '../jsutils/Maybe.js';\n\nimport type {\n  DirectiveDefinitionNode,\n  DocumentNode,\n  EnumTypeDefinitionNode,\n  EnumTypeExtensionNode,\n  EnumValueDefinitionNode,\n  FieldDefinitionNode,\n  InputObjectTypeDefinitionNode,\n  InputObjectTypeExtensionNode,\n  InputValueDefinitionNode,\n  InterfaceTypeDefinitionNode,\n  InterfaceTypeExtensionNode,\n  NamedTypeNode,\n  ObjectTypeDefinitionNode,\n  ObjectTypeExtensionNode,\n  ScalarTypeDefinitionNode,\n  ScalarTypeExtensionNode,\n  SchemaDefinitionNode,\n  SchemaExtensionNode,\n  TypeDefinitionNode,\n  TypeNode,\n  UnionTypeDefinitionNode,\n  UnionTypeExtensionNode,\n} from '../language/ast.js';\nimport { Kind } from '../language/kinds.js';\n\nimport type {\n  GraphQLEnumValueNormalizedConfigMap,\n  GraphQLFieldConfigArgumentMap,\n  GraphQLFieldNormalizedConfigMap,\n  GraphQLInputFieldNormalizedConfigMap,\n  GraphQLNamedType,\n  GraphQLType,\n} from '../type/definition.js';\nimport {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n} from '../type/definition.js';\nimport {\n  GraphQLDeprecatedDirective,\n  GraphQLDirective,\n  GraphQLOneOfDirective,\n  GraphQLSpecifiedByDirective,\n} from '../type/directives.js';\nimport { introspectionTypes } from '../type/introspection.js';\nimport { specifiedScalarTypes } from '../type/scalars.js';\nimport type {\n  GraphQLSchemaNormalizedConfig,\n  GraphQLSchemaValidationOptions,\n} from '../type/schema.js';\nimport { assertSchema, GraphQLSchema } from '../type/schema.js';\n\nimport { assertValidSDLExtension } from '../validation/validate.js';\n\nimport { getDirectiveValues } from '../execution/values.js';\n\nimport { mapSchemaConfig, SchemaElementKind } from './mapSchemaConfig.js';\n\ninterface Options extends GraphQLSchemaValidationOptions {\n  /**\n   * Set to true to assume the SDL is valid.\n   *\n   * Default: false\n   */\n  assumeValidSDL?: boolean | undefined;\n}\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\nexport function extendSchema(\n  schema: GraphQLSchema,\n  documentAST: DocumentNode,\n  options?: Options,\n): GraphQLSchema {\n  assertSchema(schema);\n\n  if (options?.assumeValid !== true && options?.assumeValidSDL !== true) {\n    assertValidSDLExtension(documentAST, schema);\n  }\n\n  const schemaConfig = schema.toConfig();\n  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);\n  return schemaConfig === extendedConfig\n    ? schema\n    : new GraphQLSchema(extendedConfig);\n}\n\n/**\n * @internal\n */\nexport function extendSchemaImpl(\n  schemaConfig: GraphQLSchemaNormalizedConfig,\n  documentAST: DocumentNode,\n  options?: Options,\n): GraphQLSchemaNormalizedConfig {\n  // Collect the type definitions and extensions found in the document.\n  const typeDefs: Array<TypeDefinitionNode> = [];\n\n  const scalarExtensions = new AccumulatorMap<\n    string,\n    ScalarTypeExtensionNode\n  >();\n  const objectExtensions = new AccumulatorMap<\n    string,\n    ObjectTypeExtensionNode\n  >();\n  const interfaceExtensions = new AccumulatorMap<\n    string,\n    InterfaceTypeExtensionNode\n  >();\n  const unionExtensions = new AccumulatorMap<string, UnionTypeExtensionNode>();\n  const enumExtensions = new AccumulatorMap<string, EnumTypeExtensionNode>();\n  const inputObjectExtensions = new AccumulatorMap<\n    string,\n    InputObjectTypeExtensionNode\n  >();\n\n  // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n  const directiveDefs: Array<DirectiveDefinitionNode> = [];\n\n  let schemaDef: Maybe<SchemaDefinitionNode>;\n  // Schema extensions are collected which may add additional operation types.\n  const schemaExtensions: Array<SchemaExtensionNode> = [];\n\n  let isSchemaChanged = false;\n  for (const def of documentAST.definitions) {\n    switch (def.kind) {\n      case Kind.SCHEMA_DEFINITION:\n        schemaDef = def;\n        break;\n      case Kind.SCHEMA_EXTENSION:\n        schemaExtensions.push(def);\n        break;\n      case Kind.DIRECTIVE_DEFINITION:\n        directiveDefs.push(def);\n        break;\n\n      // Type Definitions\n      case Kind.SCALAR_TYPE_DEFINITION:\n      case Kind.OBJECT_TYPE_DEFINITION:\n      case Kind.INTERFACE_TYPE_DEFINITION:\n      case Kind.UNION_TYPE_DEFINITION:\n      case Kind.ENUM_TYPE_DEFINITION:\n      case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n        typeDefs.push(def);\n        break;\n\n      // Type System Extensions\n      case Kind.SCALAR_TYPE_EXTENSION:\n        scalarExtensions.add(def.name.value, def);\n        break;\n      case Kind.OBJECT_TYPE_EXTENSION:\n        objectExtensions.add(def.name.value, def);\n        break;\n      case Kind.INTERFACE_TYPE_EXTENSION:\n        interfaceExtensions.add(def.name.value, def);\n        break;\n      case Kind.UNION_TYPE_EXTENSION:\n        unionExtensions.add(def.name.value, def);\n        break;\n      case Kind.ENUM_TYPE_EXTENSION:\n        enumExtensions.add(def.name.value, def);\n        break;\n      case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n        inputObjectExtensions.add(def.name.value, def);\n        break;\n      default:\n        continue;\n    }\n    isSchemaChanged = true;\n  }\n\n  // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n  if (!isSchemaChanged) {\n    return schemaConfig;\n  }\n\n  return mapSchemaConfig(schemaConfig, (context) => {\n    const { getNamedType, setNamedType, getNamedTypes } = context;\n    return {\n      [SchemaElementKind.SCHEMA]: (config) => {\n        for (const typeNode of typeDefs) {\n          const type =\n            stdTypeMap.get(typeNode.name.value) ?? buildNamedType(typeNode);\n          setNamedType(type);\n        }\n\n        const operationTypes = {\n          // Get the extended root operation types.\n          query:\n            config.query &&\n            (getNamedType(config.query.name) as GraphQLObjectType),\n          mutation:\n            config.mutation &&\n            (getNamedType(config.mutation.name) as GraphQLObjectType),\n          subscription:\n            config.subscription &&\n            (getNamedType(config.subscription.name) as GraphQLObjectType),\n          // Then, incorporate schema definition and all schema extensions.\n          ...(schemaDef && getOperationTypes([schemaDef])),\n          ...getOperationTypes(schemaExtensions),\n        };\n\n        // Then produce and return a Schema config with these types.\n        return {\n          description: schemaDef?.description?.value ?? config.description,\n          ...operationTypes,\n          types: getNamedTypes(),\n          directives: [\n            ...config.directives,\n            ...directiveDefs.map(buildDirective),\n          ],\n          extensions: config.extensions,\n          astNode: schemaDef ?? config.astNode,\n          extensionASTNodes: config.extensionASTNodes.concat(schemaExtensions),\n          assumeValid: options?.assumeValid ?? false,\n        };\n      },\n      [SchemaElementKind.INPUT_OBJECT]: (config) => {\n        const extensions = inputObjectExtensions.get(config.name) ?? [];\n        return {\n          ...config,\n          fields: () => ({\n            ...config.fields(),\n            ...buildInputFieldMap(extensions),\n          }),\n          extensionASTNodes: config.extensionASTNodes.concat(extensions),\n        };\n      },\n      [SchemaElementKind.ENUM]: (config) => {\n        const extensions = enumExtensions.get(config.name) ?? [];\n        return {\n          ...config,\n          values: () => ({\n            ...config.values(),\n            ...buildEnumValueMap(extensions),\n          }),\n          extensionASTNodes: config.extensionASTNodes.concat(extensions),\n        };\n      },\n      [SchemaElementKind.SCALAR]: (config) => {\n        const extensions = scalarExtensions.get(config.name) ?? [];\n        let specifiedByURL = config.specifiedByURL;\n        for (const extensionNode of extensions) {\n          specifiedByURL = getSpecifiedByURL(extensionNode) ?? specifiedByURL;\n        }\n        return {\n          ...config,\n          specifiedByURL,\n          extensionASTNodes: config.extensionASTNodes.concat(extensions),\n        };\n      },\n      [SchemaElementKind.OBJECT]: (config) => {\n        const extensions = objectExtensions.get(config.name) ?? [];\n        return {\n          ...config,\n          interfaces: () => [\n            ...config.interfaces(),\n            ...buildInterfaces(extensions),\n          ],\n          fields: () => ({\n            ...config.fields(),\n            ...buildFieldMap(extensions),\n          }),\n          extensionASTNodes: config.extensionASTNodes.concat(extensions),\n        };\n      },\n      [SchemaElementKind.INTERFACE]: (config) => {\n        const extensions = interfaceExtensions.get(config.name) ?? [];\n        return {\n          ...config,\n          interfaces: () => [\n            ...config.interfaces(),\n            ...buildInterfaces(extensions),\n          ],\n          fields: () => ({\n            ...config.fields(),\n            ...buildFieldMap(extensions),\n          }),\n          extensionASTNodes: config.extensionASTNodes.concat(extensions),\n        };\n      },\n      [SchemaElementKind.UNION]: (config) => {\n        const extensions = unionExtensions.get(config.name) ?? [];\n        return {\n          ...config,\n          types: () => [...config.types(), ...buildUnionTypes(extensions)],\n          extensionASTNodes: config.extensionASTNodes.concat(extensions),\n        };\n      },\n    };\n\n    function getOperationTypes(\n      nodes: ReadonlyArray<SchemaDefinitionNode | SchemaExtensionNode>,\n    ): {\n      query?: Maybe<GraphQLObjectType>;\n      mutation?: Maybe<GraphQLObjectType>;\n      subscription?: Maybe<GraphQLObjectType>;\n    } {\n      const opTypes = {};\n      for (const node of nodes) {\n        const operationTypesNodes = node.operationTypes ?? [];\n\n        for (const operationType of operationTypesNodes) {\n          // Note: While this could make early assertions to get the correctly\n          // typed values below, that would throw immediately while type system\n          // validation with validateSchema() will produce more actionable results.\n          // @ts-expect-error\n          opTypes[operationType.operation] = namedTypeFromAST(\n            operationType.type,\n          );\n        }\n      }\n\n      return opTypes;\n    }\n\n    function namedTypeFromAST(node: NamedTypeNode): GraphQLNamedType {\n      const name = node.name.value;\n      const type = getNamedType(name);\n      invariant(type !== undefined, `Unknown type: \"${name}\".`);\n      return type;\n    }\n\n    function typeFromAST(node: TypeNode): GraphQLType {\n      if (node.kind === Kind.LIST_TYPE) {\n        return new GraphQLList(typeFromAST(node.type));\n      }\n      if (node.kind === Kind.NON_NULL_TYPE) {\n        return new GraphQLNonNull(typeFromAST(node.type));\n      }\n      return namedTypeFromAST(node);\n    }\n\n    function buildDirective(node: DirectiveDefinitionNode): GraphQLDirective {\n      return new GraphQLDirective({\n        name: node.name.value,\n        description: node.description?.value,\n        // @ts-expect-error\n        locations: node.locations.map(({ value }) => value),\n        isRepeatable: node.repeatable,\n        args: buildArgumentMap(node.arguments),\n        astNode: node,\n      });\n    }\n\n    function buildFieldMap(\n      nodes: ReadonlyArray<\n        | InterfaceTypeDefinitionNode\n        | InterfaceTypeExtensionNode\n        | ObjectTypeDefinitionNode\n        | ObjectTypeExtensionNode\n      >,\n    ): GraphQLFieldNormalizedConfigMap<unknown, unknown> {\n      const fieldConfigMap = Object.create(null);\n      for (const node of nodes) {\n        const nodeFields = node.fields ?? [];\n\n        for (const field of nodeFields) {\n          fieldConfigMap[field.name.value] = {\n            // Note: While this could make assertions to get the correctly typed\n            // value, that would throw immediately while type system validation\n            // with validateSchema() will produce more actionable results.\n            type: typeFromAST(field.type),\n            description: field.description?.value,\n            args: buildArgumentMap(field.arguments),\n            deprecationReason: getDeprecationReason(field),\n            astNode: field,\n          };\n        }\n      }\n      return fieldConfigMap;\n    }\n\n    function buildArgumentMap(\n      args: Maybe<ReadonlyArray<InputValueDefinitionNode>>,\n    ): GraphQLFieldConfigArgumentMap {\n      const argsNodes = args ?? [];\n\n      const argConfigMap = Object.create(null);\n      for (const arg of argsNodes) {\n        // Note: While this could make assertions to get the correctly typed\n        // value, that would throw immediately while type system validation\n        // with validateSchema() will produce more actionable results.\n        const type: any = typeFromAST(arg.type);\n\n        argConfigMap[arg.name.value] = {\n          type,\n          description: arg.description?.value,\n          default: arg.defaultValue && { literal: arg.defaultValue },\n          deprecationReason: getDeprecationReason(arg),\n          astNode: arg,\n        };\n      }\n      return argConfigMap;\n    }\n\n    function buildInputFieldMap(\n      nodes: ReadonlyArray<\n        InputObjectTypeDefinitionNode | InputObjectTypeExtensionNode\n      >,\n    ): GraphQLInputFieldNormalizedConfigMap {\n      const inputFieldMap = Object.create(null);\n      for (const node of nodes) {\n        const fieldsNodes = node.fields ?? [];\n\n        for (const field of fieldsNodes) {\n          // Note: While this could make assertions to get the correctly typed\n          // value, that would throw immediately while type system validation\n          // with validateSchema() will produce more actionable results.\n          const type: any = typeFromAST(field.type);\n\n          inputFieldMap[field.name.value] = {\n            type,\n            description: field.description?.value,\n            default: field.defaultValue && { literal: field.defaultValue },\n            deprecationReason: getDeprecationReason(field),\n            astNode: field,\n          };\n        }\n      }\n      return inputFieldMap;\n    }\n\n    function buildEnumValueMap(\n      nodes: ReadonlyArray<EnumTypeDefinitionNode | EnumTypeExtensionNode>,\n    ): GraphQLEnumValueNormalizedConfigMap {\n      const enumValueMap = Object.create(null);\n      for (const node of nodes) {\n        const valuesNodes = node.values ?? [];\n\n        for (const value of valuesNodes) {\n          enumValueMap[value.name.value] = {\n            description: value.description?.value,\n            deprecationReason: getDeprecationReason(value),\n            astNode: value,\n          };\n        }\n      }\n      return enumValueMap;\n    }\n\n    function buildInterfaces(\n      nodes: ReadonlyArray<\n        | InterfaceTypeDefinitionNode\n        | InterfaceTypeExtensionNode\n        | ObjectTypeDefinitionNode\n        | ObjectTypeExtensionNode\n      >,\n    ): Array<GraphQLInterfaceType> {\n      // Note: While this could make assertions to get the correctly typed\n      // values below, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      // @ts-expect-error\n      return nodes.flatMap(\n        (node) => node.interfaces?.map(namedTypeFromAST) ?? [],\n      );\n    }\n\n    function buildUnionTypes(\n      nodes: ReadonlyArray<UnionTypeDefinitionNode | UnionTypeExtensionNode>,\n    ): Array<GraphQLObjectType> {\n      // Note: While this could make assertions to get the correctly typed\n      // values below, that would throw immediately while type system\n      // validation with validateSchema() will produce more actionable results.\n      // @ts-expect-error\n      return nodes.flatMap((node) => node.types?.map(namedTypeFromAST) ?? []);\n    }\n\n    function buildNamedType(astNode: TypeDefinitionNode): GraphQLNamedType {\n      const name = astNode.name.value;\n\n      switch (astNode.kind) {\n        case Kind.OBJECT_TYPE_DEFINITION: {\n          const extensionASTNodes = objectExtensions.get(name) ?? [];\n          const allNodes = [astNode, ...extensionASTNodes];\n\n          return new GraphQLObjectType({\n            name,\n            description: astNode.description?.value,\n            interfaces: () => buildInterfaces(allNodes),\n            fields: () => buildFieldMap(allNodes),\n            astNode,\n            extensionASTNodes,\n          });\n        }\n        case Kind.INTERFACE_TYPE_DEFINITION: {\n          const extensionASTNodes = interfaceExtensions.get(name) ?? [];\n          const allNodes = [astNode, ...extensionASTNodes];\n\n          return new GraphQLInterfaceType({\n            name,\n            description: astNode.description?.value,\n            interfaces: () => buildInterfaces(allNodes),\n            fields: () => buildFieldMap(allNodes),\n            astNode,\n            extensionASTNodes,\n          });\n        }\n        case Kind.ENUM_TYPE_DEFINITION: {\n          const extensionASTNodes = enumExtensions.get(name) ?? [];\n          const allNodes = [astNode, ...extensionASTNodes];\n\n          return new GraphQLEnumType({\n            name,\n            description: astNode.description?.value,\n            values: () => buildEnumValueMap(allNodes),\n            astNode,\n            extensionASTNodes,\n          });\n        }\n        case Kind.UNION_TYPE_DEFINITION: {\n          const extensionASTNodes = unionExtensions.get(name) ?? [];\n          const allNodes = [astNode, ...extensionASTNodes];\n\n          return new GraphQLUnionType({\n            name,\n            description: astNode.description?.value,\n            types: () => buildUnionTypes(allNodes),\n            astNode,\n            extensionASTNodes,\n          });\n        }\n        case Kind.SCALAR_TYPE_DEFINITION: {\n          const extensionASTNodes = scalarExtensions.get(name) ?? [];\n          return new GraphQLScalarType({\n            name,\n            description: astNode.description?.value,\n            specifiedByURL: getSpecifiedByURL(astNode),\n            astNode,\n            extensionASTNodes,\n          });\n        }\n        case Kind.INPUT_OBJECT_TYPE_DEFINITION: {\n          const extensionASTNodes = inputObjectExtensions.get(name) ?? [];\n          const allNodes = [astNode, ...extensionASTNodes];\n\n          return new GraphQLInputObjectType({\n            name,\n            description: astNode.description?.value,\n            fields: () => buildInputFieldMap(allNodes),\n            astNode,\n            extensionASTNodes,\n            isOneOf: isOneOf(astNode),\n          });\n        }\n      }\n    }\n  });\n}\n\nconst stdTypeMap = new Map(\n  [...specifiedScalarTypes, ...introspectionTypes].map((type) => [\n    type.name,\n    type,\n  ]),\n);\n\n/**\n * Given a field or enum value node, returns the string value for the\n * deprecation reason.\n */\nfunction getDeprecationReason(\n  node:\n    | EnumValueDefinitionNode\n    | FieldDefinitionNode\n    | InputValueDefinitionNode,\n): Maybe<string> {\n  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  // @ts-expect-error validated by `getDirectiveValues`\n  return deprecated?.reason;\n}\n\n/**\n * Given a scalar node, returns the string value for the specifiedByURL.\n */\nfunction getSpecifiedByURL(\n  node: ScalarTypeDefinitionNode | ScalarTypeExtensionNode,\n): Maybe<string> {\n  const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);\n  // @ts-expect-error validated by `getDirectiveValues`\n  return specifiedBy?.url;\n}\n\n/**\n * Given an input object node, returns if the node should be OneOf.\n */\nfunction isOneOf(node: InputObjectTypeDefinitionNode): boolean {\n  return Boolean(getDirectiveValues(GraphQLOneOfDirective, node));\n}\n"]}