{"version":3,"file":"typeComparators.js","sourceRoot":"","sources":["../../src/utilities/typeComparators.ts"],"names":[],"mappings":"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","sourcesContent":["import type { GraphQLCompositeType, GraphQLType } from '../type/definition.js';\nimport {\n  isAbstractType,\n  isInterfaceType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../type/definition.js';\nimport type { GraphQLSchema } from '../type/schema.js';\n\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\nexport function isEqualType(typeA: GraphQLType, typeB: GraphQLType): boolean {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  }\n\n  // If either type is non-null, the other must also be non-null.\n  if (isNonNullType(typeA) && isNonNullType(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  }\n\n  // If either type is a list, the other must also be a list.\n  if (isListType(typeA) && isListType(typeB)) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  }\n\n  // Otherwise the types are not equal.\n  return false;\n}\n\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\nexport function isTypeSubTypeOf(\n  schema: GraphQLSchema,\n  maybeSubType: GraphQLType,\n  superType: GraphQLType,\n): boolean {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  }\n\n  // If superType is non-null, maybeSubType must also be non-null.\n  if (isNonNullType(superType)) {\n    if (isNonNullType(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n    return false;\n  }\n  if (isNonNullType(maybeSubType)) {\n    // If superType is nullable, maybeSubType may be non-null or nullable.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  }\n\n  // If superType type is a list, maybeSubType type must also be a list.\n  if (isListType(superType)) {\n    if (isListType(maybeSubType)) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n    return false;\n  }\n  if (isListType(maybeSubType)) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  }\n\n  // If superType type is an abstract type, check if it is super type of maybeSubType.\n  // Otherwise, the child type is not a valid subtype of the parent type.\n  return (\n    isAbstractType(superType) &&\n    (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) &&\n    schema.isSubType(superType, maybeSubType)\n  );\n}\n\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\nexport function doTypesOverlap(\n  schema: GraphQLSchema,\n  typeA: GraphQLCompositeType,\n  typeB: GraphQLCompositeType,\n): boolean {\n  // Equivalent types overlap\n  if (typeA === typeB) {\n    return true;\n  }\n\n  if (isAbstractType(typeA)) {\n    if (isAbstractType(typeB)) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema\n        .getPossibleTypes(typeA)\n        .some((type) => schema.isSubType(typeB, type));\n    }\n    // Determine if the latter type is a possible concrete type of the former.\n    return schema.isSubType(typeA, typeB);\n  }\n\n  if (isAbstractType(typeB)) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isSubType(typeB, typeA);\n  }\n\n  // Otherwise the types do not overlap.\n  return false;\n}\n"]}