{"version":3,"file":"valueFromAST.js","sourceRoot":"","sources":["../../src/utilities/valueFromAST.ts"],"names":[],"mappings":"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","sourcesContent":["import { inspect } from '../jsutils/inspect.js';\nimport { invariant } from '../jsutils/invariant.js';\nimport type { Maybe } from '../jsutils/Maybe.js';\nimport type { ObjMap } from '../jsutils/ObjMap.js';\n\nimport type { ValueNode } from '../language/ast.js';\nimport { Kind } from '../language/kinds.js';\n\nimport type { GraphQLInputType } from '../type/definition.js';\nimport {\n  isInputObjectType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n} from '../type/definition.js';\n\n/**\n * Produces a JavaScript value given a GraphQL Value AST.\n *\n * A GraphQL type must be provided, which will be used to interpret different\n * GraphQL Value literals.\n *\n * Returns `undefined` when the value could not be validly coerced according to\n * the provided type.\n *\n * | GraphQL Value        | JSON Value    |\n * | -------------------- | ------------- |\n * | Input Object         | Object        |\n * | List                 | Array         |\n * | Boolean              | Boolean       |\n * | String               | String        |\n * | Int / Float          | Number        |\n * | Enum Value           | Unknown       |\n * | NullValue            | null          |\n *\n * @deprecated use `coerceInputLiteral()` instead - will be removed in v18\n */\nexport function valueFromAST(\n  valueNode: Maybe<ValueNode>,\n  type: GraphQLInputType,\n  variables?: Maybe<ObjMap<unknown>>,\n): unknown {\n  if (!valueNode) {\n    // When there is no node, then there is also no value.\n    // Importantly, this is different from returning the value null.\n    return;\n  }\n\n  if (valueNode.kind === Kind.VARIABLE) {\n    const variableName = valueNode.name.value;\n    const variableValue = variables?.[variableName];\n    if (variableValue === undefined) {\n      // No valid return value.\n      return;\n    }\n    if (variableValue === null && isNonNullType(type)) {\n      return; // Invalid: intentionally return no value.\n    }\n    // Note: This does no further checking that this variable is correct.\n    // This assumes that this query has been validated and the variable\n    // usage here is of the correct type.\n    return variableValue;\n  }\n\n  if (isNonNullType(type)) {\n    if (valueNode.kind === Kind.NULL) {\n      return; // Invalid: intentionally return no value.\n    }\n    return valueFromAST(valueNode, type.ofType, variables);\n  }\n\n  if (valueNode.kind === Kind.NULL) {\n    // This is explicitly returning the value null.\n    return null;\n  }\n\n  if (isListType(type)) {\n    const itemType = type.ofType;\n    if (valueNode.kind === Kind.LIST) {\n      const coercedValues = [];\n      for (const itemNode of valueNode.values) {\n        if (isMissingVariable(itemNode, variables)) {\n          // If an array contains a missing variable, it is either coerced to\n          // null or if the item type is non-null, it considered invalid.\n          if (isNonNullType(itemType)) {\n            return; // Invalid: intentionally return no value.\n          }\n          coercedValues.push(null);\n        } else {\n          const itemValue = valueFromAST(itemNode, itemType, variables);\n          if (itemValue === undefined) {\n            return; // Invalid: intentionally return no value.\n          }\n          coercedValues.push(itemValue);\n        }\n      }\n      return coercedValues;\n    }\n    const coercedValue = valueFromAST(valueNode, itemType, variables);\n    if (coercedValue === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n    return [coercedValue];\n  }\n\n  if (isInputObjectType(type)) {\n    if (valueNode.kind !== Kind.OBJECT) {\n      return; // Invalid: intentionally return no value.\n    }\n    const coercedObj = Object.create(null);\n    const fieldNodes = new Map(\n      valueNode.fields.map((field) => [field.name.value, field]),\n    );\n    for (const field of Object.values(type.getFields())) {\n      const fieldNode = fieldNodes.get(field.name);\n      if (fieldNode == null || isMissingVariable(fieldNode.value, variables)) {\n        if (field.defaultValue !== undefined) {\n          coercedObj[field.name] = field.defaultValue;\n        } else if (isNonNullType(field.type)) {\n          return; // Invalid: intentionally return no value.\n        }\n        continue;\n      }\n      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);\n      if (fieldValue === undefined) {\n        return; // Invalid: intentionally return no value.\n      }\n      coercedObj[field.name] = fieldValue;\n    }\n\n    if (type.isOneOf) {\n      const keys = Object.keys(coercedObj);\n      if (keys.length !== 1) {\n        return; // Invalid: not exactly one key, intentionally return no value.\n      }\n\n      if (coercedObj[keys[0]] === null) {\n        return; // Invalid: value not non-null, intentionally return no value.\n      }\n    }\n\n    return coercedObj;\n  }\n\n  if (isLeafType(type)) {\n    // Scalars and Enums fulfill parsing a literal value via parseLiteral().\n    // Invalid values represent a failure to parse correctly, in which case\n    // no value is returned.\n    let result;\n    try {\n      result = type.parseLiteral(valueNode, variables);\n    } catch (_error) {\n      return; // Invalid: intentionally return no value.\n    }\n    if (result === undefined) {\n      return; // Invalid: intentionally return no value.\n    }\n    return result;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable, all possible input types have been considered.\n  invariant(false, 'Unexpected input type: ' + inspect(type));\n}\n\n// Returns true if the provided valueNode is a variable which is not defined\n// in the set of variables.\nfunction isMissingVariable(\n  valueNode: ValueNode,\n  variables: Maybe<ObjMap<unknown>>,\n): boolean {\n  return (\n    valueNode.kind === Kind.VARIABLE &&\n    (variables == null || variables[valueNode.name.value] === undefined)\n  );\n}\n"]}