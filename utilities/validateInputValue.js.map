{"version":3,"file":"validateInputValue.js","sourceRoot":"","sources":["../../src/utilities/validateInputValue.ts"],"names":[],"mappings":"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","sourcesContent":["import { didYouMean } from '../jsutils/didYouMean.js';\nimport { inspect } from '../jsutils/inspect.js';\nimport { isIterableObject } from '../jsutils/isIterableObject.js';\nimport { isObjectLike } from '../jsutils/isObjectLike.js';\nimport { keyMap } from '../jsutils/keyMap.js';\nimport type { Maybe } from '../jsutils/Maybe.js';\nimport type { Path } from '../jsutils/Path.js';\nimport { addPath, pathToArray } from '../jsutils/Path.js';\nimport { suggestionList } from '../jsutils/suggestionList.js';\n\nimport { GraphQLError } from '../error/GraphQLError.js';\n\nimport type { ASTNode, ValueNode, VariableNode } from '../language/ast.js';\nimport { Kind } from '../language/kinds.js';\nimport { print } from '../language/printer.js';\n\nimport type { GraphQLInputType } from '../type/definition.js';\nimport {\n  assertLeafType,\n  isInputObjectType,\n  isListType,\n  isNonNullType,\n  isRequiredInputField,\n} from '../type/definition.js';\n\nimport type { FragmentVariableValues } from '../execution/collectFields.js';\nimport type { VariableValues } from '../execution/values.js';\n\nimport { replaceVariables } from './replaceVariables.js';\n\n/**\n * Validate that the provided input value is allowed for this type, collecting\n * all errors via a callback function.\n */\nexport function validateInputValue(\n  inputValue: unknown,\n  type: GraphQLInputType,\n  onError: (error: GraphQLError, path: ReadonlyArray<string | number>) => void,\n  hideSuggestions?: Maybe<boolean>,\n): void {\n  return validateInputValueImpl(\n    inputValue,\n    type,\n    onError,\n    hideSuggestions,\n    undefined,\n  );\n}\n\nfunction validateInputValueImpl(\n  inputValue: unknown,\n  type: GraphQLInputType,\n  onError: (error: GraphQLError, path: ReadonlyArray<string | number>) => void,\n  hideSuggestions: Maybe<boolean>,\n  path: Path | undefined,\n): void {\n  if (isNonNullType(type)) {\n    if (inputValue === undefined) {\n      reportInvalidValue(\n        onError,\n        `Expected a value of non-null type \"${type}\" to be provided.`,\n        path,\n      );\n      return;\n    }\n    if (inputValue === null) {\n      reportInvalidValue(\n        onError,\n        `Expected value of non-null type \"${type}\" not to be null.`,\n        path,\n      );\n      return;\n    }\n    return validateInputValueImpl(\n      inputValue,\n      type.ofType,\n      onError,\n      hideSuggestions,\n      path,\n    );\n  }\n\n  if (inputValue == null) {\n    return;\n  }\n\n  if (isListType(type)) {\n    if (!isIterableObject(inputValue)) {\n      // Lists accept a non-list value as a list of one.\n      validateInputValueImpl(\n        inputValue,\n        type.ofType,\n        onError,\n        hideSuggestions,\n        path,\n      );\n    } else {\n      let index = 0;\n      for (const itemValue of inputValue) {\n        validateInputValueImpl(\n          itemValue,\n          type.ofType,\n          onError,\n          hideSuggestions,\n          addPath(path, index++, undefined),\n        );\n      }\n    }\n  } else if (isInputObjectType(type)) {\n    if (!isObjectLike(inputValue)) {\n      reportInvalidValue(\n        onError,\n        `Expected value of type \"${type}\" to be an object, found: ${inspect(\n          inputValue,\n        )}.`,\n        path,\n      );\n      return;\n    }\n\n    const fieldDefs = type.getFields();\n\n    for (const field of Object.values(fieldDefs)) {\n      const fieldValue = inputValue[field.name];\n      if (fieldValue === undefined) {\n        if (isRequiredInputField(field)) {\n          reportInvalidValue(\n            onError,\n            `Expected value of type \"${type}\" to include required field \"${\n              field.name\n            }\", found: ${inspect(inputValue)}.`,\n            path,\n          );\n        }\n      } else {\n        validateInputValueImpl(\n          fieldValue,\n          field.type,\n          onError,\n          hideSuggestions,\n          addPath(path, field.name, type.name),\n        );\n      }\n    }\n\n    const fields = Object.keys(inputValue);\n    // Ensure every provided field is defined.\n    for (const fieldName of fields) {\n      if (!Object.hasOwn(fieldDefs, fieldName)) {\n        const suggestion = hideSuggestions\n          ? ''\n          : didYouMean(suggestionList(fieldName, Object.keys(fieldDefs)));\n        reportInvalidValue(\n          onError,\n          `Expected value of type \"${type}\" not to include unknown field \"${fieldName}\"${\n            suggestion ? `.${suggestion} Found` : ', found'\n          }: ${inspect(inputValue)}.`,\n          path,\n        );\n      }\n    }\n\n    if (type.isOneOf) {\n      if (fields.length !== 1) {\n        reportInvalidValue(\n          onError,\n          `Exactly one key must be specified for OneOf type \"${type}\".`,\n          path,\n        );\n      }\n\n      const field = fields[0];\n      const value = inputValue[field];\n      if (value === null) {\n        reportInvalidValue(\n          onError,\n          `Field \"${field}\" for OneOf type \"${type}\" must be non-null.`,\n          path,\n        );\n      }\n    }\n  } else {\n    assertLeafType(type);\n\n    let result;\n    let caughtError;\n\n    try {\n      result = type.coerceInputValue(inputValue, hideSuggestions);\n    } catch (error) {\n      if (error instanceof GraphQLError) {\n        onError(error, pathToArray(path));\n        return;\n      }\n      caughtError = error;\n    }\n\n    if (result === undefined) {\n      reportInvalidValue(\n        onError,\n        `Expected value of type \"${type}\"${\n          caughtError != null\n            ? `, but encountered error \"${caughtError.message != null && caughtError.message !== '' ? caughtError.message : caughtError}\"; found`\n            : ', found'\n        }: ${inspect(inputValue)}.`,\n        path,\n        caughtError,\n      );\n    }\n  }\n}\n\nfunction reportInvalidValue(\n  onError: (error: GraphQLError, path: ReadonlyArray<string | number>) => void,\n  message: string,\n  path: Path | undefined,\n  originalError?: GraphQLError,\n): void {\n  onError(new GraphQLError(message, { originalError }), pathToArray(path));\n}\n\n/**\n * Validate that the provided input literal is allowed for this type, collecting\n * all errors via a callback function.\n *\n * If variable values are not provided, the literal is validated statically\n * (not assuming that those variables are missing runtime values).\n */\n// eslint-disable-next-line @typescript-eslint/max-params\nexport function validateInputLiteral(\n  valueNode: ValueNode,\n  type: GraphQLInputType,\n  onError: (error: GraphQLError, path: ReadonlyArray<string | number>) => void,\n  variables?: Maybe<VariableValues>,\n  fragmentVariableValues?: Maybe<FragmentVariableValues>,\n  hideSuggestions?: Maybe<boolean>,\n): void {\n  const context: ValidationContext = {\n    static: !variables && !fragmentVariableValues,\n    onError,\n    variables,\n    fragmentVariableValues,\n  };\n  return validateInputLiteralImpl(\n    context,\n    valueNode,\n    type,\n    hideSuggestions,\n    undefined,\n  );\n}\n\ninterface ValidationContext {\n  static: boolean;\n  onError: (error: GraphQLError, path: ReadonlyArray<string | number>) => void;\n  variables?: Maybe<VariableValues>;\n  fragmentVariableValues?: Maybe<FragmentVariableValues>;\n}\n\nfunction validateInputLiteralImpl(\n  context: ValidationContext,\n  valueNode: ValueNode,\n  type: GraphQLInputType,\n  hideSuggestions: Maybe<boolean>,\n  path: Path | undefined,\n): void {\n  if (valueNode.kind === Kind.VARIABLE) {\n    if (context.static) {\n      // If no variable values are provided, this is being validated statically,\n      // and cannot yet produce any validation errors for variables.\n      return;\n    }\n    const scopedVariableValues = getScopedVariableValues(context, valueNode);\n    const value = scopedVariableValues?.coerced[valueNode.name.value];\n    if (isNonNullType(type)) {\n      if (value === undefined) {\n        reportInvalidLiteral(\n          context.onError,\n          `Expected variable \"$${valueNode.name.value}\" provided to type \"${type}\" to provide a runtime value.`,\n          valueNode,\n          path,\n        );\n      } else if (value === null) {\n        reportInvalidLiteral(\n          context.onError,\n          `Expected variable \"$${valueNode.name.value}\" provided to non-null type \"${type}\" not to be null.`,\n          valueNode,\n          path,\n        );\n      }\n    }\n    // Note: This does no further checking that this variable is correct.\n    // This assumes this variable usage has already been validated.\n    return;\n  }\n\n  if (isNonNullType(type)) {\n    if (valueNode.kind === Kind.NULL) {\n      reportInvalidLiteral(\n        context.onError,\n        `Expected value of non-null type \"${type}\" not to be null.`,\n        valueNode,\n        path,\n      );\n      return;\n    }\n    return validateInputLiteralImpl(\n      context,\n      valueNode,\n      type.ofType,\n      hideSuggestions,\n      path,\n    );\n  }\n\n  if (valueNode.kind === Kind.NULL) {\n    return;\n  }\n\n  if (isListType(type)) {\n    if (valueNode.kind !== Kind.LIST) {\n      // Lists accept a non-list value as a list of one.\n      validateInputLiteralImpl(\n        context,\n        valueNode,\n        type.ofType,\n        hideSuggestions,\n        path,\n      );\n    } else {\n      let index = 0;\n      for (const itemNode of valueNode.values) {\n        validateInputLiteralImpl(\n          context,\n          itemNode,\n          type.ofType,\n          hideSuggestions,\n          addPath(path, index++, undefined),\n        );\n      }\n    }\n  } else if (isInputObjectType(type)) {\n    if (valueNode.kind !== Kind.OBJECT) {\n      reportInvalidLiteral(\n        context.onError,\n        `Expected value of type \"${type}\" to be an object, found: ${print(\n          valueNode,\n        )}.`,\n        valueNode,\n        path,\n      );\n      return;\n    }\n\n    const fieldDefs = type.getFields();\n    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);\n\n    for (const field of Object.values(fieldDefs)) {\n      const fieldNode = fieldNodes[field.name];\n      if (fieldNode === undefined) {\n        if (isRequiredInputField(field)) {\n          reportInvalidLiteral(\n            context.onError,\n            `Expected value of type \"${type}\" to include required field \"${\n              field.name\n            }\", found: ${print(valueNode)}.`,\n            valueNode,\n            path,\n          );\n        }\n      } else {\n        const fieldValueNode = fieldNode.value;\n        if (fieldValueNode.kind === Kind.VARIABLE && !context.static) {\n          const scopedVariableValues = getScopedVariableValues(\n            context,\n            fieldValueNode,\n          );\n          const variableName = fieldValueNode.name.value;\n          const value = scopedVariableValues?.coerced[variableName];\n          if (type.isOneOf) {\n            if (value === undefined) {\n              reportInvalidLiteral(\n                context.onError,\n                `Expected variable \"$${variableName}\" provided to field \"${field.name}\" for OneOf Input Object type \"${type}\" to provide a runtime value.`,\n                valueNode,\n                path,\n              );\n            } else if (value === null) {\n              reportInvalidLiteral(\n                context.onError,\n                `Expected variable \"$${variableName}\" provided to field \"${field.name}\" for OneOf Input Object type \"${type}\" not to be null.`,\n                valueNode,\n                path,\n              );\n            }\n          } else if (value === undefined && !isRequiredInputField(field)) {\n            continue;\n          }\n        }\n\n        validateInputLiteralImpl(\n          context,\n          fieldValueNode,\n          field.type,\n          hideSuggestions,\n          addPath(path, field.name, type.name),\n        );\n      }\n    }\n\n    const fields = valueNode.fields;\n    // Ensure every provided field is defined.\n    for (const fieldNode of fields) {\n      const fieldName = fieldNode.name.value;\n      if (!Object.hasOwn(fieldDefs, fieldName)) {\n        const suggestion = hideSuggestions\n          ? ''\n          : didYouMean(suggestionList(fieldName, Object.keys(fieldDefs)));\n        reportInvalidLiteral(\n          context.onError,\n          `Expected value of type \"${type}\" not to include unknown field \"${fieldName}\"${\n            suggestion ? `.${suggestion} Found` : ', found'\n          }: ${print(valueNode)}.`,\n          fieldNode,\n          path,\n        );\n      }\n    }\n\n    if (type.isOneOf) {\n      const isNotExactlyOneField = fields.length !== 1;\n      if (isNotExactlyOneField) {\n        reportInvalidLiteral(\n          context.onError,\n          `OneOf Input Object \"${type}\" must specify exactly one key.`,\n          valueNode,\n          path,\n        );\n        return;\n      }\n\n      const fieldValueNode = fields[0].value;\n      if (fieldValueNode.kind === Kind.NULL) {\n        const fieldName = fields[0].name.value;\n        reportInvalidLiteral(\n          context.onError,\n          `Field \"${type}.${fieldName}\" used for OneOf Input Object must be non-null.`,\n          valueNode,\n          addPath(path, fieldName, undefined),\n        );\n      }\n    }\n  } else {\n    assertLeafType(type);\n\n    let result;\n    let caughtError;\n    try {\n      result = type.coerceInputLiteral\n        ? type.coerceInputLiteral(\n            replaceVariables(\n              valueNode,\n              context.variables,\n              context.fragmentVariableValues,\n            ),\n            hideSuggestions,\n          )\n        : type.parseLiteral(valueNode, undefined, hideSuggestions);\n    } catch (error) {\n      if (error instanceof GraphQLError) {\n        context.onError(error, pathToArray(path));\n        return;\n      }\n      caughtError = error;\n    }\n\n    if (result === undefined) {\n      reportInvalidLiteral(\n        context.onError,\n        `Expected value of type \"${type}\"${\n          caughtError != null\n            ? `, but encountered error \"${caughtError.message != null && caughtError.message !== '' ? caughtError.message : caughtError}\"; found`\n            : ', found'\n        }: ${print(valueNode)}.`,\n        valueNode,\n        path,\n        caughtError,\n      );\n    }\n  }\n}\n\nfunction getScopedVariableValues(\n  context: ValidationContext,\n  valueNode: VariableNode,\n): Maybe<VariableValues> {\n  const variableName = valueNode.name.value;\n  const { fragmentVariableValues, variables } = context;\n  return fragmentVariableValues?.sources[variableName]\n    ? fragmentVariableValues\n    : variables;\n}\n\nfunction reportInvalidLiteral(\n  onError: (error: GraphQLError, path: ReadonlyArray<string | number>) => void,\n  message: string,\n  valueNode: ASTNode,\n  path: Path | undefined,\n  originalError?: GraphQLError,\n): void {\n  onError(\n    new GraphQLError(message, { nodes: valueNode, originalError }),\n    pathToArray(path),\n  );\n}\n"]}