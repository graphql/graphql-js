{"version":3,"file":"valueToLiteral.js","sourceRoot":"","sources":["../../src/utilities/valueToLiteral.ts"],"names":[],"mappings":"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","sourcesContent":["import { inspect } from '../jsutils/inspect.js';\nimport { isIterableObject } from '../jsutils/isIterableObject.js';\nimport { isObjectLike } from '../jsutils/isObjectLike.js';\n\nimport type { ConstObjectFieldNode, ConstValueNode } from '../language/ast.js';\nimport { Kind } from '../language/kinds.js';\n\nimport type { GraphQLInputType } from '../type/definition.js';\nimport {\n  assertLeafType,\n  isInputObjectType,\n  isListType,\n  isNonNullType,\n  isRequiredInputField,\n} from '../type/definition.js';\n\n/**\n * Produces a GraphQL Value AST given a JavaScript value and a GraphQL type.\n *\n * Scalar types are converted by calling the `valueToLiteral` method on that\n * type, otherwise the default scalar `valueToLiteral` method is used, defined\n * below.\n *\n * The provided value is an non-coerced \"input\" value. This function does not\n * perform any coercion, however it does perform validation. Provided values\n * which are invalid for the given type will result in an `undefined` return\n * value.\n */\nexport function valueToLiteral(\n  value: unknown,\n  type: GraphQLInputType,\n): ConstValueNode | undefined {\n  if (isNonNullType(type)) {\n    if (value == null) {\n      return; // Invalid: intentionally return no value.\n    }\n    return valueToLiteral(value, type.ofType);\n  }\n\n  // Like JSON, a null literal is produced for both null and undefined.\n  if (value == null) {\n    return { kind: Kind.NULL };\n  }\n\n  if (isListType(type)) {\n    if (!isIterableObject(value)) {\n      return valueToLiteral(value, type.ofType);\n    }\n    const values: Array<ConstValueNode> = [];\n    for (const itemValue of value) {\n      const itemNode = valueToLiteral(itemValue, type.ofType);\n      if (!itemNode) {\n        return; // Invalid: intentionally return no value.\n      }\n      values.push(itemNode);\n    }\n    return { kind: Kind.LIST, values };\n  }\n\n  if (isInputObjectType(type)) {\n    if (!isObjectLike(value)) {\n      return; // Invalid: intentionally return no value.\n    }\n    const fields: Array<ConstObjectFieldNode> = [];\n    const fieldDefs = type.getFields();\n    const hasUndefinedField = Object.keys(value).some(\n      (name) => !Object.hasOwn(fieldDefs, name),\n    );\n    if (hasUndefinedField) {\n      return; // Invalid: intentionally return no value.\n    }\n    for (const field of Object.values(type.getFields())) {\n      const fieldValue = value[field.name];\n      if (fieldValue === undefined) {\n        if (isRequiredInputField(field)) {\n          return; // Invalid: intentionally return no value.\n        }\n      } else {\n        const fieldNode = valueToLiteral(value[field.name], field.type);\n        if (!fieldNode) {\n          return; // Invalid: intentionally return no value.\n        }\n        fields.push({\n          kind: Kind.OBJECT_FIELD,\n          name: { kind: Kind.NAME, value: field.name },\n          value: fieldNode,\n        });\n      }\n    }\n    return { kind: Kind.OBJECT, fields };\n  }\n\n  const leafType = assertLeafType(type);\n\n  if (leafType.valueToLiteral) {\n    try {\n      return leafType.valueToLiteral(value);\n    } catch (_error) {\n      return; // Invalid: intentionally ignore error and return no value.\n    }\n  }\n\n  return defaultScalarValueToLiteral(value);\n}\n\n/**\n * The default implementation to convert scalar values to literals.\n *\n * | JavaScript Value  | GraphQL Value        |\n * | ----------------- | -------------------- |\n * | Object            | Input Object         |\n * | Array             | List                 |\n * | Boolean           | Boolean              |\n * | String            | String               |\n * | Number            | Int / Float          |\n * | null / undefined  | Null                 |\n *\n * @internal\n */\nexport function defaultScalarValueToLiteral(value: unknown): ConstValueNode {\n  // Like JSON, a null literal is produced for both null and undefined.\n  if (value == null) {\n    return { kind: Kind.NULL };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n  switch (typeof value) {\n    case 'boolean':\n      return { kind: Kind.BOOLEAN, value };\n    case 'string':\n      return { kind: Kind.STRING, value, block: false };\n    case 'number': {\n      if (!Number.isFinite(value)) {\n        // Like JSON, a null literal is produced for non-finite values.\n        return { kind: Kind.NULL };\n      }\n      const stringValue = String(value);\n      // Will parse as an IntValue.\n      return /^-?(?:0|[1-9][0-9]*)$/.test(stringValue)\n        ? { kind: Kind.INT, value: stringValue }\n        : { kind: Kind.FLOAT, value: stringValue };\n    }\n    case 'object': {\n      if (isIterableObject(value)) {\n        return {\n          kind: Kind.LIST,\n          values: Array.from(value, defaultScalarValueToLiteral),\n        };\n      }\n      const objValue = value as { [prop: string]: unknown };\n      const fields: Array<ConstObjectFieldNode> = [];\n      for (const fieldName of Object.keys(objValue)) {\n        const fieldValue = objValue[fieldName];\n        // Like JSON, undefined fields are not included in the literal result.\n        if (fieldValue !== undefined) {\n          fields.push({\n            kind: Kind.OBJECT_FIELD,\n            name: { kind: Kind.NAME, value: fieldName },\n            value: defaultScalarValueToLiteral(fieldValue),\n          });\n        }\n      }\n      return { kind: Kind.OBJECT, fields };\n    }\n  }\n\n  throw new TypeError(`Cannot convert value to AST: ${inspect(value)}.`);\n}\n"]}