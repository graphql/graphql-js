{"version":3,"file":"buildASTSchema.js","sourceRoot":"","sources":["../../src/utilities/buildASTSchema.ts"],"names":[],"mappings":";;AAgCA,wCAmDC;AAMD,kCAaC;AApGD,qDAA8C;AAG9C,yDAA4D;AAE5D,iDAAkD;AAElD,2DAA2D;AAE3D,uDAAqD;AAWrD;;;;;;;;;GASG;AACH,SAAgB,cAAc,CAC5B,WAAyB,EACzB,OAA4B;IAE5B,IAAI,OAAO,EAAE,WAAW,KAAK,IAAI,IAAI,OAAO,EAAE,cAAc,KAAK,IAAI,EAAE,CAAC;QACtE,IAAA,4BAAc,EAAC,WAAW,CAAC,CAAC;IAC9B,CAAC;IAED,MAAM,iBAAiB,GAAG;QACxB,WAAW,EAAE,SAAS;QACtB,KAAK,EAAE,EAAE;QACT,UAAU,EAAE,EAAE;QACd,UAAU,EAAE,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;QAC/B,iBAAiB,EAAE,EAAE;QACrB,WAAW,EAAE,KAAK;KACnB,CAAC;IACF,MAAM,MAAM,GAAG,IAAA,kCAAgB,EAAC,iBAAiB,EAAE,WAAW,EAAE,OAAO,CAAC,CAAC;IAEzE,IAAI,MAAM,CAAC,OAAO,IAAI,IAAI,EAAE,CAAC;QAC3B,KAAK,MAAM,IAAI,IAAI,MAAM,CAAC,KAAK,EAAE,CAAC;YAChC,QAAQ,IAAI,CAAC,IAAI,EAAE,CAAC;gBAClB,oEAAoE;gBACpE,qEAAqE;gBACrE,yEAAyE;gBACzE,KAAK,OAAO;oBACV,iDAAiD;oBACjD,MAAM,CAAC,KAAK,GAAG,IAAI,CAAC;oBACpB,MAAM;gBACR,KAAK,UAAU;oBACb,iDAAiD;oBACjD,MAAM,CAAC,QAAQ,GAAG,IAAI,CAAC;oBACvB,MAAM;gBACR,KAAK,cAAc;oBACjB,iDAAiD;oBACjD,MAAM,CAAC,YAAY,GAAG,IAAI,CAAC;oBAC3B,MAAM;YACV,CAAC;QACH,CAAC;IACH,CAAC;IAED,MAAM,UAAU,GAAG;QACjB,GAAG,MAAM,CAAC,UAAU;QACpB,kEAAkE;QAClE,GAAG,mCAAmB,CAAC,MAAM,CAAC,CAAC,YAAY,EAAE,EAAE,CAC7C,MAAM,CAAC,UAAU,CAAC,KAAK,CACrB,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,IAAI,KAAK,YAAY,CAAC,IAAI,CACpD,CACF;KACF,CAAC;IAEF,OAAO,IAAI,yBAAa,CAAC,EAAE,GAAG,MAAM,EAAE,UAAU,EAAE,CAAC,CAAC;AACtD,CAAC;AAED;;;GAGG;AACH,SAAgB,WAAW,CACzB,MAAuB,EACvB,OAA2C;IAE3C,MAAM,QAAQ,GAAG,IAAA,iBAAK,EAAC,MAAM,EAAE;QAC7B,UAAU,EAAE,OAAO,EAAE,UAAU;QAC/B,6BAA6B,EAAE,OAAO,EAAE,6BAA6B;KACtE,CAAC,CAAC;IAEH,OAAO,cAAc,CAAC,QAAQ,EAAE;QAC9B,cAAc,EAAE,OAAO,EAAE,cAAc;QACvC,WAAW,EAAE,OAAO,EAAE,WAAW;KAClC,CAAC,CAAC;AACL,CAAC","sourcesContent":["import type { DocumentNode } from '../language/ast.js';\nimport type { ParseOptions } from '../language/parser.js';\nimport { parse } from '../language/parser.js';\nimport type { Source } from '../language/source.js';\n\nimport { specifiedDirectives } from '../type/directives.js';\nimport type { GraphQLSchemaValidationOptions } from '../type/schema.js';\nimport { GraphQLSchema } from '../type/schema.js';\n\nimport { assertValidSDL } from '../validation/validate.js';\n\nimport { extendSchemaImpl } from './extendSchema.js';\n\nexport interface BuildSchemaOptions extends GraphQLSchemaValidationOptions {\n  /**\n   * Set to true to assume the SDL is valid.\n   *\n   * Default: false\n   */\n  assumeValidSDL?: boolean | undefined;\n}\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query,\n * Mutation and Subscription.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n */\nexport function buildASTSchema(\n  documentAST: DocumentNode,\n  options?: BuildSchemaOptions,\n): GraphQLSchema {\n  if (options?.assumeValid !== true && options?.assumeValidSDL !== true) {\n    assertValidSDL(documentAST);\n  }\n\n  const emptySchemaConfig = {\n    description: undefined,\n    types: [],\n    directives: [],\n    extensions: Object.create(null),\n    extensionASTNodes: [],\n    assumeValid: false,\n  };\n  const config = extendSchemaImpl(emptySchemaConfig, documentAST, options);\n\n  if (config.astNode == null) {\n    for (const type of config.types) {\n      switch (type.name) {\n        // Note: While this could make early assertions to get the correctly\n        // typed values below, that would throw immediately while type system\n        // validation with validateSchema() will produce more actionable results.\n        case 'Query':\n          // @ts-expect-error validated in `validateSchema`\n          config.query = type;\n          break;\n        case 'Mutation':\n          // @ts-expect-error validated in `validateSchema`\n          config.mutation = type;\n          break;\n        case 'Subscription':\n          // @ts-expect-error validated in `validateSchema`\n          config.subscription = type;\n          break;\n      }\n    }\n  }\n\n  const directives = [\n    ...config.directives,\n    // If specified directives were not explicitly declared, add them.\n    ...specifiedDirectives.filter((stdDirective) =>\n      config.directives.every(\n        (directive) => directive.name !== stdDirective.name,\n      ),\n    ),\n  ];\n\n  return new GraphQLSchema({ ...config, directives });\n}\n\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\nexport function buildSchema(\n  source: string | Source,\n  options?: BuildSchemaOptions & ParseOptions,\n): GraphQLSchema {\n  const document = parse(source, {\n    noLocation: options?.noLocation,\n    experimentalFragmentArguments: options?.experimentalFragmentArguments,\n  });\n\n  return buildASTSchema(document, {\n    assumeValidSDL: options?.assumeValidSDL,\n    assumeValid: options?.assumeValid,\n  });\n}\n"]}