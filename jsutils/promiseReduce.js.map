{"version":3,"file":"promiseReduce.js","sourceRoot":"","sources":["../../src/jsutils/promiseReduce.ts"],"names":[],"mappings":";;AAUA,sCAYC;AAtBD,iDAA2C;AAG3C;;;;;;GAMG;AACH,SAAgB,aAAa,CAC3B,MAAmB,EACnB,UAAkE,EAClE,YAA+B;IAE/B,IAAI,WAAW,GAAG,YAAY,CAAC;IAC/B,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE,CAAC;QAC3B,WAAW,GAAG,IAAA,wBAAS,EAAC,WAAW,CAAC;YAClC,CAAC,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,UAAU,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;YAC7D,CAAC,CAAC,UAAU,CAAC,WAAW,EAAE,KAAK,CAAC,CAAC;IACrC,CAAC;IACD,OAAO,WAAW,CAAC;AACrB,CAAC","sourcesContent":["import { isPromise } from './isPromise.js';\nimport type { PromiseOrValue } from './PromiseOrValue.js';\n\n/**\n * Similar to Array.prototype.reduce(), however the reducing callback may return\n * a Promise, in which case reduction will continue after each promise resolves.\n *\n * If the callback does not return a Promise, then this function will also not\n * return a Promise.\n */\nexport function promiseReduce<T, U>(\n  values: Iterable<T>,\n  callbackFn: (accumulator: U, currentValue: T) => PromiseOrValue<U>,\n  initialValue: PromiseOrValue<U>,\n): PromiseOrValue<U> {\n  let accumulator = initialValue;\n  for (const value of values) {\n    accumulator = isPromise(accumulator)\n      ? accumulator.then((resolved) => callbackFn(resolved, value))\n      : callbackFn(accumulator, value);\n  }\n  return accumulator;\n}\n"]}