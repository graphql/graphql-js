{"version":3,"file":"ValidationContext.js","sourceRoot":"","sources":["../../src/validation/ValidationContext.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Maybe } from '../jsutils/Maybe.js';\nimport type { ObjMap } from '../jsutils/ObjMap.js';\n\nimport type { GraphQLError } from '../error/GraphQLError.js';\n\nimport type {\n  DocumentNode,\n  FragmentDefinitionNode,\n  FragmentSpreadNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  VariableDefinitionNode,\n  VariableNode,\n} from '../language/ast.js';\nimport { Kind } from '../language/kinds.js';\nimport type { ASTVisitor } from '../language/visitor.js';\nimport { visit } from '../language/visitor.js';\n\nimport type {\n  GraphQLArgument,\n  GraphQLCompositeType,\n  GraphQLEnumValue,\n  GraphQLField,\n  GraphQLInputType,\n  GraphQLOutputType,\n} from '../type/definition.js';\nimport type { GraphQLDirective } from '../type/directives.js';\nimport type { GraphQLSchema } from '../type/schema.js';\n\nimport type { FragmentSignature } from '../utilities/TypeInfo.js';\nimport { TypeInfo, visitWithTypeInfo } from '../utilities/TypeInfo.js';\n\ntype NodeWithSelectionSet = OperationDefinitionNode | FragmentDefinitionNode;\ninterface VariableUsage {\n  readonly node: VariableNode;\n  readonly type: Maybe<GraphQLInputType>;\n  readonly parentType: Maybe<GraphQLInputType>;\n  readonly defaultValue: unknown;\n  readonly fragmentVariableDefinition: Maybe<VariableDefinitionNode>;\n}\n\n/**\n * An instance of this class is passed as the \"this\" context to all validators,\n * allowing access to commonly useful contextual information from within a\n * validation rule.\n */\nexport class ASTValidationContext {\n  private _ast: DocumentNode;\n  private _onError: (error: GraphQLError) => void;\n  private _fragments: ObjMap<FragmentDefinitionNode> | undefined;\n  private _fragmentSpreads: Map<SelectionSetNode, Array<FragmentSpreadNode>>;\n  private _recursivelyReferencedFragments: Map<\n    OperationDefinitionNode,\n    Array<FragmentDefinitionNode>\n  >;\n\n  constructor(ast: DocumentNode, onError: (error: GraphQLError) => void) {\n    this._ast = ast;\n    this._fragments = undefined;\n    this._fragmentSpreads = new Map();\n    this._recursivelyReferencedFragments = new Map();\n    this._onError = onError;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'ASTValidationContext';\n  }\n\n  reportError(error: GraphQLError): void {\n    this._onError(error);\n  }\n\n  getDocument(): DocumentNode {\n    return this._ast;\n  }\n\n  getFragment(name: string): Maybe<FragmentDefinitionNode> {\n    let fragments: ObjMap<FragmentDefinitionNode>;\n    if (this._fragments) {\n      fragments = this._fragments;\n    } else {\n      fragments = Object.create(null);\n      for (const defNode of this.getDocument().definitions) {\n        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {\n          fragments[defNode.name.value] = defNode;\n        }\n      }\n      this._fragments = fragments;\n    }\n    return fragments[name];\n  }\n\n  getFragmentSpreads(\n    node: SelectionSetNode,\n  ): ReadonlyArray<FragmentSpreadNode> {\n    let spreads = this._fragmentSpreads.get(node);\n    if (!spreads) {\n      spreads = [];\n      const setsToVisit: Array<SelectionSetNode> = [node];\n      let set: SelectionSetNode | undefined;\n      while ((set = setsToVisit.pop())) {\n        for (const selection of set.selections) {\n          if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            spreads.push(selection);\n          } else if (selection.selectionSet) {\n            setsToVisit.push(selection.selectionSet);\n          }\n        }\n      }\n      this._fragmentSpreads.set(node, spreads);\n    }\n    return spreads;\n  }\n\n  getRecursivelyReferencedFragments(\n    operation: OperationDefinitionNode,\n  ): ReadonlyArray<FragmentDefinitionNode> {\n    let fragments = this._recursivelyReferencedFragments.get(operation);\n    if (!fragments) {\n      fragments = [];\n      const collectedNames = new Set<string>();\n      const nodesToVisit: Array<SelectionSetNode> = [operation.selectionSet];\n      let node: SelectionSetNode | undefined;\n      while ((node = nodesToVisit.pop())) {\n        for (const spread of this.getFragmentSpreads(node)) {\n          const fragName = spread.name.value;\n          if (!collectedNames.has(fragName)) {\n            collectedNames.add(fragName);\n            const fragment = this.getFragment(fragName);\n            if (fragment) {\n              fragments.push(fragment);\n              nodesToVisit.push(fragment.selectionSet);\n            }\n          }\n        }\n      }\n      this._recursivelyReferencedFragments.set(operation, fragments);\n    }\n    return fragments;\n  }\n}\n\nexport type ASTValidationRule = (context: ASTValidationContext) => ASTVisitor;\n\nexport class SDLValidationContext extends ASTValidationContext {\n  private _schema: Maybe<GraphQLSchema>;\n\n  constructor(\n    ast: DocumentNode,\n    schema: Maybe<GraphQLSchema>,\n    onError: (error: GraphQLError) => void,\n  ) {\n    super(ast, onError);\n    this._schema = schema;\n  }\n\n  get hideSuggestions() {\n    return false;\n  }\n\n  override get [Symbol.toStringTag]() {\n    return 'SDLValidationContext';\n  }\n\n  getSchema(): Maybe<GraphQLSchema> {\n    return this._schema;\n  }\n}\n\nexport type SDLValidationRule = (context: SDLValidationContext) => ASTVisitor;\n\nexport class ValidationContext extends ASTValidationContext {\n  private _schema: GraphQLSchema;\n  private _typeInfo: TypeInfo;\n  private _variableUsages: Map<\n    NodeWithSelectionSet,\n    ReadonlyArray<VariableUsage>\n  >;\n\n  private _recursiveVariableUsages: Map<\n    OperationDefinitionNode,\n    ReadonlyArray<VariableUsage>\n  >;\n  private _hideSuggestions: boolean;\n\n  constructor(\n    schema: GraphQLSchema,\n    ast: DocumentNode,\n    typeInfo: TypeInfo,\n    onError: (error: GraphQLError) => void,\n    hideSuggestions?: Maybe<boolean>,\n  ) {\n    super(ast, onError);\n    this._schema = schema;\n    this._typeInfo = typeInfo;\n    this._variableUsages = new Map();\n    this._recursiveVariableUsages = new Map();\n    this._hideSuggestions = hideSuggestions ?? false;\n  }\n\n  override get [Symbol.toStringTag]() {\n    return 'ValidationContext';\n  }\n\n  get hideSuggestions() {\n    return this._hideSuggestions;\n  }\n\n  getSchema(): GraphQLSchema {\n    return this._schema;\n  }\n\n  getVariableUsages(node: NodeWithSelectionSet): ReadonlyArray<VariableUsage> {\n    let usages = this._variableUsages.get(node);\n    if (!usages) {\n      const newUsages: Array<VariableUsage> = [];\n      const typeInfo = new TypeInfo(\n        this._schema,\n        undefined,\n        this._typeInfo.getFragmentSignatureByName(),\n      );\n      const fragmentDefinition =\n        node.kind === Kind.FRAGMENT_DEFINITION ? node : undefined;\n      visit(\n        node,\n        visitWithTypeInfo(typeInfo, {\n          VariableDefinition: () => false,\n          Variable(variable) {\n            let fragmentVariableDefinition;\n            if (fragmentDefinition) {\n              const fragmentSignature = typeInfo.getFragmentSignatureByName()(\n                fragmentDefinition.name.value,\n              );\n\n              fragmentVariableDefinition =\n                fragmentSignature?.variableDefinitions.get(variable.name.value);\n              newUsages.push({\n                node: variable,\n                type: typeInfo.getInputType(),\n                parentType: typeInfo.getParentInputType(),\n                defaultValue: undefined, // fragment variables have a variable default but no location default, which is what this default value represents\n                fragmentVariableDefinition,\n              });\n            } else {\n              newUsages.push({\n                node: variable,\n                type: typeInfo.getInputType(),\n                parentType: typeInfo.getParentInputType(),\n                defaultValue: typeInfo.getDefaultValue(),\n                fragmentVariableDefinition: undefined,\n              });\n            }\n          },\n        }),\n      );\n      usages = newUsages;\n      this._variableUsages.set(node, usages);\n    }\n    return usages;\n  }\n\n  getRecursiveVariableUsages(\n    operation: OperationDefinitionNode,\n  ): ReadonlyArray<VariableUsage> {\n    let usages = this._recursiveVariableUsages.get(operation);\n    if (!usages) {\n      usages = this.getVariableUsages(operation);\n      for (const frag of this.getRecursivelyReferencedFragments(operation)) {\n        usages = usages.concat(this.getVariableUsages(frag));\n      }\n      this._recursiveVariableUsages.set(operation, usages);\n    }\n    return usages;\n  }\n\n  getType(): Maybe<GraphQLOutputType> {\n    return this._typeInfo.getType();\n  }\n\n  getParentType(): Maybe<GraphQLCompositeType> {\n    return this._typeInfo.getParentType();\n  }\n\n  getInputType(): Maybe<GraphQLInputType> {\n    return this._typeInfo.getInputType();\n  }\n\n  getParentInputType(): Maybe<GraphQLInputType> {\n    return this._typeInfo.getParentInputType();\n  }\n\n  getFieldDef(): Maybe<GraphQLField<unknown, unknown>> {\n    return this._typeInfo.getFieldDef();\n  }\n\n  getDirective(): Maybe<GraphQLDirective> {\n    return this._typeInfo.getDirective();\n  }\n\n  getArgument(): Maybe<GraphQLArgument> {\n    return this._typeInfo.getArgument();\n  }\n\n  getFragmentSignature(): Maybe<FragmentSignature> {\n    return this._typeInfo.getFragmentSignature();\n  }\n\n  getFragmentSignatureByName(): (\n    fragmentName: string,\n  ) => Maybe<FragmentSignature> {\n    return this._typeInfo.getFragmentSignatureByName();\n  }\n\n  getEnumValue(): Maybe<GraphQLEnumValue> {\n    return this._typeInfo.getEnumValue();\n  }\n}\n\nexport type ValidationRule = (context: ValidationContext) => ASTVisitor;\n"]}