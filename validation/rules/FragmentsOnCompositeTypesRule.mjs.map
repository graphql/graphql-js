{"version":3,"file":"FragmentsOnCompositeTypesRule.js","sourceRoot":"","sources":["../../../src/validation/rules/FragmentsOnCompositeTypesRule.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,qCAAoC;AAE3D,OAAO,EAAE,KAAK,EAAE,mCAAkC;AAGlD,OAAO,EAAE,eAAe,EAAE,kCAAiC;AAE3D,OAAO,EAAE,WAAW,EAAE,wCAAuC;AAI7D;;;;;;;;GAQG;AACH,MAAM,UAAU,6BAA6B,CAC3C,OAA0B;IAE1B,OAAO;QACL,cAAc,CAAC,IAAI;YACjB,MAAM,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC;YACzC,IAAI,aAAa,EAAE,CAAC;gBAClB,MAAM,IAAI,GAAG,WAAW,CAAC,OAAO,CAAC,SAAS,EAAE,EAAE,aAAa,CAAC,CAAC;gBAC7D,IAAI,IAAI,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,EAAE,CAAC;oBACnC,MAAM,OAAO,GAAG,KAAK,CAAC,aAAa,CAAC,CAAC;oBACrC,OAAO,CAAC,WAAW,CACjB,IAAI,YAAY,CACd,oDAAoD,OAAO,IAAI,EAC/D,EAAE,KAAK,EAAE,aAAa,EAAE,CACzB,CACF,CAAC;gBACJ,CAAC;YACH,CAAC;QACH,CAAC;QACD,kBAAkB,CAAC,IAAI;YACrB,MAAM,IAAI,GAAG,WAAW,CAAC,OAAO,CAAC,SAAS,EAAE,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;YAClE,IAAI,IAAI,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,EAAE,CAAC;gBACnC,MAAM,OAAO,GAAG,KAAK,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;gBAC1C,OAAO,CAAC,WAAW,CACjB,IAAI,YAAY,CACd,aAAa,IAAI,CAAC,IAAI,CAAC,KAAK,6CAA6C,OAAO,IAAI,EACpF,EAAE,KAAK,EAAE,IAAI,CAAC,aAAa,EAAE,CAC9B,CACF,CAAC;YACJ,CAAC;QACH,CAAC;KACF,CAAC;AACJ,CAAC","sourcesContent":["import { GraphQLError } from '../../error/GraphQLError.js';\n\nimport { print } from '../../language/printer.js';\nimport type { ASTVisitor } from '../../language/visitor.js';\n\nimport { isCompositeType } from '../../type/definition.js';\n\nimport { typeFromAST } from '../../utilities/typeFromAST.js';\n\nimport type { ValidationContext } from '../ValidationContext.js';\n\n/**\n * Fragments on composite type\n *\n * Fragments use a type condition to determine if they apply, since fragments\n * can only be spread into a composite type (object, interface, or union), the\n * type condition must also be a composite type.\n *\n * See https://spec.graphql.org/draft/#sec-Fragments-On-Composite-Types\n */\nexport function FragmentsOnCompositeTypesRule(\n  context: ValidationContext,\n): ASTVisitor {\n  return {\n    InlineFragment(node) {\n      const typeCondition = node.typeCondition;\n      if (typeCondition) {\n        const type = typeFromAST(context.getSchema(), typeCondition);\n        if (type && !isCompositeType(type)) {\n          const typeStr = print(typeCondition);\n          context.reportError(\n            new GraphQLError(\n              `Fragment cannot condition on non composite type \"${typeStr}\".`,\n              { nodes: typeCondition },\n            ),\n          );\n        }\n      }\n    },\n    FragmentDefinition(node) {\n      const type = typeFromAST(context.getSchema(), node.typeCondition);\n      if (type && !isCompositeType(type)) {\n        const typeStr = print(node.typeCondition);\n        context.reportError(\n          new GraphQLError(\n            `Fragment \"${node.name.value}\" cannot condition on non composite type \"${typeStr}\".`,\n            { nodes: node.typeCondition },\n          ),\n        );\n      }\n    },\n  };\n}\n"]}