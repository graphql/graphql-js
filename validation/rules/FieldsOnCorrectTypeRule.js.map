{"version":3,"file":"FieldsOnCorrectTypeRule.js","sourceRoot":"","sources":["../../../src/validation/rules/FieldsOnCorrectTypeRule.ts"],"names":[],"mappings":"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","sourcesContent":["import { didYouMean } from '../../jsutils/didYouMean.js';\nimport { naturalCompare } from '../../jsutils/naturalCompare.js';\nimport { suggestionList } from '../../jsutils/suggestionList.js';\n\nimport { GraphQLError } from '../../error/GraphQLError.js';\n\nimport type { FieldNode } from '../../language/ast.js';\nimport type { ASTVisitor } from '../../language/visitor.js';\n\nimport type {\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLOutputType,\n} from '../../type/definition.js';\nimport {\n  isAbstractType,\n  isInterfaceType,\n  isObjectType,\n} from '../../type/definition.js';\nimport type { GraphQLSchema } from '../../type/schema.js';\n\nimport type { ValidationContext } from '../ValidationContext.js';\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typename.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selections\n */\nexport function FieldsOnCorrectTypeRule(\n  context: ValidationContext,\n): ASTVisitor {\n  return {\n    Field(node: FieldNode) {\n      const type = context.getParentType();\n      if (type) {\n        const fieldDef = context.getFieldDef();\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          const schema = context.getSchema();\n          const fieldName = node.name.value;\n\n          // First determine if there are any suggested types to condition on.\n          let suggestion = didYouMean(\n            'to use an inline fragment on',\n            context.hideSuggestions\n              ? []\n              : getSuggestedTypeNames(schema, type, fieldName),\n          );\n\n          // If there are no suggested types, then perhaps this was a typo?\n          if (suggestion === '') {\n            suggestion = didYouMean(\n              context.hideSuggestions\n                ? []\n                : getSuggestedFieldNames(type, fieldName),\n            );\n          }\n\n          // Report an error, including helpful suggestions.\n          context.reportError(\n            new GraphQLError(\n              `Cannot query field \"${fieldName}\" on type \"${type}\".` +\n                suggestion,\n              { nodes: node },\n            ),\n          );\n        }\n      }\n    },\n  };\n}\n\n/**\n * Go through all of the implementations of type, as well as the interfaces that\n * they implement. If any of those types include the provided field, suggest them,\n * sorted by how often the type is referenced.\n */\nfunction getSuggestedTypeNames(\n  schema: GraphQLSchema,\n  type: GraphQLOutputType,\n  fieldName: string,\n): Array<string> {\n  if (!isAbstractType(type)) {\n    // Must be an Object type, which does not have possible fields.\n    return [];\n  }\n\n  const suggestedTypes = new Set<GraphQLObjectType | GraphQLInterfaceType>();\n  const usageCount = Object.create(null);\n  for (const possibleType of schema.getPossibleTypes(type)) {\n    if (possibleType.getFields()[fieldName] == null) {\n      continue;\n    }\n\n    // This object type defines this field.\n    suggestedTypes.add(possibleType);\n    usageCount[possibleType.name] = 1;\n\n    for (const possibleInterface of possibleType.getInterfaces()) {\n      if (possibleInterface.getFields()[fieldName] == null) {\n        continue;\n      }\n\n      // This interface type defines this field.\n      suggestedTypes.add(possibleInterface);\n      usageCount[possibleInterface.name] =\n        (usageCount[possibleInterface.name] ?? 0) + 1;\n    }\n  }\n\n  return [...suggestedTypes]\n    .sort((typeA, typeB) => {\n      // Suggest both interface and object types based on how common they are.\n      const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];\n      if (usageCountDiff !== 0) {\n        return usageCountDiff;\n      }\n\n      // Suggest super types first followed by subtypes\n      if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {\n        return -1;\n      }\n      if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {\n        return 1;\n      }\n\n      return naturalCompare(typeA.name, typeB.name);\n    })\n    .map((x) => x.name);\n}\n\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\nfunction getSuggestedFieldNames(\n  type: GraphQLOutputType,\n  fieldName: string,\n): Array<string> {\n  if (isObjectType(type) || isInterfaceType(type)) {\n    const possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  }\n  // Otherwise, must be a Union type, which does not define fields.\n  return [];\n}\n"]}