{"version":3,"file":"OverlappingFieldsCanBeMergedRule.js","sourceRoot":"","sources":["../../../src/validation/rules/OverlappingFieldsCanBeMergedRule.ts"],"names":[],"mappings":"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","sourcesContent":["import { inspect } from '../../jsutils/inspect.js';\nimport type { Maybe } from '../../jsutils/Maybe.js';\n\nimport { GraphQLError } from '../../error/GraphQLError.js';\n\nimport type {\n  ArgumentNode,\n  DirectiveNode,\n  FieldNode,\n  FragmentArgumentNode,\n  FragmentDefinitionNode,\n  FragmentSpreadNode,\n  SelectionSetNode,\n  ValueNode,\n} from '../../language/ast.js';\nimport { Kind } from '../../language/kinds.js';\nimport { print } from '../../language/printer.js';\nimport type { ASTVisitor } from '../../language/visitor.js';\n\nimport type {\n  GraphQLField,\n  GraphQLNamedType,\n  GraphQLOutputType,\n} from '../../type/definition.js';\nimport {\n  getNamedType,\n  isInterfaceType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../../type/definition.js';\n\nimport { sortValueNode } from '../../utilities/sortValueNode.js';\nimport { typeFromAST } from '../../utilities/typeFromAST.js';\n\nimport type { ValidationContext } from '../ValidationContext.js';\n\n/* eslint-disable @typescript-eslint/max-params */\n// This file contains a lot of such errors but we plan to refactor it anyway\n// so just disable it for entire file.\n\nfunction reasonMessage(reason: ConflictReasonMessage): string {\n  if (Array.isArray(reason)) {\n    return reason\n      .map(\n        ([responseName, subReason]) =>\n          `subfields \"${responseName}\" conflict because ` +\n          reasonMessage(subReason),\n      )\n      .join(' and ');\n  }\n  return reason;\n}\n\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n *\n * See https://spec.graphql.org/draft/#sec-Field-Selection-Merging\n */\nexport function OverlappingFieldsCanBeMergedRule(\n  context: ValidationContext,\n): ASTVisitor {\n  // A memoization for when fields and a fragment or two fragments are compared\n  // \"between\" each other for conflicts. Comparisons made be made many times,\n  // so memoizing this can dramatically improve the performance of this validator.\n  const comparedFieldsAndFragmentPairs = new OrderedPairSet<\n    NodeAndDefCollection,\n    string\n  >();\n  const comparedFragmentPairs = new PairSet<string>();\n\n  // A cache for the \"field map\" and list of fragment spreads found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n  const cachedFieldsAndFragmentSpreads = new Map();\n\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(\n        context,\n        cachedFieldsAndFragmentSpreads,\n        comparedFieldsAndFragmentPairs,\n        comparedFragmentPairs,\n        context.getParentType(),\n        selectionSet,\n      );\n      for (const [[responseName, reason], fields1, fields2] of conflicts) {\n        const reasonMsg = reasonMessage(reason);\n        context.reportError(\n          new GraphQLError(\n            `Fields \"${responseName}\" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,\n            { nodes: fields1.concat(fields2) },\n          ),\n        );\n      }\n    },\n  };\n}\n\ntype Conflict = [ConflictReason, Array<FieldNode>, Array<FieldNode>];\n// Field name and reason.\ntype ConflictReason = [string, ConflictReasonMessage];\n// Reason is a string, or a nested list of conflicts.\ntype ConflictReasonMessage = string | Array<ConflictReason>;\n// Tuple defining a field node in a context.\ntype NodeAndDef = [\n  Maybe<GraphQLNamedType>,\n  FieldNode,\n  Maybe<GraphQLField<unknown, unknown>>,\n];\n// Map of array of those.\ntype NodeAndDefCollection = Map<string, Array<NodeAndDef>>;\ninterface FragmentSpread {\n  key: string;\n  node: FragmentSpreadNode;\n  varMap: Map<string, ValueNode> | undefined;\n}\ntype FragmentSpreads = ReadonlyArray<FragmentSpread>;\ntype FieldsAndFragmentSpreads = readonly [\n  NodeAndDefCollection,\n  FragmentSpreads,\n];\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(\n  context: ValidationContext,\n  cachedFieldsAndFragmentSpreads: Map<\n    SelectionSetNode,\n    FieldsAndFragmentSpreads\n  >,\n  comparedFieldsAndFragmentPairs: OrderedPairSet<NodeAndDefCollection, string>,\n  comparedFragmentPairs: PairSet<string>,\n  parentType: Maybe<GraphQLNamedType>,\n  selectionSet: SelectionSetNode,\n): Array<Conflict> {\n  const conflicts: Array<Conflict> = [];\n\n  const [fieldMap, fragmentSpreads] = getFieldsAndFragmentSpreads(\n    context,\n    cachedFieldsAndFragmentSpreads,\n    parentType,\n    selectionSet,\n    undefined,\n  );\n\n  // (A) Find find all conflicts \"within\" the fields and f of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n  collectConflictsWithin(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentSpreads,\n    comparedFieldsAndFragmentPairs,\n    comparedFragmentPairs,\n    fieldMap,\n  );\n\n  if (fragmentSpreads.length !== 0) {\n    // (B) Then collect conflicts between these fields and those represented by\n    // each spread found.\n    for (let i = 0; i < fragmentSpreads.length; i++) {\n      collectConflictsBetweenFieldsAndFragment(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentSpreads,\n        comparedFieldsAndFragmentPairs,\n        comparedFragmentPairs,\n        false,\n        fieldMap,\n        fragmentSpreads[i],\n      );\n      // (C) Then compare this fragment with all other fragments found in this\n      // selection set to collect conflicts between fragments spread together.\n      // This compares each item in the list of fragment spreads to every other\n      // item in that same list (except for itself).\n      for (let j = i + 1; j < fragmentSpreads.length; j++) {\n        collectConflictsBetweenFragments(\n          context,\n          conflicts,\n          cachedFieldsAndFragmentSpreads,\n          comparedFieldsAndFragmentPairs,\n          comparedFragmentPairs,\n          false,\n          fragmentSpreads[i],\n          fragmentSpreads[j],\n        );\n      }\n    }\n  }\n  return conflicts;\n}\n\n// Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\nfunction collectConflictsBetweenFieldsAndFragment(\n  context: ValidationContext,\n  conflicts: Array<Conflict>,\n  cachedFieldsAndFragmentSpreads: Map<\n    SelectionSetNode,\n    FieldsAndFragmentSpreads\n  >,\n  comparedFieldsAndFragmentPairs: OrderedPairSet<NodeAndDefCollection, string>,\n  comparedFragmentPairs: PairSet<string>,\n  areMutuallyExclusive: boolean,\n  fieldMap: NodeAndDefCollection,\n  fragmentSpread: FragmentSpread,\n): void {\n  // Memoize so the fields and fragments are not compared for conflicts more\n  // than once.\n  if (\n    comparedFieldsAndFragmentPairs.has(\n      fieldMap,\n      fragmentSpread.key,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n  comparedFieldsAndFragmentPairs.add(\n    fieldMap,\n    fragmentSpread.key,\n    areMutuallyExclusive,\n  );\n\n  const fragment = context.getFragment(fragmentSpread.node.name.value);\n  if (!fragment) {\n    return;\n  }\n\n  const [fieldMap2, referencedFragmentSpreads] =\n    getReferencedFieldsAndFragmentSpreads(\n      context,\n      cachedFieldsAndFragmentSpreads,\n      fragment,\n      fragmentSpread.varMap,\n    );\n\n  // Do not compare a fragment's fieldMap to itself.\n  if (fieldMap === fieldMap2) {\n    return;\n  }\n\n  // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentSpreads,\n    comparedFieldsAndFragmentPairs,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap,\n    undefined,\n    fieldMap2,\n    fragmentSpread.varMap,\n  );\n\n  // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n  for (const referencedFragmentSpread of referencedFragmentSpreads) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentSpreads,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap,\n      referencedFragmentSpread,\n    );\n  }\n}\n\n// Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\nfunction collectConflictsBetweenFragments(\n  context: ValidationContext,\n  conflicts: Array<Conflict>,\n  cachedFieldsAndFragmentSpreads: Map<\n    SelectionSetNode,\n    FieldsAndFragmentSpreads\n  >,\n  comparedFieldsAndFragmentPairs: OrderedPairSet<NodeAndDefCollection, string>,\n  comparedFragmentPairs: PairSet<string>,\n  areMutuallyExclusive: boolean,\n  fragmentSpread1: FragmentSpread,\n  fragmentSpread2: FragmentSpread,\n): void {\n  // No need to compare a fragment to itself.\n  if (fragmentSpread1.key === fragmentSpread2.key) {\n    return;\n  }\n\n  if (fragmentSpread1.node.name.value === fragmentSpread2.node.name.value) {\n    if (\n      !sameArguments(\n        fragmentSpread1.node.arguments,\n        fragmentSpread1.varMap,\n        fragmentSpread2.node.arguments,\n        fragmentSpread2.varMap,\n      )\n    ) {\n      context.reportError(\n        new GraphQLError(\n          `Spreads \"${fragmentSpread1.node.name.value}\" conflict because ${fragmentSpread1.key} and ${fragmentSpread2.key} have different fragment arguments.`,\n          { nodes: [fragmentSpread1.node, fragmentSpread2.node] },\n        ),\n      );\n      return;\n    }\n  }\n\n  // Memoize so two fragments are not compared for conflicts more than once.\n  if (\n    comparedFragmentPairs.has(\n      fragmentSpread1.key,\n      fragmentSpread2.key,\n      areMutuallyExclusive,\n    )\n  ) {\n    return;\n  }\n  comparedFragmentPairs.add(\n    fragmentSpread1.key,\n    fragmentSpread2.key,\n    areMutuallyExclusive,\n  );\n\n  const fragment1 = context.getFragment(fragmentSpread1.node.name.value);\n  const fragment2 = context.getFragment(fragmentSpread2.node.name.value);\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  const [fieldMap1, referencedFragmentSpreads1] =\n    getReferencedFieldsAndFragmentSpreads(\n      context,\n      cachedFieldsAndFragmentSpreads,\n      fragment1,\n      fragmentSpread1.varMap,\n    );\n  const [fieldMap2, referencedFragmentSpreads2] =\n    getReferencedFieldsAndFragmentSpreads(\n      context,\n      cachedFieldsAndFragmentSpreads,\n      fragment2,\n      fragmentSpread2.varMap,\n    );\n\n  // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentSpreads,\n    comparedFieldsAndFragmentPairs,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    fragmentSpread1.varMap,\n    fieldMap2,\n    fragmentSpread2.varMap,\n  );\n\n  // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n  for (const referencedFragmentSpread2 of referencedFragmentSpreads2) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentSpreads,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fragmentSpread1,\n      referencedFragmentSpread2,\n    );\n  }\n\n  // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n  for (const referencedFragmentSpread1 of referencedFragmentSpreads1) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentSpreads,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      referencedFragmentSpread1,\n      fragmentSpread2,\n    );\n  }\n}\n\n// Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\nfunction findConflictsBetweenSubSelectionSets(\n  context: ValidationContext,\n  cachedFieldsAndFragmentSpreads: Map<\n    SelectionSetNode,\n    FieldsAndFragmentSpreads\n  >,\n  comparedFieldsAndFragmentPairs: OrderedPairSet<NodeAndDefCollection, string>,\n  comparedFragmentPairs: PairSet<string>,\n  areMutuallyExclusive: boolean,\n  parentType1: Maybe<GraphQLNamedType>,\n  selectionSet1: SelectionSetNode,\n  varMap1: Map<string, ValueNode> | undefined,\n  parentType2: Maybe<GraphQLNamedType>,\n  selectionSet2: SelectionSetNode,\n  varMap2: Map<string, ValueNode> | undefined,\n): Array<Conflict> {\n  const conflicts: Array<Conflict> = [];\n\n  const [fieldMap1, fragmentSpreads1] = getFieldsAndFragmentSpreads(\n    context,\n    cachedFieldsAndFragmentSpreads,\n    parentType1,\n    selectionSet1,\n    varMap1,\n  );\n  const [fieldMap2, fragmentSpreads2] = getFieldsAndFragmentSpreads(\n    context,\n    cachedFieldsAndFragmentSpreads,\n    parentType2,\n    selectionSet2,\n    varMap2,\n  );\n\n  // (H) First, collect all conflicts between these two collections of field.\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentSpreads,\n    comparedFieldsAndFragmentPairs,\n    comparedFragmentPairs,\n    areMutuallyExclusive,\n    fieldMap1,\n    varMap1,\n    fieldMap2,\n    varMap2,\n  );\n\n  // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n  for (const fragmentSpread2 of fragmentSpreads2) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentSpreads,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap1,\n      fragmentSpread2,\n    );\n  }\n\n  // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n  for (const fragmentSpread1 of fragmentSpreads1) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentSpreads,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      fieldMap2,\n      fragmentSpread1,\n    );\n  }\n\n  // (J) Also collect conflicts between any fragment spreads by the first and\n  // fragment spreads by the second. This compares each item in the first set of\n  // spreads to each item in the second set of spreads.\n  for (const fragmentSpread1 of fragmentSpreads1) {\n    for (const fragmentSpread2 of fragmentSpreads2) {\n      collectConflictsBetweenFragments(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentSpreads,\n        comparedFieldsAndFragmentPairs,\n        comparedFragmentPairs,\n        areMutuallyExclusive,\n        fragmentSpread1,\n        fragmentSpread2,\n      );\n    }\n  }\n  return conflicts;\n}\n\n// Collect all Conflicts \"within\" one collection of fields.\nfunction collectConflictsWithin(\n  context: ValidationContext,\n  conflicts: Array<Conflict>,\n  cachedFieldsAndFragmentSpreads: Map<\n    SelectionSetNode,\n    FieldsAndFragmentSpreads\n  >,\n  comparedFieldsAndFragmentPairs: OrderedPairSet<NodeAndDefCollection, string>,\n  comparedFragmentPairs: PairSet<string>,\n  fieldMap: NodeAndDefCollection,\n): void {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  for (const [responseName, fields] of fieldMap.entries()) {\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentSpreads,\n            comparedFieldsAndFragmentPairs,\n            comparedFragmentPairs,\n            false, // within one collection is never mutually exclusive\n            responseName,\n            fields[i],\n            undefined,\n            fields[j],\n            undefined,\n          );\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n}\n\n// Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\nfunction collectConflictsBetween(\n  context: ValidationContext,\n  conflicts: Array<Conflict>,\n  cachedFieldsAndFragmentSpreads: Map<\n    SelectionSetNode,\n    FieldsAndFragmentSpreads\n  >,\n  comparedFieldsAndFragmentPairs: OrderedPairSet<NodeAndDefCollection, string>,\n  comparedFragmentPairs: PairSet<string>,\n  parentFieldsAreMutuallyExclusive: boolean,\n  fieldMap1: NodeAndDefCollection,\n  varMap1: Map<string, ValueNode> | undefined,\n  fieldMap2: NodeAndDefCollection,\n  varMap2: Map<string, ValueNode> | undefined,\n): void {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  for (const [responseName, fields1] of fieldMap1.entries()) {\n    const fields2 = fieldMap2.get(responseName);\n    if (fields2 != null) {\n      for (const field1 of fields1) {\n        for (const field2 of fields2) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentSpreads,\n            comparedFieldsAndFragmentPairs,\n            comparedFragmentPairs,\n            parentFieldsAreMutuallyExclusive,\n            responseName,\n            field1,\n            varMap1,\n            field2,\n            varMap2,\n          );\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  }\n}\n\n// Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\nfunction findConflict(\n  context: ValidationContext,\n  cachedFieldsAndFragmentSpreads: Map<\n    SelectionSetNode,\n    FieldsAndFragmentSpreads\n  >,\n  comparedFieldsAndFragmentPairs: OrderedPairSet<NodeAndDefCollection, string>,\n  comparedFragmentPairs: PairSet<string>,\n  parentFieldsAreMutuallyExclusive: boolean,\n  responseName: string,\n  field1: NodeAndDef,\n  varMap1: Map<string, ValueNode> | undefined,\n  field2: NodeAndDef,\n  varMap2: Map<string, ValueNode> | undefined,\n): Maybe<Conflict> {\n  const [parentType1, node1, def1] = field1;\n  const [parentType2, node2, def2] = field2;\n\n  // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n  const areMutuallyExclusive =\n    parentFieldsAreMutuallyExclusive ||\n    (parentType1 !== parentType2 &&\n      isObjectType(parentType1) &&\n      isObjectType(parentType2));\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    const name1 = node1.name.value;\n    const name2 = node2.name.value;\n    if (name1 !== name2) {\n      return [\n        [responseName, `\"${name1}\" and \"${name2}\" are different fields`],\n        [node1],\n        [node2],\n      ];\n    }\n\n    // Two field calls must have the same arguments.\n    if (!sameArguments(node1.arguments, varMap1, node2.arguments, varMap2)) {\n      return [\n        [responseName, 'they have differing arguments'],\n        [node1],\n        [node2],\n      ];\n    }\n  }\n\n  const directives1 = node1.directives ?? [];\n  const directives2 = node2.directives ?? [];\n  const overlappingStreamReason = hasNoOverlappingStreams(\n    directives1,\n    varMap1,\n    directives2,\n    varMap2,\n  );\n  if (overlappingStreamReason !== undefined) {\n    return [[responseName, overlappingStreamReason], [node1], [node2]];\n  }\n\n  // The return type for each field.\n  const type1 = def1?.type;\n  const type2 = def2?.type;\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [\n      [\n        responseName,\n        `they return conflicting types \"${inspect(type1)}\" and \"${inspect(\n          type2,\n        )}\"`,\n      ],\n      [node1],\n      [node2],\n    ];\n  }\n\n  // Collect and compare sub-fields. Use the same \"visited fragment spreads\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n  const selectionSet1 = node1.selectionSet;\n  const selectionSet2 = node2.selectionSet;\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(\n      context,\n      cachedFieldsAndFragmentSpreads,\n      comparedFieldsAndFragmentPairs,\n      comparedFragmentPairs,\n      areMutuallyExclusive,\n      getNamedType(type1),\n      selectionSet1,\n      varMap1,\n      getNamedType(type2),\n      selectionSet2,\n      varMap2,\n    );\n    return subfieldConflicts(conflicts, responseName, node1, node2);\n  }\n}\n\nfunction sameArguments<T extends ArgumentNode | FragmentArgumentNode>(\n  args1: ReadonlyArray<T> | undefined,\n  varMap1: Map<string, ValueNode> | undefined,\n  args2: ReadonlyArray<T> | undefined,\n  varMap2: Map<string, ValueNode> | undefined,\n): boolean {\n  if (args1 === undefined || args1.length === 0) {\n    return args2 === undefined || args2.length === 0;\n  }\n  if (args2 === undefined || args2.length === 0) {\n    return false;\n  }\n\n  if (args1.length !== args2.length) {\n    return false;\n  }\n\n  const values2 = new Map(\n    args2.map(({ name, value }) => [\n      name.value,\n      varMap2 === undefined ? value : replaceFragmentVariables(value, varMap2),\n    ]),\n  );\n  return args1.every((arg1) => {\n    let value1 = arg1.value;\n    if (varMap1) {\n      value1 = replaceFragmentVariables(value1, varMap1);\n    }\n    const value2 = values2.get(arg1.name.value);\n    if (value2 === undefined) {\n      return false;\n    }\n\n    return stringifyValue(value1) === stringifyValue(value2);\n  });\n}\n\nfunction replaceFragmentVariables(\n  valueNode: ValueNode,\n  varMap: ReadonlyMap<string, ValueNode>,\n): ValueNode {\n  switch (valueNode.kind) {\n    case Kind.VARIABLE:\n      return varMap.get(valueNode.name.value) ?? valueNode;\n    case Kind.LIST:\n      return {\n        ...valueNode,\n        values: valueNode.values.map((node) =>\n          replaceFragmentVariables(node, varMap),\n        ),\n      };\n    case Kind.OBJECT:\n      return {\n        ...valueNode,\n        fields: valueNode.fields.map((field) => ({\n          ...field,\n          value: replaceFragmentVariables(field.value, varMap),\n        })),\n      };\n    default: {\n      return valueNode;\n    }\n  }\n}\n\nfunction stringifyValue(value: ValueNode): string | null {\n  return print(sortValueNode(value));\n}\n\nfunction getStreamDirective(\n  directives: ReadonlyArray<DirectiveNode>,\n): DirectiveNode | undefined {\n  return directives.find((directive) => directive.name.value === 'stream');\n}\n\nfunction hasNoOverlappingStreams(\n  directives1: ReadonlyArray<DirectiveNode>,\n  varMap1: Map<string, ValueNode> | undefined,\n  directives2: ReadonlyArray<DirectiveNode>,\n  varMap2: Map<string, ValueNode> | undefined,\n): string | undefined {\n  const stream1 = getStreamDirective(directives1);\n  const stream2 = getStreamDirective(directives2);\n  if (!stream1 && !stream2) {\n    // both fields do not have streams\n    return;\n  } else if (stream1 && stream2) {\n    // check if both fields have equivalent streams\n    if (sameArguments(stream1.arguments, varMap1, stream2.arguments, varMap2)) {\n      // This was allowed in previous alpha versions of `graphql-js`.\n      return 'they have overlapping stream directives. See https://github.com/graphql/defer-stream-wg/discussions/100';\n    }\n    return 'they have overlapping stream directives';\n  }\n  // fields have a mix of stream and no stream\n  return 'they have overlapping stream directives';\n}\n\n// Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\nfunction doTypesConflict(\n  type1: GraphQLOutputType,\n  type2: GraphQLOutputType,\n): boolean {\n  if (isListType(type1)) {\n    return isListType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n  if (isListType(type2)) {\n    return true;\n  }\n  if (isNonNullType(type1)) {\n    return isNonNullType(type2)\n      ? doTypesConflict(type1.ofType, type2.ofType)\n      : true;\n  }\n  if (isNonNullType(type2)) {\n    return true;\n  }\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n  return false;\n}\n\n// Given a selection set, return the collection of fields (a mapping of response\n// name to field nodes and definitions) as well as a list of fragment spreads\n// referenced via fragment spreads.\nfunction getFieldsAndFragmentSpreads(\n  context: ValidationContext,\n  cachedFieldsAndFragmentSpreads: Map<\n    SelectionSetNode,\n    FieldsAndFragmentSpreads\n  >,\n  parentType: Maybe<GraphQLNamedType>,\n  selectionSet: SelectionSetNode,\n  varMap: Map<string, ValueNode> | undefined,\n): FieldsAndFragmentSpreads {\n  const cached = cachedFieldsAndFragmentSpreads.get(selectionSet);\n  if (cached) {\n    return cached;\n  }\n  const nodeAndDefs: NodeAndDefCollection = new Map();\n  const fragmentSpreads = new Map<string, FragmentSpread>();\n  _collectFieldsAndFragmentSpreads(\n    context,\n    parentType,\n    selectionSet,\n    nodeAndDefs,\n    fragmentSpreads,\n    varMap,\n  );\n  const result: FieldsAndFragmentSpreads = [\n    nodeAndDefs,\n    Array.from(fragmentSpreads.values()),\n  ];\n  cachedFieldsAndFragmentSpreads.set(selectionSet, result);\n  return result;\n}\n\n// Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment spreads referenced via fragment spreads.\nfunction getReferencedFieldsAndFragmentSpreads(\n  context: ValidationContext,\n  cachedFieldsAndFragmentSpreads: Map<\n    SelectionSetNode,\n    FieldsAndFragmentSpreads\n  >,\n  fragment: FragmentDefinitionNode,\n  varMap: Map<string, ValueNode> | undefined,\n) {\n  // Short-circuit building a type from the node if possible.\n  const cached = cachedFieldsAndFragmentSpreads.get(fragment.selectionSet);\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentSpreads(\n    context,\n    cachedFieldsAndFragmentSpreads,\n    fragmentType,\n    fragment.selectionSet,\n    varMap,\n  );\n}\n\nfunction _collectFieldsAndFragmentSpreads(\n  context: ValidationContext,\n  parentType: Maybe<GraphQLNamedType>,\n  selectionSet: SelectionSetNode,\n  nodeAndDefs: NodeAndDefCollection,\n  fragmentSpreads: Map<string, FragmentSpread>,\n  varMap: Map<string, ValueNode> | undefined,\n): void {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        const fieldName = selection.name.value;\n        let fieldDef;\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n        const responseName = selection.alias\n          ? selection.alias.value\n          : fieldName;\n\n        let nodeAndDefsList = nodeAndDefs.get(responseName);\n        if (nodeAndDefsList == null) {\n          nodeAndDefsList = [];\n          nodeAndDefs.set(responseName, nodeAndDefsList);\n        }\n        nodeAndDefsList.push([parentType, selection, fieldDef]);\n        break;\n      }\n      case Kind.FRAGMENT_SPREAD: {\n        const fragmentSpread = getFragmentSpread(context, selection, varMap);\n        fragmentSpreads.set(fragmentSpread.key, fragmentSpread);\n        break;\n      }\n      case Kind.INLINE_FRAGMENT: {\n        const typeCondition = selection.typeCondition;\n        const inlineFragmentType = typeCondition\n          ? typeFromAST(context.getSchema(), typeCondition)\n          : parentType;\n        _collectFieldsAndFragmentSpreads(\n          context,\n          inlineFragmentType,\n          selection.selectionSet,\n          nodeAndDefs,\n          fragmentSpreads,\n          varMap,\n        );\n        break;\n      }\n    }\n  }\n}\n\nfunction getFragmentSpread(\n  context: ValidationContext,\n  fragmentSpreadNode: FragmentSpreadNode,\n  varMap: Map<string, ValueNode> | undefined,\n): FragmentSpread {\n  let key = '';\n  const newVarMap = new Map<string, ValueNode>();\n  const fragmentSignature = context.getFragmentSignatureByName()(\n    fragmentSpreadNode.name.value,\n  );\n  const argMap = new Map<string, ValueNode>();\n  if (fragmentSpreadNode.arguments) {\n    for (const arg of fragmentSpreadNode.arguments) {\n      argMap.set(arg.name.value, arg.value);\n    }\n  }\n  if (fragmentSignature?.variableDefinitions) {\n    key += fragmentSpreadNode.name.value + '(';\n    for (const [varName, variable] of fragmentSignature.variableDefinitions) {\n      const value = argMap.get(varName);\n      if (value) {\n        key += varName + ': ' + print(sortValueNode(value));\n      }\n      const arg = argMap.get(varName);\n      if (arg !== undefined) {\n        newVarMap.set(\n          varName,\n          varMap !== undefined ? replaceFragmentVariables(arg, varMap) : arg,\n        );\n      } else if (variable.defaultValue) {\n        newVarMap.set(varName, variable.defaultValue);\n      }\n    }\n    key += ')';\n  }\n  return {\n    key,\n    node: fragmentSpreadNode,\n    varMap: newVarMap.size > 0 ? newVarMap : undefined,\n  };\n}\n\n// Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\nfunction subfieldConflicts(\n  conflicts: ReadonlyArray<Conflict>,\n  responseName: string,\n  node1: FieldNode,\n  node2: FieldNode,\n): Maybe<Conflict> {\n  if (conflicts.length > 0) {\n    return [\n      [responseName, conflicts.map(([reason]) => reason)],\n      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],\n      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()],\n    ];\n  }\n}\n\n/**\n * A way to keep track of pairs of things where the ordering of the pair\n * matters.\n *\n * Provides a third argument for has/set to allow flagging the pair as\n * weakly or strongly present within the collection.\n */\nclass OrderedPairSet<T, U> {\n  _data: Map<T, Map<U, boolean>>;\n\n  constructor() {\n    this._data = new Map();\n  }\n\n  has(a: T, b: U, weaklyPresent: boolean): boolean {\n    const result = this._data.get(a)?.get(b);\n    if (result === undefined) {\n      return false;\n    }\n\n    return weaklyPresent ? true : weaklyPresent === result;\n  }\n\n  add(a: T, b: U, weaklyPresent: boolean): void {\n    const map = this._data.get(a);\n    if (map === undefined) {\n      this._data.set(a, new Map([[b, weaklyPresent]]));\n    } else {\n      map.set(b, weaklyPresent);\n    }\n  }\n}\n\n/**\n * A way to keep track of pairs of similar things when the ordering of the pair\n * does not matter.\n */\nclass PairSet<T> {\n  _orderedPairSet: OrderedPairSet<T, T>;\n\n  constructor() {\n    this._orderedPairSet = new OrderedPairSet();\n  }\n\n  has(a: T, b: T, weaklyPresent: boolean): boolean {\n    return a < b\n      ? this._orderedPairSet.has(a, b, weaklyPresent)\n      : this._orderedPairSet.has(b, a, weaklyPresent);\n  }\n\n  add(a: T, b: T, weaklyPresent: boolean): void {\n    if (a < b) {\n      this._orderedPairSet.add(a, b, weaklyPresent);\n    } else {\n      this._orderedPairSet.add(b, a, weaklyPresent);\n    }\n  }\n}\n"]}