{"version":3,"file":"mapAsyncIterable.js","sourceRoot":"","sources":["../../src/execution/mapAsyncIterable.ts"],"names":[],"mappings":";;AAMA,4CA4DC;AAhED;;;GAGG;AACH,SAAgB,gBAAgB,CAC9B,QAAuD,EACvD,QAAyC,EACzC,MAAmB;IAEnB,MAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,aAAa,CAAC,EAAE,CAAC;IAElD,KAAK,UAAU,SAAS,CACtB,OAAsC;QAEtC,IAAI,KAAQ,CAAC;QACb,IAAI,CAAC;YACH,MAAM,MAAM,GAAG,MAAM,OAAO,CAAC;YAC7B,IAAI,MAAM,CAAC,IAAI,EAAE,CAAC;gBAChB,MAAM,EAAE,EAAE,CAAC;gBACX,OAAO,MAAM,CAAC;YAChB,CAAC;YACD,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;QACvB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,MAAM,EAAE,EAAE,CAAC;YACX,MAAM,KAAK,CAAC;QACd,CAAC;QAED,IAAI,CAAC;YACH,OAAO,EAAE,KAAK,EAAE,MAAM,QAAQ,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC;QACvD,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,qBAAqB;YACrB,uBAAuB;YACvB,IAAI,OAAO,QAAQ,CAAC,MAAM,KAAK,UAAU,EAAE,CAAC;gBAC1C,IAAI,CAAC;oBACH,MAAM,QAAQ,CAAC,MAAM,EAAE,CAAC;gBAC1B,CAAC;gBAAC,OAAO,EAAE,EAAE,CAAC;oBACZ,kBAAkB;gBACpB,CAAC;YACH,CAAC;YACD,MAAM,KAAK,CAAC;YACZ,oBAAoB;QACtB,CAAC;IACH,CAAC;IAED,OAAO;QACL,KAAK,CAAC,IAAI;YACR,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC;QACpC,CAAC;QACD,KAAK,CAAC,MAAM;YACV,sEAAsE;YACtE,OAAO,OAAO,QAAQ,CAAC,MAAM,KAAK,UAAU;gBAC1C,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC;gBAC9B,CAAC,CAAC,EAAE,KAAK,EAAE,SAAgB,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;QAC9C,CAAC;QACD,KAAK,CAAC,KAAK,CAAC,KAAe;YACzB,IAAI,OAAO,QAAQ,CAAC,KAAK,KAAK,UAAU,EAAE,CAAC;gBACzC,OAAO,SAAS,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;YAC1C,CAAC;YACD,MAAM,KAAK,CAAC;QACd,CAAC;QACD,CAAC,MAAM,CAAC,aAAa,CAAC;YACpB,OAAO,IAAI,CAAC;QACd,CAAC;KACF,CAAC;AACJ,CAAC","sourcesContent":["import type { PromiseOrValue } from '../jsutils/PromiseOrValue.js';\n\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nexport function mapAsyncIterable<T, U, R = undefined>(\n  iterable: AsyncGenerator<T, R, void> | AsyncIterable<T>,\n  callback: (value: T) => PromiseOrValue<U>,\n  onDone?: () => void,\n): AsyncGenerator<U, R, void> {\n  const iterator = iterable[Symbol.asyncIterator]();\n\n  async function mapResult(\n    promise: Promise<IteratorResult<T, R>>,\n  ): Promise<IteratorResult<U, R>> {\n    let value: T;\n    try {\n      const result = await promise;\n      if (result.done) {\n        onDone?.();\n        return result;\n      }\n      value = result.value;\n    } catch (error) {\n      onDone?.();\n      throw error;\n    }\n\n    try {\n      return { value: await callback(value), done: false };\n    } catch (error) {\n      /* c8 ignore start */\n      // FIXME: add test case\n      if (typeof iterator.return === 'function') {\n        try {\n          await iterator.return();\n        } catch (_e) {\n          /* ignore error */\n        }\n      }\n      throw error;\n      /* c8 ignore stop */\n    }\n  }\n\n  return {\n    async next() {\n      return mapResult(iterator.next());\n    },\n    async return(): Promise<IteratorResult<U, R>> {\n      // If iterator.return() does not exist, then type R must be undefined.\n      return typeof iterator.return === 'function'\n        ? mapResult(iterator.return())\n        : { value: undefined as any, done: true };\n    },\n    async throw(error?: unknown) {\n      if (typeof iterator.throw === 'function') {\n        return mapResult(iterator.throw(error));\n      }\n      throw error;\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n"]}