{"version":3,"file":"IncrementalPublisher.js","sourceRoot":"","sources":["../../src/execution/IncrementalPublisher.ts"],"names":[],"mappings":"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","sourcesContent":["import { invariant } from '../jsutils/invariant.js';\nimport type { ObjMap } from '../jsutils/ObjMap.js';\nimport { pathToArray } from '../jsutils/Path.js';\n\nimport type { GraphQLError } from '../error/GraphQLError.js';\n\nimport type { AbortSignalListener } from './AbortSignalListener.js';\nimport { IncrementalGraph } from './IncrementalGraph.js';\nimport type {\n  CancellableStreamRecord,\n  CompletedExecutionGroup,\n  CompletedResult,\n  DeferredFragmentRecord,\n  DeliveryGroup,\n  ExperimentalIncrementalExecutionResults,\n  IncrementalDataRecord,\n  IncrementalDataRecordResult,\n  IncrementalDeferResult,\n  IncrementalResult,\n  IncrementalStreamResult,\n  InitialIncrementalExecutionResult,\n  PendingResult,\n  StreamItemsResult,\n  SubsequentIncrementalExecutionResult,\n} from './types.js';\nimport {\n  isCancellableStreamRecord,\n  isCompletedExecutionGroup,\n  isFailedExecutionGroup,\n} from './types.js';\n\nexport function buildIncrementalResponse(\n  context: IncrementalPublisherContext,\n  result: ObjMap<unknown>,\n  errors: ReadonlyArray<GraphQLError> | undefined,\n  incrementalDataRecords: ReadonlyArray<IncrementalDataRecord>,\n): ExperimentalIncrementalExecutionResults {\n  const incrementalPublisher = new IncrementalPublisher(context);\n  return incrementalPublisher.buildResponse(\n    result,\n    errors,\n    incrementalDataRecords,\n  );\n}\n\ninterface IncrementalPublisherContext {\n  abortSignalListener: AbortSignalListener | undefined;\n  cancellableStreams: Set<CancellableStreamRecord> | undefined;\n}\n\ninterface SubsequentIncrementalExecutionResultContext {\n  pending: Array<PendingResult>;\n  incremental: Array<IncrementalResult>;\n  completed: Array<CompletedResult>;\n}\n\n/**\n * This class is used to publish incremental results to the client, enabling semi-concurrent\n * execution while preserving result order.\n *\n * @internal\n */\nclass IncrementalPublisher {\n  private _context: IncrementalPublisherContext;\n  private _nextId: number;\n  private _incrementalGraph: IncrementalGraph;\n\n  constructor(context: IncrementalPublisherContext) {\n    this._context = context;\n    this._nextId = 0;\n    this._incrementalGraph = new IncrementalGraph();\n  }\n\n  buildResponse(\n    data: ObjMap<unknown>,\n    errors: ReadonlyArray<GraphQLError> | undefined,\n    incrementalDataRecords: ReadonlyArray<IncrementalDataRecord>,\n  ): ExperimentalIncrementalExecutionResults {\n    const newRootNodes = this._incrementalGraph.getNewRootNodes(\n      incrementalDataRecords,\n    );\n\n    const pending = this._toPendingResults(newRootNodes);\n\n    const initialResult: InitialIncrementalExecutionResult =\n      errors === undefined\n        ? { data, pending, hasNext: true }\n        : { errors, data, pending, hasNext: true };\n\n    return {\n      initialResult,\n      subsequentResults: this._subscribe(),\n    };\n  }\n\n  private _toPendingResults(\n    newRootNodes: ReadonlyArray<DeliveryGroup>,\n  ): Array<PendingResult> {\n    const pendingResults: Array<PendingResult> = [];\n    for (const node of newRootNodes) {\n      const id = String(this._getNextId());\n      node.id = id;\n      const pendingResult: PendingResult = {\n        id,\n        path: pathToArray(node.path),\n      };\n      if (node.label !== undefined) {\n        pendingResult.label = node.label;\n      }\n      pendingResults.push(pendingResult);\n    }\n    return pendingResults;\n  }\n\n  private _getNextId(): string {\n    return String(this._nextId++);\n  }\n\n  private _subscribe(): AsyncGenerator<\n    SubsequentIncrementalExecutionResult,\n    void,\n    void\n  > {\n    let isDone = false;\n\n    const _next = async (): Promise<\n      IteratorResult<SubsequentIncrementalExecutionResult, void>\n    > => {\n      if (isDone) {\n        this._context.abortSignalListener?.disconnect();\n        await this._returnAsyncIteratorsIgnoringErrors();\n        return { value: undefined, done: true };\n      }\n\n      const context: SubsequentIncrementalExecutionResultContext = {\n        pending: [],\n        incremental: [],\n        completed: [],\n      };\n\n      let batch: Iterable<IncrementalDataRecordResult> | undefined =\n        this._incrementalGraph.currentCompletedBatch();\n      do {\n        for (const completedResult of batch) {\n          this._handleCompletedIncrementalData(completedResult, context);\n        }\n\n        const { incremental, completed } = context;\n        if (incremental.length > 0 || completed.length > 0) {\n          const hasNext = this._incrementalGraph.hasNext();\n\n          if (!hasNext) {\n            isDone = true;\n          }\n\n          const subsequentIncrementalExecutionResult: SubsequentIncrementalExecutionResult =\n            { hasNext };\n\n          const pending = context.pending;\n          if (pending.length > 0) {\n            subsequentIncrementalExecutionResult.pending = pending;\n          }\n          if (incremental.length > 0) {\n            subsequentIncrementalExecutionResult.incremental = incremental;\n          }\n          if (completed.length > 0) {\n            subsequentIncrementalExecutionResult.completed = completed;\n          }\n\n          return { value: subsequentIncrementalExecutionResult, done: false };\n        }\n\n        // eslint-disable-next-line no-await-in-loop\n        batch = await this._incrementalGraph.nextCompletedBatch();\n      } while (batch !== undefined);\n\n      // TODO: add test for this case\n      /* c8 ignore next */\n      this._context.abortSignalListener?.disconnect();\n      await this._returnAsyncIteratorsIgnoringErrors();\n      return { value: undefined, done: true };\n    };\n\n    const _return = async (): Promise<\n      IteratorResult<SubsequentIncrementalExecutionResult, void>\n    > => {\n      isDone = true;\n      this._incrementalGraph.abort();\n      await this._returnAsyncIterators();\n      return { value: undefined, done: true };\n    };\n\n    const _throw = async (\n      error?: unknown,\n    ): Promise<IteratorResult<SubsequentIncrementalExecutionResult, void>> => {\n      isDone = true;\n      this._incrementalGraph.abort();\n      await this._returnAsyncIterators();\n      // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n      return Promise.reject(error);\n    };\n\n    return {\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      next: _next,\n      return: _return,\n      throw: _throw,\n    };\n  }\n\n  private _handleCompletedIncrementalData(\n    completedIncrementalData: IncrementalDataRecordResult,\n    context: SubsequentIncrementalExecutionResultContext,\n  ): void {\n    if (isCompletedExecutionGroup(completedIncrementalData)) {\n      this._handleCompletedExecutionGroup(completedIncrementalData, context);\n    } else {\n      this._handleCompletedStreamItems(completedIncrementalData, context);\n    }\n  }\n\n  private _handleCompletedExecutionGroup(\n    completedExecutionGroup: CompletedExecutionGroup,\n    context: SubsequentIncrementalExecutionResultContext,\n  ): void {\n    if (isFailedExecutionGroup(completedExecutionGroup)) {\n      for (const deferredFragmentRecord of completedExecutionGroup\n        .pendingExecutionGroup.deferredFragmentRecords) {\n        const id = deferredFragmentRecord.id;\n        if (\n          !this._incrementalGraph.removeDeferredFragment(deferredFragmentRecord)\n        ) {\n          // This can occur if multiple deferred grouped field sets error for a fragment.\n          continue;\n        }\n        invariant(id !== undefined);\n        context.completed.push({\n          id,\n          errors: completedExecutionGroup.errors,\n        });\n      }\n      return;\n    }\n\n    this._incrementalGraph.addCompletedSuccessfulExecutionGroup(\n      completedExecutionGroup,\n    );\n\n    for (const deferredFragmentRecord of completedExecutionGroup\n      .pendingExecutionGroup.deferredFragmentRecords) {\n      const completion = this._incrementalGraph.completeDeferredFragment(\n        deferredFragmentRecord,\n      );\n      if (completion === undefined) {\n        continue;\n      }\n      const id = deferredFragmentRecord.id;\n      invariant(id !== undefined);\n      const incremental = context.incremental;\n      const { newRootNodes, successfulExecutionGroups } = completion;\n      context.pending.push(...this._toPendingResults(newRootNodes));\n      for (const successfulExecutionGroup of successfulExecutionGroups) {\n        const { bestId, subPath } = this._getBestIdAndSubPath(\n          id,\n          deferredFragmentRecord,\n          successfulExecutionGroup,\n        );\n        const incrementalEntry: IncrementalDeferResult = {\n          ...successfulExecutionGroup.result,\n          id: bestId,\n        };\n        if (subPath !== undefined) {\n          incrementalEntry.subPath = subPath;\n        }\n        incremental.push(incrementalEntry);\n      }\n      context.completed.push({ id });\n    }\n  }\n\n  private _handleCompletedStreamItems(\n    streamItemsResult: StreamItemsResult,\n    context: SubsequentIncrementalExecutionResultContext,\n  ): void {\n    const streamRecord = streamItemsResult.streamRecord;\n    const id = streamRecord.id;\n    invariant(id !== undefined);\n    if (streamItemsResult.errors !== undefined) {\n      context.completed.push({\n        id,\n        errors: streamItemsResult.errors,\n      });\n      this._incrementalGraph.removeStream(streamRecord);\n      if (isCancellableStreamRecord(streamRecord)) {\n        invariant(this._context.cancellableStreams !== undefined);\n        this._context.cancellableStreams.delete(streamRecord);\n        streamRecord.earlyReturn().catch(() => {\n          /* c8 ignore next 1 */\n          // ignore error\n        });\n      }\n    } else if (streamItemsResult.result === undefined) {\n      context.completed.push({ id });\n      this._incrementalGraph.removeStream(streamRecord);\n      if (isCancellableStreamRecord(streamRecord)) {\n        invariant(this._context.cancellableStreams !== undefined);\n        this._context.cancellableStreams.delete(streamRecord);\n      }\n    } else {\n      const incrementalEntry: IncrementalStreamResult = {\n        id,\n        ...streamItemsResult.result,\n      };\n\n      context.incremental.push(incrementalEntry);\n\n      const incrementalDataRecords = streamItemsResult.incrementalDataRecords;\n      if (incrementalDataRecords !== undefined) {\n        const newRootNodes = this._incrementalGraph.getNewRootNodes(\n          incrementalDataRecords,\n        );\n        context.pending.push(...this._toPendingResults(newRootNodes));\n      }\n    }\n  }\n\n  private _getBestIdAndSubPath(\n    initialId: string,\n    initialDeferredFragmentRecord: DeferredFragmentRecord,\n    completedExecutionGroup: CompletedExecutionGroup,\n  ): { bestId: string; subPath: ReadonlyArray<string | number> | undefined } {\n    let maxLength = pathToArray(initialDeferredFragmentRecord.path).length;\n    let bestId = initialId;\n\n    for (const deferredFragmentRecord of completedExecutionGroup\n      .pendingExecutionGroup.deferredFragmentRecords) {\n      if (deferredFragmentRecord === initialDeferredFragmentRecord) {\n        continue;\n      }\n      const id = deferredFragmentRecord.id;\n      // TODO: add test case for when an fragment has not been released, but might be processed for the shortest path.\n      /* c8 ignore next 3 */\n      if (id === undefined) {\n        continue;\n      }\n      const fragmentPath = pathToArray(deferredFragmentRecord.path);\n      const length = fragmentPath.length;\n      if (length > maxLength) {\n        maxLength = length;\n        bestId = id;\n      }\n    }\n    const subPath = completedExecutionGroup.path.slice(maxLength);\n    return {\n      bestId,\n      subPath: subPath.length > 0 ? subPath : undefined,\n    };\n  }\n\n  private async _returnAsyncIterators(): Promise<void> {\n    const cancellableStreams = this._context.cancellableStreams;\n    if (cancellableStreams === undefined) {\n      return;\n    }\n    const promises: Array<Promise<unknown>> = [];\n    for (const streamRecord of cancellableStreams) {\n      if (streamRecord.earlyReturn !== undefined) {\n        promises.push(streamRecord.earlyReturn());\n      }\n    }\n    await Promise.all(promises);\n  }\n\n  private async _returnAsyncIteratorsIgnoringErrors(): Promise<void> {\n    await this._returnAsyncIterators().catch(() => {\n      // Ignore errors\n    });\n  }\n}\n"]}