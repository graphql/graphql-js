{"version":3,"file":"values.js","sourceRoot":"","sources":["../../src/execution/values.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,SAAS,EAAE,iCAAgC;AAGpD,OAAO,EAAE,cAAc,EAAE,sCAAqC;AAE9D,OAAO,EAAE,YAAY,EAAE,kCAAiC;AAUxD,OAAO,EAAE,IAAI,EAAE,8BAA6B;AAG5C,OAAO,EACL,UAAU,EACV,aAAa,EACb,kBAAkB,GACnB,+BAA8B;AAI/B,OAAO,EACL,kBAAkB,EAClB,kBAAkB,EAClB,gBAAgB,GACjB,0CAAyC;AAC1C,OAAO,EACL,oBAAoB,EACpB,kBAAkB,GACnB,4CAA2C;AAI5C,OAAO,EAAE,oBAAoB,EAAE,mCAAkC;AAgBjE;;;;;;;;GAQG;AACH,MAAM,UAAU,iBAAiB,CAC/B,MAAqB,EACrB,WAAkD,EAClD,MAAgD,EAChD,OAA2D;IAE3D,MAAM,MAAM,GAAwB,EAAE,CAAC;IACvC,MAAM,SAAS,GAAG,OAAO,EAAE,SAAS,CAAC;IACrC,IAAI,CAAC;QACH,MAAM,cAAc,GAAG,oBAAoB,CACzC,MAAM,EACN,WAAW,EACX,MAAM,EACN,CAAC,KAAK,EAAE,EAAE;YACR,IAAI,SAAS,IAAI,IAAI,IAAI,MAAM,CAAC,MAAM,IAAI,SAAS,EAAE,CAAC;gBACpD,MAAM,IAAI,YAAY,CACpB,+EAA+E,CAChF,CAAC;YACJ,CAAC;YACD,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACrB,CAAC,EACD,OAAO,EAAE,eAAe,CACzB,CAAC;QAEF,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACxB,OAAO,EAAE,cAAc,EAAE,CAAC;QAC5B,CAAC;IACH,CAAC;IAAC,OAAO,KAAK,EAAE,CAAC;QACf,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACrB,CAAC;IAED,OAAO,EAAE,MAAM,EAAE,CAAC;AACpB,CAAC;AAED,SAAS,oBAAoB,CAC3B,MAAqB,EACrB,WAAkD,EAClD,MAAgD,EAChD,OAAsC,EACtC,eAAgC;IAEhC,MAAM,OAAO,GAAgC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACjE,MAAM,OAAO,GAAoB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACrD,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE,CAAC;QACrC,MAAM,YAAY,GAAG,oBAAoB,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;QAE9D,IAAI,YAAY,YAAY,YAAY,EAAE,CAAC;YACzC,OAAO,CAAC,YAAY,CAAC,CAAC;YACtB,SAAS;QACX,CAAC;QAED,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE,GAAG,YAAY,CAAC;QACtD,IAAI,KAAc,CAAC;QACnB,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE,CAAC;YACpC,OAAO,CAAC,OAAO,CAAC,GAAG,EAAE,SAAS,EAAE,YAAY,EAAE,CAAC;YAC/C,IAAI,UAAU,CAAC,YAAY,EAAE,CAAC;gBAC5B,OAAO,CAAC,OAAO,CAAC,GAAG,kBAAkB,CAAC,UAAU,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;gBACxE,SAAS;YACX,CAAC;iBAAM,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,EAAE,CAAC;gBACnC,0DAA0D;gBAC1D,SAAS;YACX,CAAC;QACH,CAAC;aAAM,CAAC;YACN,KAAK,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC;YACxB,OAAO,CAAC,OAAO,CAAC,GAAG,EAAE,SAAS,EAAE,YAAY,EAAE,KAAK,EAAE,CAAC;QACxD,CAAC;QAED,MAAM,YAAY,GAAG,gBAAgB,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;QACtD,IAAI,YAAY,KAAK,SAAS,EAAE,CAAC;YAC/B,OAAO,CAAC,OAAO,CAAC,GAAG,YAAY,CAAC;QAClC,CAAC;aAAM,CAAC;YACN,kBAAkB,CAChB,KAAK,EACL,OAAO,EACP,CAAC,KAAK,EAAE,IAAI,EAAE,EAAE;gBACd,OAAO,CACL,IAAI,YAAY,CACd,cAAc,OAAO,sBAAsB,cAAc,CAAC,IAAI,CAAC,KAC7D,KAAK,CAAC,OACR,EAAE,EACF,EAAE,KAAK,EAAE,UAAU,EAAE,aAAa,EAAE,KAAK,EAAE,CAC5C,CACF,CAAC;YACJ,CAAC,EACD,eAAe,CAChB,CAAC;QACJ,CAAC;IACH,CAAC;IAED,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,CAAC;AAC9B,CAAC;AAED,MAAM,UAAU,yBAAyB,CACvC,kBAAsC,EACtC,kBAA4D,EAC5D,cAA8B,EAC9B,sBAAsD,EACtD,eAAgC;IAEhC,MAAM,aAAa,GAAG,kBAAkB,CAAC,SAAS,IAAI,EAAE,CAAC;IACzD,MAAM,UAAU,GAAG,IAAI,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;IAC9E,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACpC,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACpC,KAAK,MAAM,CAAC,OAAO,EAAE,YAAY,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,kBAAkB,CAAC,EAAE,CAAC;QACzE,OAAO,CAAC,OAAO,CAAC,GAAG;YACjB,SAAS,EAAE,YAAY;SACxB,CAAC;QACF,MAAM,YAAY,GAAG,UAAU,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;QAC7C,IAAI,YAAY,KAAK,SAAS,EAAE,CAAC;YAC/B,MAAM,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,CAAC;YAChC,MAAM,CAAC,KAAK,GAAG,YAAY,CAAC,KAAK,CAAC;YAClC,MAAM,CAAC,sBAAsB,GAAG,sBAAsB,CAAC;QACzD,CAAC;QAED,cAAc,CACZ,OAAO,EACP,kBAAkB,EAClB,OAAO,EACP,YAAY,EACZ,YAAY,EACZ,cAAc,EACd,sBAAsB,EACtB,eAAe,CAChB,CAAC;IACJ,CAAC;IAED,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,CAAC;AAC9B,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,iBAAiB,CAC/B,GAAsD,EACtD,IAA+B,EAC/B,cAAsC,EACtC,sBAAsD,EACtD,eAAgC;IAEhC,MAAM,aAAa,GAAoC,EAAE,CAAC;IAE1D,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,IAAI,EAAE,CAAC;IAC3C,MAAM,UAAU,GAAG,IAAI,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;IAE9E,KAAK,MAAM,MAAM,IAAI,GAAG,CAAC,IAAI,EAAE,CAAC;QAC9B,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC;QACzB,cAAc,CACZ,aAAa,EACb,IAAI,EACJ,IAAI,EACJ,MAAM,EACN,UAAU,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,CAAC,EAC3B,cAAc,EACd,sBAAsB,EACtB,eAAe,CAChB,CAAC;IACJ,CAAC;IACD,OAAO,aAAa,CAAC;AACvB,CAAC;AAED,yDAAyD;AACzD,SAAS,cAAc,CACrB,aAA8B,EAC9B,IAAoD,EACpD,OAAe,EACf,MAAkD,EAClD,YAA6D,EAC7D,cAAqC,EACrC,sBAAqD,EACrD,eAAgC;IAEhC,MAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC;IAE5B,IAAI,CAAC,YAAY,EAAE,CAAC;QAClB,IAAI,kBAAkB,CAAC,MAAM,CAAC,EAAE,CAAC;YAC/B,0EAA0E;YAC1E,kEAAkE;YAClE,2CAA2C;YAC3C,MAAM,IAAI,YAAY;YACpB,iIAAiI;YACjI,aAAa,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,uBAAuB,OAAO,qBAAqB,EACrG,EAAE,KAAK,EAAE,IAAI,EAAE,CAChB,CAAC;QACJ,CAAC;QACD,MAAM,mBAAmB,GAAG,kBAAkB,CAAC,MAAM,CAAC,CAAC;QACvD,IAAI,mBAAmB,KAAK,SAAS,EAAE,CAAC;YACtC,aAAa,CAAC,OAAO,CAAC,GAAG,mBAAmB,CAAC;QAC/C,CAAC;QACD,OAAO;IACT,CAAC;IAED,MAAM,SAAS,GAAG,YAAY,CAAC,KAAK,CAAC;IAErC,0EAA0E;IAC1E,gCAAgC;IAChC,IAAI,SAAS,CAAC,IAAI,KAAK,IAAI,CAAC,QAAQ,EAAE,CAAC;QACrC,MAAM,YAAY,GAAG,SAAS,CAAC,IAAI,CAAC,KAAK,CAAC;QAC1C,MAAM,oBAAoB,GAAG,sBAAsB,EAAE,OAAO,CAAC,YAAY,CAAC;YACxE,CAAC,CAAC,sBAAsB;YACxB,CAAC,CAAC,cAAc,CAAC;QACnB,IACE,CAAC,oBAAoB,IAAI,IAAI;YAC3B,CAAC,MAAM,CAAC,MAAM,CAAC,oBAAoB,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;YAC7D,CAAC,kBAAkB,CAAC,MAAM,CAAC,EAC3B,CAAC;YACD,MAAM,mBAAmB,GAAG,kBAAkB,CAAC,MAAM,CAAC,CAAC;YACvD,IAAI,mBAAmB,KAAK,SAAS,EAAE,CAAC;gBACtC,aAAa,CAAC,OAAO,CAAC,GAAG,mBAAmB,CAAC;YAC/C,CAAC;YACD,OAAO;QACT,CAAC;IACH,CAAC;IACD,MAAM,YAAY,GAAG,kBAAkB,CACrC,SAAS,EACT,OAAO,EACP,cAAc,EACd,sBAAsB,CACvB,CAAC;IACF,IAAI,YAAY,KAAK,SAAS,EAAE,CAAC;QAC/B,oEAAoE;QACpE,kEAAkE;QAClE,2CAA2C;QAC3C,oBAAoB,CAClB,SAAS,EACT,OAAO,EACP,CAAC,KAAK,EAAE,IAAI,EAAE,EAAE;YACd,iIAAiI;YACjI,KAAK,CAAC,OAAO,GAAG,aAAa,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,sBAAsB,cAAc,CACxG,IAAI,CACL,KAAK,KAAK,CAAC,OAAO,EAAE,CAAC;YACtB,MAAM,KAAK,CAAC;QACd,CAAC,EACD,cAAc,EACd,sBAAsB,EACtB,eAAe,CAChB,CAAC;QACF,oBAAoB;QACpB,CAAU,KAAK,KAAf,SAAS,QAAQ,kBAAkB,EAAE;IACvC,CAAC;IACD,aAAa,CAAC,OAAO,CAAC,GAAG,YAAY,CAAC;AACxC,CAAC;AAED;;;;;;;;;;GAUG;AACH,MAAM,UAAU,kBAAkB,CAChC,YAA8B,EAC9B,IAAwE,EACxE,cAAsC,EACtC,sBAAsD,EACtD,eAAgC;IAEhC,MAAM,aAAa,GAAG,IAAI,CAAC,UAAU,EAAE,IAAI,CACzC,CAAC,SAAS,EAAE,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,KAAK,YAAY,CAAC,IAAI,CAC1D,CAAC;IAEF,IAAI,aAAa,EAAE,CAAC;QAClB,OAAO,iBAAiB,CACtB,YAAY,EACZ,aAAa,EACb,cAAc,EACd,sBAAsB,EACtB,eAAe,CAChB,CAAC;IACJ,CAAC;AACH,CAAC","sourcesContent":["import { invariant } from '../jsutils/invariant.js';\nimport type { Maybe } from '../jsutils/Maybe.js';\nimport type { ObjMap, ReadOnlyObjMap } from '../jsutils/ObjMap.js';\nimport { printPathArray } from '../jsutils/printPathArray.js';\n\nimport { GraphQLError } from '../error/GraphQLError.js';\n\nimport type {\n  ArgumentNode,\n  DirectiveNode,\n  FieldNode,\n  FragmentArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n} from '../language/ast.js';\nimport { Kind } from '../language/kinds.js';\n\nimport type { GraphQLArgument, GraphQLField } from '../type/definition.js';\nimport {\n  isArgument,\n  isNonNullType,\n  isRequiredArgument,\n} from '../type/definition.js';\nimport type { GraphQLDirective } from '../type/directives.js';\nimport type { GraphQLSchema } from '../type/schema.js';\n\nimport {\n  coerceDefaultValue,\n  coerceInputLiteral,\n  coerceInputValue,\n} from '../utilities/coerceInputValue.js';\nimport {\n  validateInputLiteral,\n  validateInputValue,\n} from '../utilities/validateInputValue.js';\n\nimport type { FragmentVariableValues } from './collectFields.js';\nimport type { GraphQLVariableSignature } from './getVariableSignature.js';\nimport { getVariableSignature } from './getVariableSignature.js';\n\nexport interface VariableValues {\n  readonly sources: ReadOnlyObjMap<VariableValueSource>;\n  readonly coerced: ReadOnlyObjMap<unknown>;\n}\n\ninterface VariableValueSource {\n  readonly signature: GraphQLVariableSignature;\n  readonly value?: unknown;\n}\n\ntype VariableValuesOrErrors =\n  | { variableValues: VariableValues; errors?: never }\n  | { errors: ReadonlyArray<GraphQLError>; variableValues?: never };\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getVariableValues(\n  schema: GraphQLSchema,\n  varDefNodes: ReadonlyArray<VariableDefinitionNode>,\n  inputs: { readonly [variable: string]: unknown },\n  options?: { maxErrors?: number; hideSuggestions?: boolean },\n): VariableValuesOrErrors {\n  const errors: Array<GraphQLError> = [];\n  const maxErrors = options?.maxErrors;\n  try {\n    const variableValues = coerceVariableValues(\n      schema,\n      varDefNodes,\n      inputs,\n      (error) => {\n        if (maxErrors != null && errors.length >= maxErrors) {\n          throw new GraphQLError(\n            'Too many errors processing variables, error limit reached. Execution aborted.',\n          );\n        }\n        errors.push(error);\n      },\n      options?.hideSuggestions,\n    );\n\n    if (errors.length === 0) {\n      return { variableValues };\n    }\n  } catch (error) {\n    errors.push(error);\n  }\n\n  return { errors };\n}\n\nfunction coerceVariableValues(\n  schema: GraphQLSchema,\n  varDefNodes: ReadonlyArray<VariableDefinitionNode>,\n  inputs: { readonly [variable: string]: unknown },\n  onError: (error: GraphQLError) => void,\n  hideSuggestions?: Maybe<boolean>,\n): VariableValues {\n  const sources: ObjMap<VariableValueSource> = Object.create(null);\n  const coerced: ObjMap<unknown> = Object.create(null);\n  for (const varDefNode of varDefNodes) {\n    const varSignature = getVariableSignature(schema, varDefNode);\n\n    if (varSignature instanceof GraphQLError) {\n      onError(varSignature);\n      continue;\n    }\n\n    const { name: varName, type: varType } = varSignature;\n    let value: unknown;\n    if (!Object.hasOwn(inputs, varName)) {\n      sources[varName] = { signature: varSignature };\n      if (varDefNode.defaultValue) {\n        coerced[varName] = coerceInputLiteral(varDefNode.defaultValue, varType);\n        continue;\n      } else if (!isNonNullType(varType)) {\n        // Non-provided values for nullable variables are omitted.\n        continue;\n      }\n    } else {\n      value = inputs[varName];\n      sources[varName] = { signature: varSignature, value };\n    }\n\n    const coercedValue = coerceInputValue(value, varType);\n    if (coercedValue !== undefined) {\n      coerced[varName] = coercedValue;\n    } else {\n      validateInputValue(\n        value,\n        varType,\n        (error, path) => {\n          onError(\n            new GraphQLError(\n              `Variable \"$${varName}\" has invalid value${printPathArray(path)}: ${\n                error.message\n              }`,\n              { nodes: varDefNode, originalError: error },\n            ),\n          );\n        },\n        hideSuggestions,\n      );\n    }\n  }\n\n  return { sources, coerced };\n}\n\nexport function getFragmentVariableValues(\n  fragmentSpreadNode: FragmentSpreadNode,\n  fragmentSignatures: ReadOnlyObjMap<GraphQLVariableSignature>,\n  variableValues: VariableValues,\n  fragmentVariableValues?: Maybe<FragmentVariableValues>,\n  hideSuggestions?: Maybe<boolean>,\n): FragmentVariableValues {\n  const argumentNodes = fragmentSpreadNode.arguments ?? [];\n  const argNodeMap = new Map(argumentNodes.map((arg) => [arg.name.value, arg]));\n  const sources = Object.create(null);\n  const coerced = Object.create(null);\n  for (const [varName, varSignature] of Object.entries(fragmentSignatures)) {\n    sources[varName] = {\n      signature: varSignature,\n    };\n    const argumentNode = argNodeMap.get(varName);\n    if (argumentNode !== undefined) {\n      const source = sources[varName];\n      source.value = argumentNode.value;\n      source.fragmentVariableValues = fragmentVariableValues;\n    }\n\n    coerceArgument(\n      coerced,\n      fragmentSpreadNode,\n      varName,\n      varSignature,\n      argumentNode,\n      variableValues,\n      fragmentVariableValues,\n      hideSuggestions,\n    );\n  }\n\n  return { sources, coerced };\n}\n\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getArgumentValues(\n  def: GraphQLField<unknown, unknown> | GraphQLDirective,\n  node: FieldNode | DirectiveNode,\n  variableValues?: Maybe<VariableValues>,\n  fragmentVariableValues?: Maybe<FragmentVariableValues>,\n  hideSuggestions?: Maybe<boolean>,\n): { [argument: string]: unknown } {\n  const coercedValues: { [argument: string]: unknown } = {};\n\n  const argumentNodes = node.arguments ?? [];\n  const argNodeMap = new Map(argumentNodes.map((arg) => [arg.name.value, arg]));\n\n  for (const argDef of def.args) {\n    const name = argDef.name;\n    coerceArgument(\n      coercedValues,\n      node,\n      name,\n      argDef,\n      argNodeMap.get(argDef.name),\n      variableValues,\n      fragmentVariableValues,\n      hideSuggestions,\n    );\n  }\n  return coercedValues;\n}\n\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction coerceArgument(\n  coercedValues: ObjMap<unknown>,\n  node: FieldNode | DirectiveNode | FragmentSpreadNode,\n  argName: string,\n  argDef: GraphQLArgument | GraphQLVariableSignature,\n  argumentNode: ArgumentNode | FragmentArgumentNode | undefined,\n  variableValues: Maybe<VariableValues>,\n  fragmentVariableValues: Maybe<FragmentVariableValues>,\n  hideSuggestions?: Maybe<boolean>,\n): void {\n  const argType = argDef.type;\n\n  if (!argumentNode) {\n    if (isRequiredArgument(argDef)) {\n      // Note: ProvidedRequiredArgumentsRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new GraphQLError(\n        // TODO: clean up the naming of isRequiredArgument(), isArgument(), and argDef if/when experimental fragment variables are merged\n        `Argument \"${isArgument(argDef) ? argDef : argName}\" of required type \"${argType}\" was not provided.`,\n        { nodes: node },\n      );\n    }\n    const coercedDefaultValue = coerceDefaultValue(argDef);\n    if (coercedDefaultValue !== undefined) {\n      coercedValues[argName] = coercedDefaultValue;\n    }\n    return;\n  }\n\n  const valueNode = argumentNode.value;\n\n  // Variables without a value are treated as if no argument was provided if\n  // the argument is not required.\n  if (valueNode.kind === Kind.VARIABLE) {\n    const variableName = valueNode.name.value;\n    const scopedVariableValues = fragmentVariableValues?.sources[variableName]\n      ? fragmentVariableValues\n      : variableValues;\n    if (\n      (scopedVariableValues == null ||\n        !Object.hasOwn(scopedVariableValues.coerced, variableName)) &&\n      !isRequiredArgument(argDef)\n    ) {\n      const coercedDefaultValue = coerceDefaultValue(argDef);\n      if (coercedDefaultValue !== undefined) {\n        coercedValues[argName] = coercedDefaultValue;\n      }\n      return;\n    }\n  }\n  const coercedValue = coerceInputLiteral(\n    valueNode,\n    argType,\n    variableValues,\n    fragmentVariableValues,\n  );\n  if (coercedValue === undefined) {\n    // Note: ValuesOfCorrectTypeRule validation should catch this before\n    // execution. This is a runtime check to ensure execution does not\n    // continue with an invalid argument value.\n    validateInputLiteral(\n      valueNode,\n      argType,\n      (error, path) => {\n        // TODO: clean up the naming of isRequiredArgument(), isArgument(), and argDef if/when experimental fragment variables are merged\n        error.message = `Argument \"${isArgument(argDef) ? argDef : argDef.name}\" has invalid value${printPathArray(\n          path,\n        )}: ${error.message}`;\n        throw error;\n      },\n      variableValues,\n      fragmentVariableValues,\n      hideSuggestions,\n    );\n    /* c8 ignore next */\n    invariant(false, 'Invalid argument');\n  }\n  coercedValues[argName] = coercedValue;\n}\n\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getDirectiveValues(\n  directiveDef: GraphQLDirective,\n  node: { readonly directives?: ReadonlyArray<DirectiveNode> | undefined },\n  variableValues?: Maybe<VariableValues>,\n  fragmentVariableValues?: Maybe<FragmentVariableValues>,\n  hideSuggestions?: Maybe<boolean>,\n): undefined | { [argument: string]: unknown } {\n  const directiveNode = node.directives?.find(\n    (directive) => directive.name.value === directiveDef.name,\n  );\n\n  if (directiveNode) {\n    return getArgumentValues(\n      directiveDef,\n      directiveNode,\n      variableValues,\n      fragmentVariableValues,\n      hideSuggestions,\n    );\n  }\n}\n"]}