{"version":3,"file":"collectFields.js","sourceRoot":"","sources":["../../src/execution/collectFields.ts"],"names":[],"mappings":"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","sourcesContent":["import { AccumulatorMap } from '../jsutils/AccumulatorMap.js';\nimport type { ObjMap, ReadOnlyObjMap } from '../jsutils/ObjMap.js';\n\nimport type {\n  ConstValueNode,\n  DirectiveNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n  SelectionSetNode,\n} from '../language/ast.js';\nimport { Kind } from '../language/kinds.js';\n\nimport type { GraphQLObjectType } from '../type/definition.js';\nimport { isAbstractType } from '../type/definition.js';\nimport {\n  GraphQLDeferDirective,\n  GraphQLIncludeDirective,\n  GraphQLSkipDirective,\n} from '../type/directives.js';\nimport type { GraphQLSchema } from '../type/schema.js';\n\nimport { typeFromAST } from '../utilities/typeFromAST.js';\n\nimport type { GraphQLVariableSignature } from './getVariableSignature.js';\nimport type { VariableValues } from './values.js';\nimport {\n  getArgumentValues,\n  getDirectiveValues,\n  getFragmentVariableValues,\n} from './values.js';\n\nexport interface DeferUsage {\n  label: string | undefined;\n  parentDeferUsage: DeferUsage | undefined;\n}\n\nexport interface FragmentVariableValues {\n  readonly sources: ReadOnlyObjMap<FragmentVariableValueSource>;\n  readonly coerced: ReadOnlyObjMap<unknown>;\n}\n\ninterface FragmentVariableValueSource {\n  readonly signature: GraphQLVariableSignature;\n  readonly value?: ConstValueNode;\n  readonly fragmentVariableValues?: FragmentVariableValues;\n}\n\nexport interface FieldDetails {\n  node: FieldNode;\n  deferUsage?: DeferUsage | undefined;\n  fragmentVariableValues?: FragmentVariableValues | undefined;\n}\n\nexport type FieldDetailsList = ReadonlyArray<FieldDetails>;\n\nexport type GroupedFieldSet = ReadonlyMap<string, FieldDetailsList>;\n\nexport interface FragmentDetails {\n  definition: FragmentDefinitionNode;\n  variableSignatures?: ObjMap<GraphQLVariableSignature> | undefined;\n}\n\ninterface CollectFieldsContext {\n  schema: GraphQLSchema;\n  fragments: ObjMap<FragmentDetails>;\n  variableValues: VariableValues;\n  runtimeType: GraphQLObjectType;\n  visitedFragmentNames: Set<string>;\n  hideSuggestions: boolean;\n  forbiddenDirectiveInstances: Array<DirectiveNode>;\n  forbidSkipAndInclude: boolean;\n}\n\n/**\n * Given a selectionSet, collects all of the fields and returns them.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field that\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/max-params\nexport function collectFields(\n  schema: GraphQLSchema,\n  fragments: ObjMap<FragmentDetails>,\n  variableValues: VariableValues,\n  runtimeType: GraphQLObjectType,\n  selectionSet: SelectionSetNode,\n  hideSuggestions: boolean,\n  forbidSkipAndInclude = false,\n): {\n  groupedFieldSet: GroupedFieldSet;\n  newDeferUsages: ReadonlyArray<DeferUsage>;\n  forbiddenDirectiveInstances: ReadonlyArray<DirectiveNode>;\n} {\n  const groupedFieldSet = new AccumulatorMap<string, FieldDetails>();\n  const newDeferUsages: Array<DeferUsage> = [];\n  const context: CollectFieldsContext = {\n    schema,\n    fragments,\n    variableValues,\n    runtimeType,\n    visitedFragmentNames: new Set(),\n    hideSuggestions,\n    forbiddenDirectiveInstances: [],\n    forbidSkipAndInclude,\n  };\n\n  collectFieldsImpl(context, selectionSet, groupedFieldSet, newDeferUsages);\n  return {\n    groupedFieldSet,\n    newDeferUsages,\n    forbiddenDirectiveInstances: context.forbiddenDirectiveInstances,\n  };\n}\n\n/**\n * Given an array of field nodes, collects all of the subfields of the passed\n * in fields, and returns them at the end.\n *\n * CollectSubFields requires the \"return type\" of an object. For a field that\n * returns an Interface or Union type, the \"return type\" will be the actual\n * object type returned by that field.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/max-params\nexport function collectSubfields(\n  schema: GraphQLSchema,\n  fragments: ObjMap<FragmentDetails>,\n  variableValues: VariableValues,\n  returnType: GraphQLObjectType,\n  fieldDetailsList: FieldDetailsList,\n  hideSuggestions: boolean,\n): {\n  groupedFieldSet: GroupedFieldSet;\n  newDeferUsages: ReadonlyArray<DeferUsage>;\n} {\n  const context: CollectFieldsContext = {\n    schema,\n    fragments,\n    variableValues,\n    runtimeType: returnType,\n    visitedFragmentNames: new Set(),\n    hideSuggestions,\n    forbiddenDirectiveInstances: [],\n    forbidSkipAndInclude: false,\n  };\n  const subGroupedFieldSet = new AccumulatorMap<string, FieldDetails>();\n  const newDeferUsages: Array<DeferUsage> = [];\n\n  for (const fieldDetail of fieldDetailsList) {\n    const selectionSet = fieldDetail.node.selectionSet;\n    if (selectionSet) {\n      const { deferUsage, fragmentVariableValues } = fieldDetail;\n      collectFieldsImpl(\n        context,\n        selectionSet,\n        subGroupedFieldSet,\n        newDeferUsages,\n        deferUsage,\n        fragmentVariableValues,\n      );\n    }\n  }\n\n  return {\n    groupedFieldSet: subGroupedFieldSet,\n    newDeferUsages,\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/max-params\nfunction collectFieldsImpl(\n  context: CollectFieldsContext,\n  selectionSet: SelectionSetNode,\n  groupedFieldSet: AccumulatorMap<string, FieldDetails>,\n  newDeferUsages: Array<DeferUsage>,\n  deferUsage?: DeferUsage,\n  fragmentVariableValues?: FragmentVariableValues,\n): void {\n  const {\n    schema,\n    fragments,\n    variableValues,\n    runtimeType,\n    visitedFragmentNames,\n    hideSuggestions,\n  } = context;\n\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        if (\n          !shouldIncludeNode(\n            context,\n            selection,\n            variableValues,\n            fragmentVariableValues,\n          )\n        ) {\n          continue;\n        }\n        groupedFieldSet.add(getFieldEntryKey(selection), {\n          node: selection,\n          deferUsage,\n          fragmentVariableValues,\n        });\n        break;\n      }\n      case Kind.INLINE_FRAGMENT: {\n        if (\n          !shouldIncludeNode(\n            context,\n            selection,\n            variableValues,\n            fragmentVariableValues,\n          ) ||\n          !doesFragmentConditionMatch(schema, selection, runtimeType)\n        ) {\n          continue;\n        }\n\n        const newDeferUsage = getDeferUsage(\n          variableValues,\n          fragmentVariableValues,\n          selection,\n          deferUsage,\n        );\n\n        if (!newDeferUsage) {\n          collectFieldsImpl(\n            context,\n            selection.selectionSet,\n            groupedFieldSet,\n            newDeferUsages,\n            deferUsage,\n            fragmentVariableValues,\n          );\n        } else {\n          newDeferUsages.push(newDeferUsage);\n          collectFieldsImpl(\n            context,\n            selection.selectionSet,\n            groupedFieldSet,\n            newDeferUsages,\n            newDeferUsage,\n            fragmentVariableValues,\n          );\n        }\n\n        break;\n      }\n      case Kind.FRAGMENT_SPREAD: {\n        const fragName = selection.name.value;\n\n        if (\n          visitedFragmentNames.has(fragName) ||\n          !shouldIncludeNode(\n            context,\n            selection,\n            variableValues,\n            fragmentVariableValues,\n          )\n        ) {\n          continue;\n        }\n\n        const fragment = fragments[fragName];\n        if (\n          fragment == null ||\n          !doesFragmentConditionMatch(schema, fragment.definition, runtimeType)\n        ) {\n          continue;\n        }\n\n        const newDeferUsage = getDeferUsage(\n          variableValues,\n          fragmentVariableValues,\n          selection,\n          deferUsage,\n        );\n\n        const fragmentVariableSignatures = fragment.variableSignatures;\n        let newFragmentVariableValues: FragmentVariableValues | undefined;\n        if (fragmentVariableSignatures) {\n          newFragmentVariableValues = getFragmentVariableValues(\n            selection,\n            fragmentVariableSignatures,\n            variableValues,\n            fragmentVariableValues,\n            hideSuggestions,\n          );\n        }\n\n        if (!newDeferUsage) {\n          visitedFragmentNames.add(fragName);\n          collectFieldsImpl(\n            context,\n            fragment.definition.selectionSet,\n            groupedFieldSet,\n            newDeferUsages,\n            deferUsage,\n            newFragmentVariableValues,\n          );\n        } else {\n          newDeferUsages.push(newDeferUsage);\n          collectFieldsImpl(\n            context,\n            fragment.definition.selectionSet,\n            groupedFieldSet,\n            newDeferUsages,\n            newDeferUsage,\n            newFragmentVariableValues,\n          );\n        }\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Returns an object containing the `@defer` arguments if a field should be\n * deferred based on the experimental flag, defer directive present and\n * not disabled by the \"if\" argument.\n */\nfunction getDeferUsage(\n  variableValues: VariableValues,\n  fragmentVariableValues: FragmentVariableValues | undefined,\n  node: FragmentSpreadNode | InlineFragmentNode,\n  parentDeferUsage: DeferUsage | undefined,\n): DeferUsage | undefined {\n  const defer = getDirectiveValues(\n    GraphQLDeferDirective,\n    node,\n    variableValues,\n    fragmentVariableValues,\n  );\n\n  if (!defer) {\n    return;\n  }\n\n  if (defer.if === false) {\n    return;\n  }\n\n  return {\n    label: typeof defer.label === 'string' ? defer.label : undefined,\n    parentDeferUsage,\n  };\n}\n\n/**\n * Determines if a field should be included based on the `@include` and `@skip`\n * directives, where `@skip` has higher precedence than `@include`.\n */\nfunction shouldIncludeNode(\n  context: CollectFieldsContext,\n  node: FragmentSpreadNode | FieldNode | InlineFragmentNode,\n  variableValues: VariableValues,\n  fragmentVariableValues: FragmentVariableValues | undefined,\n): boolean {\n  const skipDirectiveNode = node.directives?.find(\n    (directive) => directive.name.value === GraphQLSkipDirective.name,\n  );\n  if (skipDirectiveNode && context.forbidSkipAndInclude) {\n    context.forbiddenDirectiveInstances.push(skipDirectiveNode);\n    return false;\n  }\n  const skip = skipDirectiveNode\n    ? getArgumentValues(\n        GraphQLSkipDirective,\n        skipDirectiveNode,\n        variableValues,\n        fragmentVariableValues,\n        context.hideSuggestions,\n      )\n    : undefined;\n  if (skip?.if === true) {\n    return false;\n  }\n\n  const includeDirectiveNode = node.directives?.find(\n    (directive) => directive.name.value === GraphQLIncludeDirective.name,\n  );\n  if (includeDirectiveNode && context.forbidSkipAndInclude) {\n    context.forbiddenDirectiveInstances.push(includeDirectiveNode);\n    return false;\n  }\n  const include = includeDirectiveNode\n    ? getArgumentValues(\n        GraphQLIncludeDirective,\n        includeDirectiveNode,\n        variableValues,\n        fragmentVariableValues,\n        context.hideSuggestions,\n      )\n    : undefined;\n  if (include?.if === false) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Determines if a fragment is applicable to the given type.\n */\nfunction doesFragmentConditionMatch(\n  schema: GraphQLSchema,\n  fragment: FragmentDefinitionNode | InlineFragmentNode,\n  type: GraphQLObjectType,\n): boolean {\n  const typeConditionNode = fragment.typeCondition;\n  if (!typeConditionNode) {\n    return true;\n  }\n  const conditionalType = typeFromAST(schema, typeConditionNode);\n  if (conditionalType === type) {\n    return true;\n  }\n  if (isAbstractType(conditionalType)) {\n    return schema.isSubType(conditionalType, type);\n  }\n  return false;\n}\n\n/**\n * Implements the logic to compute the key of a given field's entry\n */\nfunction getFieldEntryKey(node: FieldNode): string {\n  return node.alias ? node.alias.value : node.name.value;\n}\n"]}