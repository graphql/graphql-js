{"version":3,"file":"execute.js","sourceRoot":"","sources":["../../src/execution/execute.ts"],"names":[],"mappings":"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","sourcesContent":["import { BoxedPromiseOrValue } from '../jsutils/BoxedPromiseOrValue.js';\nimport { inspect } from '../jsutils/inspect.js';\nimport { invariant } from '../jsutils/invariant.js';\nimport { isAsyncIterable } from '../jsutils/isAsyncIterable.js';\nimport { isIterableObject } from '../jsutils/isIterableObject.js';\nimport { isObjectLike } from '../jsutils/isObjectLike.js';\nimport { isPromise } from '../jsutils/isPromise.js';\nimport type { Maybe } from '../jsutils/Maybe.js';\nimport { memoize3 } from '../jsutils/memoize3.js';\nimport type { ObjMap } from '../jsutils/ObjMap.js';\nimport type { Path } from '../jsutils/Path.js';\nimport { addPath, pathToArray } from '../jsutils/Path.js';\nimport { promiseForObject } from '../jsutils/promiseForObject.js';\nimport type { PromiseOrValue } from '../jsutils/PromiseOrValue.js';\nimport { promiseReduce } from '../jsutils/promiseReduce.js';\n\nimport { GraphQLError } from '../error/GraphQLError.js';\nimport { locatedError } from '../error/locatedError.js';\n\nimport type {\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  OperationDefinitionNode,\n} from '../language/ast.js';\nimport { OperationTypeNode } from '../language/ast.js';\nimport { Kind } from '../language/kinds.js';\n\nimport type {\n  GraphQLAbstractType,\n  GraphQLField,\n  GraphQLFieldResolver,\n  GraphQLLeafType,\n  GraphQLList,\n  GraphQLObjectType,\n  GraphQLOutputType,\n  GraphQLResolveInfo,\n  GraphQLTypeResolver,\n} from '../type/definition.js';\nimport {\n  isAbstractType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n  isObjectType,\n} from '../type/definition.js';\nimport {\n  GraphQLDisableErrorPropagationDirective,\n  GraphQLStreamDirective,\n} from '../type/directives.js';\nimport type { GraphQLSchema } from '../type/schema.js';\nimport { assertValidSchema } from '../type/validate.js';\n\nimport {\n  AbortSignalListener,\n  cancellableIterable,\n  cancellablePromise,\n} from './AbortSignalListener.js';\nimport type { DeferUsageSet, ExecutionPlan } from './buildExecutionPlan.js';\nimport { buildExecutionPlan } from './buildExecutionPlan.js';\nimport type {\n  DeferUsage,\n  FieldDetailsList,\n  FragmentDetails,\n  GroupedFieldSet,\n} from './collectFields.js';\nimport {\n  collectFields,\n  collectSubfields as _collectSubfields,\n} from './collectFields.js';\nimport { getVariableSignature } from './getVariableSignature.js';\nimport { buildIncrementalResponse } from './IncrementalPublisher.js';\nimport { mapAsyncIterable } from './mapAsyncIterable.js';\nimport type {\n  CancellableStreamRecord,\n  CompletedExecutionGroup,\n  ExecutionResult,\n  ExperimentalIncrementalExecutionResults,\n  IncrementalDataRecord,\n  PendingExecutionGroup,\n  StreamItemRecord,\n  StreamItemResult,\n  StreamRecord,\n} from './types.js';\nimport { DeferredFragmentRecord } from './types.js';\nimport type { VariableValues } from './values.js';\nimport {\n  experimentalGetArgumentValues,\n  getArgumentValues,\n  getDirectiveValues,\n  getVariableValues,\n} from './values.js';\n\n/* eslint-disable @typescript-eslint/max-params */\n// This file contains a lot of such errors but we plan to refactor it anyway\n// so just disable it for entire file.\n\n/**\n * A memoized collection of relevant subfields with regard to the return\n * type. Memoizing ensures the subfields are not repeatedly calculated, which\n * saves overhead when resolving lists of values.\n */\nconst collectSubfields = memoize3(\n  (\n    validatedExecutionArgs: ValidatedExecutionArgs,\n    returnType: GraphQLObjectType,\n    fieldDetailsList: FieldDetailsList,\n  ) => {\n    const { schema, fragments, variableValues, hideSuggestions } =\n      validatedExecutionArgs;\n    return _collectSubfields(\n      schema,\n      fragments,\n      variableValues,\n      returnType,\n      fieldDetailsList,\n      hideSuggestions,\n    );\n  },\n);\n\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g `a`\n * 2) fragment \"spreads\" e.g. `...c`\n * 3) inline fragment \"spreads\" e.g. `...on Type { a }`\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\nexport interface ValidatedExecutionArgs {\n  schema: GraphQLSchema;\n  // TODO: consider deprecating/removing fragmentDefinitions if/when fragment\n  // arguments are officially supported and/or the full fragment details are\n  // exposed within GraphQLResolveInfo.\n  fragmentDefinitions: ObjMap<FragmentDefinitionNode>;\n  fragments: ObjMap<FragmentDetails>;\n  rootValue: unknown;\n  contextValue: unknown;\n  operation: OperationDefinitionNode;\n  variableValues: VariableValues;\n  fieldResolver: GraphQLFieldResolver<any, any>;\n  typeResolver: GraphQLTypeResolver<any, any>;\n  subscribeFieldResolver: GraphQLFieldResolver<any, any>;\n  perEventExecutor: (\n    validatedExecutionArgs: ValidatedExecutionArgs,\n  ) => PromiseOrValue<ExecutionResult>;\n  enableEarlyExecution: boolean;\n  hideSuggestions: boolean;\n  abortSignal: AbortSignal | undefined;\n}\n\nexport interface ExecutionContext {\n  validatedExecutionArgs: ValidatedExecutionArgs;\n  errors: Array<GraphQLError> | undefined;\n  abortSignalListener: AbortSignalListener | undefined;\n  completed: boolean;\n  cancellableStreams: Set<CancellableStreamRecord> | undefined;\n  errorPropagation: boolean;\n}\n\ninterface IncrementalContext {\n  errors: Array<GraphQLError> | undefined;\n  completed: boolean;\n  deferUsageSet?: DeferUsageSet | undefined;\n}\n\nexport interface ExecutionArgs {\n  schema: GraphQLSchema;\n  document: DocumentNode;\n  rootValue?: unknown;\n  contextValue?: unknown;\n  variableValues?: Maybe<{ readonly [variable: string]: unknown }>;\n  operationName?: Maybe<string>;\n  fieldResolver?: Maybe<GraphQLFieldResolver<any, any>>;\n  typeResolver?: Maybe<GraphQLTypeResolver<any, any>>;\n  subscribeFieldResolver?: Maybe<GraphQLFieldResolver<any, any>>;\n  perEventExecutor?: Maybe<\n    (\n      validatedExecutionArgs: ValidatedExecutionArgs,\n    ) => PromiseOrValue<ExecutionResult>\n  >;\n  enableEarlyExecution?: Maybe<boolean>;\n  hideSuggestions?: Maybe<boolean>;\n  abortSignal?: Maybe<AbortSignal>;\n}\n\nexport interface StreamUsage {\n  label: string | undefined;\n  initialCount: number;\n  fieldDetailsList: FieldDetailsList;\n}\n\ninterface GraphQLWrappedResult<T> {\n  rawResult: T;\n  incrementalDataRecords: Array<IncrementalDataRecord> | undefined;\n}\n\nconst UNEXPECTED_EXPERIMENTAL_DIRECTIVES =\n  'The provided schema unexpectedly contains experimental directives (@defer or @stream). These directives may only be utilized if experimental execution features are explicitly enabled.';\n\nconst UNEXPECTED_MULTIPLE_PAYLOADS =\n  'Executing this GraphQL operation would unexpectedly produce multiple payloads (due to @defer or @stream directive)';\n\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification.\n *\n * Returns either a synchronous ExecutionResult (if all encountered resolvers\n * are synchronous), or a Promise of an ExecutionResult that will eventually be\n * resolved and never rejected.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n *\n * This function does not support incremental delivery (`@defer` and `@stream`).\n * If an operation which would defer or stream data is executed with this\n * function, it will throw or return a rejected promise.\n * Use `experimentalExecuteIncrementally` if you want to support incremental\n * delivery.\n */\nexport function execute(args: ExecutionArgs): PromiseOrValue<ExecutionResult> {\n  if (args.schema.getDirective('defer') || args.schema.getDirective('stream')) {\n    throw new Error(UNEXPECTED_EXPERIMENTAL_DIRECTIVES);\n  }\n\n  const result = experimentalExecuteIncrementally(args);\n  // Multiple payloads could be encountered if the operation contains @defer or\n  // @stream directives and is not validated prior to execution\n  return ensureSinglePayload(result);\n}\n\nfunction ensureSinglePayload(\n  result: PromiseOrValue<\n    ExecutionResult | ExperimentalIncrementalExecutionResults\n  >,\n): PromiseOrValue<ExecutionResult> {\n  if (isPromise(result)) {\n    return result.then((resolved) => {\n      if ('initialResult' in resolved) {\n        throw new Error(UNEXPECTED_MULTIPLE_PAYLOADS);\n      }\n      return resolved;\n    });\n  }\n  if ('initialResult' in result) {\n    throw new Error(UNEXPECTED_MULTIPLE_PAYLOADS);\n  }\n  return result;\n}\n\n/**\n * Implements the \"Executing requests\" section of the GraphQL specification,\n * including `@defer` and `@stream` as proposed in\n * https://github.com/graphql/graphql-spec/pull/742\n *\n * This function returns a Promise of an ExperimentalIncrementalExecutionResults\n * object. This object either consists of a single ExecutionResult, or an\n * object containing an `initialResult` and a stream of `subsequentResults`.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\nexport function experimentalExecuteIncrementally(\n  args: ExecutionArgs,\n): PromiseOrValue<ExecutionResult | ExperimentalIncrementalExecutionResults> {\n  // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n  const validatedExecutionArgs = validateExecutionArgs(args);\n\n  // Return early errors if execution context failed.\n  if (!('schema' in validatedExecutionArgs)) {\n    return { errors: validatedExecutionArgs };\n  }\n\n  return experimentalExecuteQueryOrMutationOrSubscriptionEvent(\n    validatedExecutionArgs,\n  );\n}\n\n/**\n * Implements the \"Executing operations\" section of the spec.\n *\n * Returns a Promise that will eventually resolve to the data described by\n * The \"Response\" section of the GraphQL specification.\n *\n * If errors are encountered while executing a GraphQL field, only that\n * field and its descendants will be omitted, and sibling fields will still\n * be executed. An execution which encounters errors will still result in a\n * resolved Promise.\n *\n * Errors from sub-fields of a NonNull type may propagate to the top level,\n * at which point we still log the error and null the parent field, which\n * in this case is the entire response.\n */\nexport function executeQueryOrMutationOrSubscriptionEvent(\n  validatedExecutionArgs: ValidatedExecutionArgs,\n): PromiseOrValue<ExecutionResult> {\n  const result = experimentalExecuteQueryOrMutationOrSubscriptionEvent(\n    validatedExecutionArgs,\n  );\n  return ensureSinglePayload(result);\n}\n\nfunction errorPropagation(operation: OperationDefinitionNode): boolean {\n  const directiveNode = operation.directives?.find(\n    (directive) =>\n      directive.name.value === GraphQLDisableErrorPropagationDirective.name,\n  );\n\n  return directiveNode === undefined;\n}\n\nexport function experimentalExecuteQueryOrMutationOrSubscriptionEvent(\n  validatedExecutionArgs: ValidatedExecutionArgs,\n): PromiseOrValue<ExecutionResult | ExperimentalIncrementalExecutionResults> {\n  const abortSignal = validatedExecutionArgs.abortSignal;\n  const exeContext: ExecutionContext = {\n    validatedExecutionArgs,\n    errors: undefined,\n    abortSignalListener: abortSignal\n      ? new AbortSignalListener(abortSignal)\n      : undefined,\n    completed: false,\n    cancellableStreams: undefined,\n    errorPropagation: errorPropagation(validatedExecutionArgs.operation),\n  };\n  try {\n    const {\n      schema,\n      fragments,\n      rootValue,\n      operation,\n      variableValues,\n      hideSuggestions,\n    } = validatedExecutionArgs;\n\n    const { operation: operationType, selectionSet } = operation;\n\n    const rootType = schema.getRootType(operationType);\n    if (rootType == null) {\n      throw new GraphQLError(\n        `Schema is not configured to execute ${operationType} operation.`,\n        { nodes: operation },\n      );\n    }\n\n    const { groupedFieldSet, newDeferUsages } = collectFields(\n      schema,\n      fragments,\n      variableValues,\n      rootType,\n      selectionSet,\n      hideSuggestions,\n    );\n\n    const graphqlWrappedResult = executeRootExecutionPlan(\n      exeContext,\n      operation.operation,\n      rootType,\n      rootValue,\n      groupedFieldSet,\n      newDeferUsages,\n    );\n\n    if (isPromise(graphqlWrappedResult)) {\n      return graphqlWrappedResult.then(\n        (resolved) => {\n          exeContext.completed = true;\n          return buildDataResponse(exeContext, resolved);\n        },\n        (error: unknown) => {\n          exeContext.completed = true;\n          exeContext.abortSignalListener?.disconnect();\n          return {\n            data: null,\n            errors: withError(exeContext.errors, error as GraphQLError),\n          };\n        },\n      );\n    }\n    exeContext.completed = true;\n    return buildDataResponse(exeContext, graphqlWrappedResult);\n  } catch (error) {\n    exeContext.completed = true;\n    // TODO: add test case for synchronous null bubbling to root with cancellation\n    /* c8 ignore next */\n    exeContext.abortSignalListener?.disconnect();\n    return { data: null, errors: withError(exeContext.errors, error) };\n  }\n}\n\nfunction withError(\n  errors: Array<GraphQLError> | undefined,\n  error: GraphQLError,\n): ReadonlyArray<GraphQLError> {\n  return errors === undefined ? [error] : [...errors, error];\n}\n\nfunction buildDataResponse(\n  exeContext: ExecutionContext,\n  graphqlWrappedResult: GraphQLWrappedResult<ObjMap<unknown>>,\n): ExecutionResult | ExperimentalIncrementalExecutionResults {\n  const { rawResult: data, incrementalDataRecords } = graphqlWrappedResult;\n  const errors = exeContext.errors;\n  if (incrementalDataRecords === undefined) {\n    exeContext.abortSignalListener?.disconnect();\n    return errors !== undefined ? { errors, data } : { data };\n  }\n\n  return buildIncrementalResponse(\n    exeContext,\n    data,\n    errors,\n    incrementalDataRecords,\n  );\n}\n\n/**\n * Also implements the \"Executing requests\" section of the GraphQL specification.\n * However, it guarantees to complete synchronously (or throw an error) assuming\n * that all field resolvers are also synchronous.\n */\nexport function executeSync(args: ExecutionArgs): ExecutionResult {\n  const result = experimentalExecuteIncrementally(args);\n\n  // Assert that the execution was synchronous.\n  if (isPromise(result) || 'initialResult' in result) {\n    throw new Error('GraphQL execution failed to complete synchronously.');\n  }\n\n  return result;\n}\n\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n *\n * TODO: consider no longer exporting this function\n * @internal\n */\nexport function validateExecutionArgs(\n  args: ExecutionArgs,\n): ReadonlyArray<GraphQLError> | ValidatedExecutionArgs {\n  const {\n    schema,\n    document,\n    rootValue,\n    contextValue,\n    variableValues: rawVariableValues,\n    operationName,\n    fieldResolver,\n    typeResolver,\n    subscribeFieldResolver,\n    perEventExecutor,\n    enableEarlyExecution,\n    abortSignal,\n  } = args;\n\n  if (abortSignal?.aborted) {\n    return [locatedError(abortSignal.reason, undefined)];\n  }\n\n  // If the schema used for execution is invalid, throw an error.\n  assertValidSchema(schema);\n\n  let operation: OperationDefinitionNode | undefined;\n  const fragmentDefinitions: ObjMap<FragmentDefinitionNode> =\n    Object.create(null);\n  const fragments: ObjMap<FragmentDetails> = Object.create(null);\n  for (const definition of document.definitions) {\n    switch (definition.kind) {\n      case Kind.OPERATION_DEFINITION:\n        if (operationName == null) {\n          if (operation !== undefined) {\n            return [\n              new GraphQLError(\n                'Must provide operation name if query contains multiple operations.',\n              ),\n            ];\n          }\n          operation = definition;\n        } else if (definition.name?.value === operationName) {\n          operation = definition;\n        }\n        break;\n      case Kind.FRAGMENT_DEFINITION: {\n        fragmentDefinitions[definition.name.value] = definition;\n        let variableSignatures;\n        if (definition.variableDefinitions) {\n          variableSignatures = Object.create(null);\n          for (const varDef of definition.variableDefinitions) {\n            const signature = getVariableSignature(schema, varDef);\n            variableSignatures[signature.name] = signature;\n          }\n        }\n        fragments[definition.name.value] = { definition, variableSignatures };\n        break;\n      }\n      default:\n      // ignore non-executable definitions\n    }\n  }\n\n  if (!operation) {\n    if (operationName != null) {\n      return [new GraphQLError(`Unknown operation named \"${operationName}\".`)];\n    }\n    return [new GraphQLError('Must provide an operation.')];\n  }\n\n  const variableDefinitions = operation.variableDefinitions ?? [];\n  const hideSuggestions = args.hideSuggestions ?? false;\n\n  const variableValuesOrErrors = getVariableValues(\n    schema,\n    variableDefinitions,\n    rawVariableValues ?? {},\n    {\n      maxErrors: 50,\n      hideSuggestions,\n    },\n  );\n\n  if (variableValuesOrErrors.errors) {\n    return variableValuesOrErrors.errors;\n  }\n\n  return {\n    schema,\n    fragmentDefinitions,\n    fragments,\n    rootValue,\n    contextValue,\n    operation,\n    variableValues: variableValuesOrErrors.variableValues,\n    fieldResolver: fieldResolver ?? defaultFieldResolver,\n    typeResolver: typeResolver ?? defaultTypeResolver,\n    subscribeFieldResolver: subscribeFieldResolver ?? defaultFieldResolver,\n    perEventExecutor: perEventExecutor ?? executeSubscriptionEvent,\n    enableEarlyExecution: enableEarlyExecution === true,\n    hideSuggestions,\n    abortSignal: args.abortSignal ?? undefined,\n  };\n}\n\nfunction executeRootExecutionPlan(\n  exeContext: ExecutionContext,\n  operation: OperationTypeNode,\n  rootType: GraphQLObjectType,\n  rootValue: unknown,\n  originalGroupedFieldSet: GroupedFieldSet,\n  newDeferUsages: ReadonlyArray<DeferUsage>,\n): PromiseOrValue<GraphQLWrappedResult<ObjMap<unknown>>> {\n  if (newDeferUsages.length === 0) {\n    return executeRootGroupedFieldSet(\n      exeContext,\n      operation,\n      rootType,\n      rootValue,\n      originalGroupedFieldSet,\n      undefined,\n    );\n  }\n  const newDeferMap = getNewDeferMap(newDeferUsages, undefined, undefined);\n\n  const { groupedFieldSet, newGroupedFieldSets } = buildExecutionPlan(\n    originalGroupedFieldSet,\n  );\n\n  const graphqlWrappedResult = executeRootGroupedFieldSet(\n    exeContext,\n    operation,\n    rootType,\n    rootValue,\n    groupedFieldSet,\n    newDeferMap,\n  );\n\n  if (newGroupedFieldSets.size > 0) {\n    const newPendingExecutionGroups = collectExecutionGroups(\n      exeContext,\n      rootType,\n      rootValue,\n      undefined,\n      undefined,\n      newGroupedFieldSets,\n      newDeferMap,\n    );\n\n    return withNewExecutionGroups(\n      graphqlWrappedResult,\n      newPendingExecutionGroups,\n    );\n  }\n  return graphqlWrappedResult;\n}\n\nfunction withNewExecutionGroups(\n  result: PromiseOrValue<GraphQLWrappedResult<ObjMap<unknown>>>,\n  newPendingExecutionGroups: ReadonlyArray<PendingExecutionGroup>,\n): PromiseOrValue<GraphQLWrappedResult<ObjMap<unknown>>> {\n  if (isPromise(result)) {\n    return result.then((resolved) => {\n      addIncrementalDataRecords(resolved, newPendingExecutionGroups);\n      return resolved;\n    });\n  }\n\n  addIncrementalDataRecords(result, newPendingExecutionGroups);\n  return result;\n}\n\nfunction executeRootGroupedFieldSet(\n  exeContext: ExecutionContext,\n  operation: OperationTypeNode,\n  rootType: GraphQLObjectType,\n  rootValue: unknown,\n  groupedFieldSet: GroupedFieldSet,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord> | undefined,\n): PromiseOrValue<GraphQLWrappedResult<ObjMap<unknown>>> {\n  switch (operation) {\n    case OperationTypeNode.QUERY:\n      return executeFields(\n        exeContext,\n        rootType,\n        rootValue,\n        undefined,\n        groupedFieldSet,\n        undefined,\n        deferMap,\n      );\n    case OperationTypeNode.MUTATION:\n      return executeFieldsSerially(\n        exeContext,\n        rootType,\n        rootValue,\n        undefined,\n        groupedFieldSet,\n        undefined,\n        deferMap,\n      );\n    case OperationTypeNode.SUBSCRIPTION:\n      // TODO: deprecate `subscribe` and move all logic here\n      // Temporary solution until we finish merging execute and subscribe together\n      return executeFields(\n        exeContext,\n        rootType,\n        rootValue,\n        undefined,\n        groupedFieldSet,\n        undefined,\n        deferMap,\n      );\n  }\n}\n\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that must be executed serially.\n */\nfunction executeFieldsSerially(\n  exeContext: ExecutionContext,\n  parentType: GraphQLObjectType,\n  sourceValue: unknown,\n  path: Path | undefined,\n  groupedFieldSet: GroupedFieldSet,\n  incrementalContext: IncrementalContext | undefined,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord> | undefined,\n): PromiseOrValue<GraphQLWrappedResult<ObjMap<unknown>>> {\n  const abortSignal = exeContext.validatedExecutionArgs.abortSignal;\n  return promiseReduce(\n    groupedFieldSet,\n    (graphqlWrappedResult, [responseName, fieldDetailsList]) => {\n      const fieldPath = addPath(path, responseName, parentType.name);\n\n      if (abortSignal?.aborted) {\n        handleFieldError(\n          abortSignal.reason,\n          exeContext,\n          parentType,\n          fieldDetailsList,\n          fieldPath,\n          incrementalContext,\n        );\n        graphqlWrappedResult.rawResult[responseName] = null;\n        return graphqlWrappedResult;\n      }\n\n      const result = executeField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldDetailsList,\n        fieldPath,\n        incrementalContext,\n        deferMap,\n      );\n      if (result === undefined) {\n        return graphqlWrappedResult;\n      }\n      if (isPromise(result)) {\n        return result.then((resolved) => {\n          graphqlWrappedResult.rawResult[responseName] = resolved.rawResult;\n          addIncrementalDataRecords(\n            graphqlWrappedResult,\n            resolved.incrementalDataRecords,\n          );\n          return graphqlWrappedResult;\n        });\n      }\n      graphqlWrappedResult.rawResult[responseName] = result.rawResult;\n      addIncrementalDataRecords(\n        graphqlWrappedResult,\n        result.incrementalDataRecords,\n      );\n      return graphqlWrappedResult;\n    },\n    {\n      rawResult: Object.create(null),\n      incrementalDataRecords: undefined,\n    },\n  );\n}\n\nfunction addIncrementalDataRecords(\n  graphqlWrappedResult: GraphQLWrappedResult<unknown>,\n  incrementalDataRecords: ReadonlyArray<IncrementalDataRecord> | undefined,\n): void {\n  if (incrementalDataRecords === undefined) {\n    return;\n  }\n  if (graphqlWrappedResult.incrementalDataRecords === undefined) {\n    graphqlWrappedResult.incrementalDataRecords = [...incrementalDataRecords];\n  } else {\n    graphqlWrappedResult.incrementalDataRecords.push(...incrementalDataRecords);\n  }\n}\n\n/**\n * Implements the \"Executing selection sets\" section of the spec\n * for fields that may be executed in parallel.\n */\nfunction executeFields(\n  exeContext: ExecutionContext,\n  parentType: GraphQLObjectType,\n  sourceValue: unknown,\n  path: Path | undefined,\n  groupedFieldSet: GroupedFieldSet,\n  incrementalContext: IncrementalContext | undefined,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord> | undefined,\n): PromiseOrValue<GraphQLWrappedResult<ObjMap<unknown>>> {\n  const results = Object.create(null);\n  const graphqlWrappedResult: GraphQLWrappedResult<ObjMap<unknown>> = {\n    rawResult: results,\n    incrementalDataRecords: undefined,\n  };\n  let containsPromise = false;\n\n  try {\n    for (const [responseName, fieldDetailsList] of groupedFieldSet) {\n      const fieldPath = addPath(path, responseName, parentType.name);\n      const result = executeField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldDetailsList,\n        fieldPath,\n        incrementalContext,\n        deferMap,\n      );\n\n      if (result !== undefined) {\n        if (isPromise(result)) {\n          results[responseName] = result.then((resolved) => {\n            addIncrementalDataRecords(\n              graphqlWrappedResult,\n              resolved.incrementalDataRecords,\n            );\n            return resolved.rawResult;\n          });\n          containsPromise = true;\n        } else {\n          results[responseName] = result.rawResult;\n          addIncrementalDataRecords(\n            graphqlWrappedResult,\n            result.incrementalDataRecords,\n          );\n        }\n      }\n    }\n  } catch (error) {\n    if (containsPromise) {\n      // Ensure that any promises returned by other fields are handled, as they may also reject.\n      return promiseForObject(results, () => {\n        /* noop */\n      }).finally(() => {\n        throw error;\n      }) as never;\n    }\n    throw error;\n  }\n\n  // If there are no promises, we can just return the object and any incrementalDataRecords\n  if (!containsPromise) {\n    return graphqlWrappedResult;\n  }\n\n  // Otherwise, results is a map from field name to the result of resolving that\n  // field, which is possibly a promise. Return a promise that will return this\n  // same map, but with any promises replaced with the values they resolved to.\n  return promiseForObject(results, (resolved) => ({\n    rawResult: resolved,\n    incrementalDataRecords: graphqlWrappedResult.incrementalDataRecords,\n  }));\n}\n\nfunction toNodes(fieldDetailsList: FieldDetailsList): ReadonlyArray<FieldNode> {\n  return fieldDetailsList.map((fieldDetails) => fieldDetails.node);\n}\n\n/**\n * Implements the \"Executing fields\" section of the spec\n * In particular, this function figures out the value that the field returns by\n * calling its resolve function, then calls completeValue to complete promises,\n * coercing scalars, or execute the sub-selection-set for objects.\n */\nfunction executeField(\n  exeContext: ExecutionContext,\n  parentType: GraphQLObjectType,\n  source: unknown,\n  fieldDetailsList: FieldDetailsList,\n  path: Path,\n  incrementalContext: IncrementalContext | undefined,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord> | undefined,\n): PromiseOrValue<GraphQLWrappedResult<unknown>> | undefined {\n  const { validatedExecutionArgs, abortSignalListener } = exeContext;\n  const { schema, contextValue, variableValues, hideSuggestions, abortSignal } =\n    validatedExecutionArgs;\n  const fieldName = fieldDetailsList[0].node.name.value;\n  const fieldDef = schema.getField(parentType, fieldName);\n  if (!fieldDef) {\n    return;\n  }\n\n  const returnType = fieldDef.type;\n  const resolveFn = fieldDef.resolve ?? validatedExecutionArgs.fieldResolver;\n\n  const info = buildResolveInfo(\n    validatedExecutionArgs,\n    fieldDef,\n    toNodes(fieldDetailsList),\n    parentType,\n    path,\n  );\n\n  // Get the resolve function, regardless of if its result is normal or abrupt (error).\n  try {\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    // TODO: find a way to memoize, in case this field is within a List type.\n    const args = experimentalGetArgumentValues(\n      fieldDetailsList[0].node,\n      fieldDef.args,\n      variableValues,\n      fieldDetailsList[0].fragmentVariableValues,\n      hideSuggestions,\n    );\n\n    // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n    const result = resolveFn(source, args, contextValue, info, abortSignal);\n\n    if (isPromise(result)) {\n      return completePromisedValue(\n        exeContext,\n        returnType,\n        fieldDetailsList,\n        info,\n        path,\n        abortSignalListener\n          ? cancellablePromise(result, abortSignalListener)\n          : result,\n        incrementalContext,\n        deferMap,\n      );\n    }\n\n    const completed = completeValue(\n      exeContext,\n      returnType,\n      fieldDetailsList,\n      info,\n      path,\n      result,\n      incrementalContext,\n      deferMap,\n    );\n\n    if (isPromise(completed)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return completed.then(undefined, (rawError: unknown) => {\n        handleFieldError(\n          rawError,\n          exeContext,\n          returnType,\n          fieldDetailsList,\n          path,\n          incrementalContext,\n        );\n        return { rawResult: null, incrementalDataRecords: undefined };\n      });\n    }\n    return completed;\n  } catch (rawError) {\n    handleFieldError(\n      rawError,\n      exeContext,\n      returnType,\n      fieldDetailsList,\n      path,\n      incrementalContext,\n    );\n    return { rawResult: null, incrementalDataRecords: undefined };\n  }\n}\n\n/**\n * TODO: consider no longer exporting this function\n * @internal\n */\nexport function buildResolveInfo(\n  validatedExecutionArgs: ValidatedExecutionArgs,\n  fieldDef: GraphQLField<unknown, unknown>,\n  fieldNodes: ReadonlyArray<FieldNode>,\n  parentType: GraphQLObjectType,\n  path: Path,\n): GraphQLResolveInfo {\n  const { schema, fragmentDefinitions, rootValue, operation, variableValues } =\n    validatedExecutionArgs;\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  return {\n    fieldName: fieldDef.name,\n    fieldNodes,\n    returnType: fieldDef.type,\n    parentType,\n    path,\n    schema,\n    fragments: fragmentDefinitions,\n    rootValue,\n    operation,\n    variableValues,\n  };\n}\n\nfunction handleFieldError(\n  rawError: unknown,\n  exeContext: ExecutionContext,\n  returnType: GraphQLOutputType,\n  fieldDetailsList: FieldDetailsList,\n  path: Path,\n  incrementalContext: IncrementalContext | undefined,\n): void {\n  const error = locatedError(\n    rawError,\n    toNodes(fieldDetailsList),\n    pathToArray(path),\n  );\n\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n  if (exeContext.errorPropagation && isNonNullType(returnType)) {\n    throw error;\n  }\n\n  // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n  const context = incrementalContext ?? exeContext;\n  let errors = context.errors;\n  if (errors === undefined) {\n    errors = [];\n    context.errors = errors;\n  }\n  errors.push(error);\n}\n\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Value Completion\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `coerceOutputValue` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by executing all sub-selections.\n */\nfunction completeValue(\n  exeContext: ExecutionContext,\n  returnType: GraphQLOutputType,\n  fieldDetailsList: FieldDetailsList,\n  info: GraphQLResolveInfo,\n  path: Path,\n  result: unknown,\n  incrementalContext: IncrementalContext | undefined,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord> | undefined,\n): PromiseOrValue<GraphQLWrappedResult<unknown>> {\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  }\n\n  // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n  if (isNonNullType(returnType)) {\n    const completed = completeValue(\n      exeContext,\n      returnType.ofType,\n      fieldDetailsList,\n      info,\n      path,\n      result,\n      incrementalContext,\n      deferMap,\n    );\n    if ((completed as GraphQLWrappedResult<unknown>).rawResult === null) {\n      throw new Error(\n        `Cannot return null for non-nullable field ${info.parentType}.${info.fieldName}.`,\n      );\n    }\n    return completed;\n  }\n\n  // If result value is null or undefined then return null.\n  if (result == null) {\n    return { rawResult: null, incrementalDataRecords: undefined };\n  }\n\n  // If field type is List, complete each item in the list with the inner type\n  if (isListType(returnType)) {\n    return completeListValue(\n      exeContext,\n      returnType,\n      fieldDetailsList,\n      info,\n      path,\n      result,\n      incrementalContext,\n      deferMap,\n    );\n  }\n\n  // If field type is a leaf type, Scalar or Enum, coerce to a valid value,\n  // returning null if coercion is not possible.\n  if (isLeafType(returnType)) {\n    return {\n      rawResult: completeLeafValue(returnType, result),\n      incrementalDataRecords: undefined,\n    };\n  }\n\n  // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n  if (isAbstractType(returnType)) {\n    return completeAbstractValue(\n      exeContext,\n      returnType,\n      fieldDetailsList,\n      info,\n      path,\n      result,\n      incrementalContext,\n      deferMap,\n    );\n  }\n\n  // If field type is Object, execute and complete all sub-selections.\n  if (isObjectType(returnType)) {\n    return completeObjectValue(\n      exeContext,\n      returnType,\n      fieldDetailsList,\n      info,\n      path,\n      result,\n      incrementalContext,\n      deferMap,\n    );\n  }\n  /* c8 ignore next 6 */\n  // Not reachable, all possible output types have been considered.\n  invariant(\n    false,\n    'Cannot complete value of unexpected output type: ' + inspect(returnType),\n  );\n}\n\nasync function completePromisedValue(\n  exeContext: ExecutionContext,\n  returnType: GraphQLOutputType,\n  fieldDetailsList: FieldDetailsList,\n  info: GraphQLResolveInfo,\n  path: Path,\n  result: Promise<unknown>,\n  incrementalContext: IncrementalContext | undefined,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord> | undefined,\n): Promise<GraphQLWrappedResult<unknown>> {\n  try {\n    const resolved = await result;\n    let completed = completeValue(\n      exeContext,\n      returnType,\n      fieldDetailsList,\n      info,\n      path,\n      resolved,\n      incrementalContext,\n      deferMap,\n    );\n\n    if (isPromise(completed)) {\n      completed = await completed;\n    }\n\n    return completed;\n  } catch (rawError) {\n    handleFieldError(\n      rawError,\n      exeContext,\n      returnType,\n      fieldDetailsList,\n      path,\n      incrementalContext,\n    );\n    return { rawResult: null, incrementalDataRecords: undefined };\n  }\n}\n\n/**\n * Returns an object containing info for streaming if a field should be\n * streamed based on the experimental flag, stream directive present and\n * not disabled by the \"if\" argument.\n */\nfunction getStreamUsage(\n  validatedExecutionArgs: ValidatedExecutionArgs,\n  fieldDetailsList: FieldDetailsList,\n  path: Path,\n): StreamUsage | undefined {\n  // do not stream inner lists of multi-dimensional lists\n  if (typeof path.key === 'number') {\n    return;\n  }\n\n  // TODO: add test for this case (a streamed list nested under a list).\n  /* c8 ignore next 7 */\n  if (\n    (fieldDetailsList as unknown as { _streamUsage: StreamUsage })\n      ._streamUsage !== undefined\n  ) {\n    return (fieldDetailsList as unknown as { _streamUsage: StreamUsage })\n      ._streamUsage;\n  }\n\n  const { operation, variableValues } = validatedExecutionArgs;\n  // validation only allows equivalent streams on multiple fields, so it is\n  // safe to only check the first fieldNode for the stream directive\n  const stream = getDirectiveValues(\n    GraphQLStreamDirective,\n    fieldDetailsList[0].node,\n    variableValues,\n    fieldDetailsList[0].fragmentVariableValues,\n  );\n\n  if (!stream) {\n    return;\n  }\n\n  if (stream.if === false) {\n    return;\n  }\n\n  invariant(\n    typeof stream.initialCount === 'number',\n    'initialCount must be a number',\n  );\n\n  invariant(\n    stream.initialCount >= 0,\n    'initialCount must be a positive integer',\n  );\n\n  invariant(\n    operation.operation !== OperationTypeNode.SUBSCRIPTION,\n    '`@stream` directive not supported on subscription operations. Disable `@stream` by setting the `if` argument to `false`.',\n  );\n\n  const streamedFieldDetailsList: FieldDetailsList = fieldDetailsList.map(\n    (fieldDetails) => ({\n      node: fieldDetails.node,\n      deferUsage: undefined,\n      fragmentVariableValues: fieldDetails.fragmentVariableValues,\n    }),\n  );\n\n  const streamUsage = {\n    initialCount: stream.initialCount,\n    label: typeof stream.label === 'string' ? stream.label : undefined,\n    fieldDetailsList: streamedFieldDetailsList,\n  };\n\n  (fieldDetailsList as unknown as { _streamUsage: StreamUsage })._streamUsage =\n    streamUsage;\n\n  return streamUsage;\n}\n\n/**\n * Complete a async iterator value by completing the result and calling\n * recursively until all the results are completed.\n */\nasync function completeAsyncIteratorValue(\n  exeContext: ExecutionContext,\n  itemType: GraphQLOutputType,\n  fieldDetailsList: FieldDetailsList,\n  info: GraphQLResolveInfo,\n  path: Path,\n  asyncIterator: AsyncIterator<unknown>,\n  incrementalContext: IncrementalContext | undefined,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord> | undefined,\n): Promise<GraphQLWrappedResult<ReadonlyArray<unknown>>> {\n  let containsPromise = false;\n  const completedResults: Array<unknown> = [];\n  const graphqlWrappedResult: GraphQLWrappedResult<Array<unknown>> = {\n    rawResult: completedResults,\n    incrementalDataRecords: undefined,\n  };\n  let index = 0;\n  const streamUsage = getStreamUsage(\n    exeContext.validatedExecutionArgs,\n    fieldDetailsList,\n    path,\n  );\n  const earlyReturn =\n    asyncIterator.return === undefined\n      ? undefined\n      : asyncIterator.return.bind(asyncIterator);\n  try {\n    while (true) {\n      if (streamUsage && index >= streamUsage.initialCount) {\n        const streamItemQueue = buildAsyncStreamItemQueue(\n          index,\n          path,\n          asyncIterator,\n          exeContext,\n          streamUsage.fieldDetailsList,\n          info,\n          itemType,\n        );\n\n        let streamRecord: StreamRecord | CancellableStreamRecord;\n        if (earlyReturn === undefined) {\n          streamRecord = {\n            label: streamUsage.label,\n            path,\n            streamItemQueue,\n          };\n        } else {\n          streamRecord = {\n            label: streamUsage.label,\n            path,\n            earlyReturn,\n            streamItemQueue,\n          };\n          if (exeContext.cancellableStreams === undefined) {\n            exeContext.cancellableStreams = new Set();\n          }\n          exeContext.cancellableStreams.add(streamRecord);\n        }\n\n        addIncrementalDataRecords(graphqlWrappedResult, [streamRecord]);\n        break;\n      }\n\n      const itemPath = addPath(path, index, undefined);\n      let iteration;\n      try {\n        // eslint-disable-next-line no-await-in-loop\n        iteration = await asyncIterator.next();\n      } catch (rawError) {\n        throw locatedError(\n          rawError,\n          toNodes(fieldDetailsList),\n          pathToArray(path),\n        );\n      }\n\n      // TODO: add test case for stream returning done before initialCount\n      /* c8 ignore next 3 */\n      if (iteration.done) {\n        break;\n      }\n\n      const item = iteration.value;\n      // TODO: add tests for stream backed by asyncIterator that returns a promise\n      /* c8 ignore start */\n      if (isPromise(item)) {\n        completedResults.push(\n          completePromisedListItemValue(\n            item,\n            graphqlWrappedResult,\n            exeContext,\n            itemType,\n            fieldDetailsList,\n            info,\n            itemPath,\n            incrementalContext,\n            deferMap,\n          ),\n        );\n        containsPromise = true;\n      } else if (\n        /* c8 ignore stop */\n        completeListItemValue(\n          item,\n          completedResults,\n          graphqlWrappedResult,\n          exeContext,\n          itemType,\n          fieldDetailsList,\n          info,\n          itemPath,\n          incrementalContext,\n          deferMap,\n        )\n        // TODO: add tests for stream backed by asyncIterator that completes to a promise\n        /* c8 ignore start */\n      ) {\n        containsPromise = true;\n      }\n      /* c8 ignore stop */\n      index++;\n    }\n  } catch (error) {\n    if (earlyReturn !== undefined) {\n      earlyReturn().catch(() => {\n        /* c8 ignore next 1 */\n        // ignore error\n      });\n    }\n    throw error;\n  }\n\n  return containsPromise\n    ? /* c8 ignore start */ Promise.all(completedResults).then((resolved) => ({\n        rawResult: resolved,\n        incrementalDataRecords: graphqlWrappedResult.incrementalDataRecords,\n      }))\n    : /* c8 ignore stop */ graphqlWrappedResult;\n}\n\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\nfunction completeListValue(\n  exeContext: ExecutionContext,\n  returnType: GraphQLList<GraphQLOutputType>,\n  fieldDetailsList: FieldDetailsList,\n  info: GraphQLResolveInfo,\n  path: Path,\n  result: unknown,\n  incrementalContext: IncrementalContext | undefined,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord> | undefined,\n): PromiseOrValue<GraphQLWrappedResult<ReadonlyArray<unknown>>> {\n  const itemType = returnType.ofType;\n\n  if (isAsyncIterable(result)) {\n    const abortSignalListener = exeContext.abortSignalListener;\n    const maybeCancellableIterable = abortSignalListener\n      ? cancellableIterable(result, abortSignalListener)\n      : result;\n    const asyncIterator = maybeCancellableIterable[Symbol.asyncIterator]();\n\n    return completeAsyncIteratorValue(\n      exeContext,\n      itemType,\n      fieldDetailsList,\n      info,\n      path,\n      asyncIterator,\n      incrementalContext,\n      deferMap,\n    );\n  }\n\n  if (!isIterableObject(result)) {\n    throw new GraphQLError(\n      `Expected Iterable, but did not find one for field \"${info.parentType}.${info.fieldName}\".`,\n    );\n  }\n\n  return completeIterableValue(\n    exeContext,\n    itemType,\n    fieldDetailsList,\n    info,\n    path,\n    result,\n    incrementalContext,\n    deferMap,\n  );\n}\n\nfunction completeIterableValue(\n  exeContext: ExecutionContext,\n  itemType: GraphQLOutputType,\n  fieldDetailsList: FieldDetailsList,\n  info: GraphQLResolveInfo,\n  path: Path,\n  items: Iterable<unknown>,\n  incrementalContext: IncrementalContext | undefined,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord> | undefined,\n): PromiseOrValue<GraphQLWrappedResult<ReadonlyArray<unknown>>> {\n  // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n  let containsPromise = false;\n  const completedResults: Array<unknown> = [];\n  const graphqlWrappedResult: GraphQLWrappedResult<Array<unknown>> = {\n    rawResult: completedResults,\n    incrementalDataRecords: undefined,\n  };\n  let index = 0;\n  const streamUsage = getStreamUsage(\n    exeContext.validatedExecutionArgs,\n    fieldDetailsList,\n    path,\n  );\n  const iterator = items[Symbol.iterator]();\n  let iteration = iterator.next();\n  while (!iteration.done) {\n    const item = iteration.value;\n\n    if (streamUsage && index >= streamUsage.initialCount) {\n      const syncStreamRecord: StreamRecord = {\n        label: streamUsage.label,\n        path,\n        streamItemQueue: buildSyncStreamItemQueue(\n          item,\n          index,\n          path,\n          iterator,\n          exeContext,\n          streamUsage.fieldDetailsList,\n          info,\n          itemType,\n        ),\n      };\n\n      addIncrementalDataRecords(graphqlWrappedResult, [syncStreamRecord]);\n      break;\n    }\n\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    const itemPath = addPath(path, index, undefined);\n\n    if (isPromise(item)) {\n      completedResults.push(\n        completePromisedListItemValue(\n          item,\n          graphqlWrappedResult,\n          exeContext,\n          itemType,\n          fieldDetailsList,\n          info,\n          itemPath,\n          incrementalContext,\n          deferMap,\n        ),\n      );\n      containsPromise = true;\n    } else if (\n      completeListItemValue(\n        item,\n        completedResults,\n        graphqlWrappedResult,\n        exeContext,\n        itemType,\n        fieldDetailsList,\n        info,\n        itemPath,\n        incrementalContext,\n        deferMap,\n      )\n    ) {\n      containsPromise = true;\n    }\n    index++;\n\n    iteration = iterator.next();\n  }\n\n  return containsPromise\n    ? Promise.all(completedResults).then((resolved) => ({\n        rawResult: resolved,\n        incrementalDataRecords: graphqlWrappedResult.incrementalDataRecords,\n      }))\n    : graphqlWrappedResult;\n}\n\n/**\n * Complete a list item value by adding it to the completed results.\n *\n * Returns true if the value is a Promise.\n */\nfunction completeListItemValue(\n  item: unknown,\n  completedResults: Array<unknown>,\n  parent: GraphQLWrappedResult<Array<unknown>>,\n  exeContext: ExecutionContext,\n  itemType: GraphQLOutputType,\n  fieldDetailsList: FieldDetailsList,\n  info: GraphQLResolveInfo,\n  itemPath: Path,\n  incrementalContext: IncrementalContext | undefined,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord> | undefined,\n): boolean {\n  try {\n    const completedItem = completeValue(\n      exeContext,\n      itemType,\n      fieldDetailsList,\n      info,\n      itemPath,\n      item,\n      incrementalContext,\n      deferMap,\n    );\n\n    if (isPromise(completedItem)) {\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      completedResults.push(\n        completedItem.then(\n          (resolved) => {\n            addIncrementalDataRecords(parent, resolved.incrementalDataRecords);\n            return resolved.rawResult;\n          },\n          (rawError: unknown) => {\n            handleFieldError(\n              rawError,\n              exeContext,\n              itemType,\n              fieldDetailsList,\n              itemPath,\n              incrementalContext,\n            );\n            return null;\n          },\n        ),\n      );\n      return true;\n    }\n\n    completedResults.push(completedItem.rawResult);\n    addIncrementalDataRecords(parent, completedItem.incrementalDataRecords);\n  } catch (rawError) {\n    handleFieldError(\n      rawError,\n      exeContext,\n      itemType,\n      fieldDetailsList,\n      itemPath,\n      incrementalContext,\n    );\n    completedResults.push(null);\n  }\n  return false;\n}\n\nasync function completePromisedListItemValue(\n  item: Promise<unknown>,\n  parent: GraphQLWrappedResult<Array<unknown>>,\n  exeContext: ExecutionContext,\n  itemType: GraphQLOutputType,\n  fieldDetailsList: FieldDetailsList,\n  info: GraphQLResolveInfo,\n  itemPath: Path,\n  incrementalContext: IncrementalContext | undefined,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord> | undefined,\n): Promise<unknown> {\n  try {\n    const abortSignalListener = exeContext.abortSignalListener;\n    const maybeCancellableItem = abortSignalListener\n      ? cancellablePromise(item, abortSignalListener)\n      : item;\n    const resolved = await maybeCancellableItem;\n    let completed = completeValue(\n      exeContext,\n      itemType,\n      fieldDetailsList,\n      info,\n      itemPath,\n      resolved,\n      incrementalContext,\n      deferMap,\n    );\n    if (isPromise(completed)) {\n      completed = await completed;\n    }\n    addIncrementalDataRecords(parent, completed.incrementalDataRecords);\n    return completed.rawResult;\n  } catch (rawError) {\n    handleFieldError(\n      rawError,\n      exeContext,\n      itemType,\n      fieldDetailsList,\n      itemPath,\n      incrementalContext,\n    );\n    return null;\n  }\n}\n\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\nfunction completeLeafValue(\n  returnType: GraphQLLeafType,\n  result: unknown,\n): unknown {\n  const coerced = returnType.coerceOutputValue(result);\n  if (coerced == null) {\n    throw new Error(\n      `Expected \\`${inspect(returnType)}.coerceOutputValue(${inspect(result)})\\` to ` +\n        `return non-nullable value, returned: ${inspect(coerced)}`,\n    );\n  }\n  return coerced;\n}\n\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\nfunction completeAbstractValue(\n  exeContext: ExecutionContext,\n  returnType: GraphQLAbstractType,\n  fieldDetailsList: FieldDetailsList,\n  info: GraphQLResolveInfo,\n  path: Path,\n  result: unknown,\n  incrementalContext: IncrementalContext | undefined,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord> | undefined,\n): PromiseOrValue<GraphQLWrappedResult<ObjMap<unknown>>> {\n  const validatedExecutionArgs = exeContext.validatedExecutionArgs;\n  const { schema, contextValue } = validatedExecutionArgs;\n  const resolveTypeFn =\n    returnType.resolveType ?? validatedExecutionArgs.typeResolver;\n  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);\n\n  if (isPromise(runtimeType)) {\n    return runtimeType.then((resolvedRuntimeType) =>\n      completeObjectValue(\n        exeContext,\n        ensureValidRuntimeType(\n          resolvedRuntimeType,\n          schema,\n          returnType,\n          fieldDetailsList,\n          info,\n          result,\n        ),\n        fieldDetailsList,\n        info,\n        path,\n        result,\n        incrementalContext,\n        deferMap,\n      ),\n    );\n  }\n\n  return completeObjectValue(\n    exeContext,\n    ensureValidRuntimeType(\n      runtimeType,\n      schema,\n      returnType,\n      fieldDetailsList,\n      info,\n      result,\n    ),\n    fieldDetailsList,\n    info,\n    path,\n    result,\n    incrementalContext,\n    deferMap,\n  );\n}\n\nfunction ensureValidRuntimeType(\n  runtimeTypeName: unknown,\n  schema: GraphQLSchema,\n  returnType: GraphQLAbstractType,\n  fieldDetailsList: FieldDetailsList,\n  info: GraphQLResolveInfo,\n  result: unknown,\n): GraphQLObjectType {\n  if (runtimeTypeName == null) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType}\" must resolve to an Object type at runtime for field \"${info.parentType}.${info.fieldName}\". Either the \"${returnType}\" type should provide a \"resolveType\" function or each possible type should provide an \"isTypeOf\" function.`,\n      { nodes: toNodes(fieldDetailsList) },\n    );\n  }\n\n  if (typeof runtimeTypeName !== 'string') {\n    throw new GraphQLError(\n      `Abstract type \"${returnType}\" must resolve to an Object type at runtime for field \"${info.parentType}.${info.fieldName}\" with ` +\n        `value ${inspect(result)}, received \"${inspect(\n          runtimeTypeName,\n        )}\", which is not a valid Object type name.`,\n    );\n  }\n\n  const runtimeType = schema.getType(runtimeTypeName);\n  if (runtimeType == null) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType}\" was resolved to a type \"${runtimeTypeName}\" that does not exist inside the schema.`,\n      { nodes: toNodes(fieldDetailsList) },\n    );\n  }\n\n  if (!isObjectType(runtimeType)) {\n    throw new GraphQLError(\n      `Abstract type \"${returnType}\" was resolved to a non-object type \"${runtimeTypeName}\".`,\n      { nodes: toNodes(fieldDetailsList) },\n    );\n  }\n\n  if (!schema.isSubType(returnType, runtimeType)) {\n    throw new GraphQLError(\n      `Runtime Object type \"${runtimeType}\" is not a possible type for \"${returnType}\".`,\n      { nodes: toNodes(fieldDetailsList) },\n    );\n  }\n\n  return runtimeType;\n}\n\n/**\n * Complete an Object value by executing all sub-selections.\n */\nfunction completeObjectValue(\n  exeContext: ExecutionContext,\n  returnType: GraphQLObjectType,\n  fieldDetailsList: FieldDetailsList,\n  info: GraphQLResolveInfo,\n  path: Path,\n  result: unknown,\n  incrementalContext: IncrementalContext | undefined,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord> | undefined,\n): PromiseOrValue<GraphQLWrappedResult<ObjMap<unknown>>> {\n  if ((incrementalContext ?? exeContext).completed) {\n    throw new Error('Completed, aborting.');\n  }\n\n  // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n  if (returnType.isTypeOf) {\n    const isTypeOf = returnType.isTypeOf(\n      result,\n      exeContext.validatedExecutionArgs.contextValue,\n      info,\n    );\n\n    if (isPromise(isTypeOf)) {\n      return isTypeOf.then((resolvedIsTypeOf) => {\n        if (!resolvedIsTypeOf) {\n          throw invalidReturnTypeError(returnType, result, fieldDetailsList);\n        }\n        return collectAndExecuteSubfields(\n          exeContext,\n          returnType,\n          fieldDetailsList,\n          path,\n          result,\n          incrementalContext,\n          deferMap,\n        );\n      });\n    }\n\n    if (!isTypeOf) {\n      throw invalidReturnTypeError(returnType, result, fieldDetailsList);\n    }\n  }\n\n  return collectAndExecuteSubfields(\n    exeContext,\n    returnType,\n    fieldDetailsList,\n    path,\n    result,\n    incrementalContext,\n    deferMap,\n  );\n}\n\nfunction invalidReturnTypeError(\n  returnType: GraphQLObjectType,\n  result: unknown,\n  fieldDetailsList: FieldDetailsList,\n): GraphQLError {\n  return new GraphQLError(\n    `Expected value of type \"${returnType}\" but got: ${inspect(result)}.`,\n    { nodes: toNodes(fieldDetailsList) },\n  );\n}\n\n/**\n * Instantiates new DeferredFragmentRecords for the given path within an\n * incremental data record, returning an updated map of DeferUsage\n * objects to DeferredFragmentRecords.\n *\n * Note: As defer directives may be used with operations returning lists,\n * a DeferUsage object may correspond to many DeferredFragmentRecords.\n */\nfunction getNewDeferMap(\n  newDeferUsages: ReadonlyArray<DeferUsage>,\n  deferMap?: ReadonlyMap<DeferUsage, DeferredFragmentRecord>,\n  path?: Path,\n): ReadonlyMap<DeferUsage, DeferredFragmentRecord> {\n  const newDeferMap = new Map(deferMap);\n\n  // For each new deferUsage object:\n  for (const newDeferUsage of newDeferUsages) {\n    const parentDeferUsage = newDeferUsage.parentDeferUsage;\n\n    const parent =\n      parentDeferUsage === undefined\n        ? undefined\n        : deferredFragmentRecordFromDeferUsage(parentDeferUsage, newDeferMap);\n\n    // Instantiate the new record.\n    const deferredFragmentRecord = new DeferredFragmentRecord(\n      path,\n      newDeferUsage.label,\n      parent,\n    );\n\n    // Update the map.\n    newDeferMap.set(newDeferUsage, deferredFragmentRecord);\n  }\n\n  return newDeferMap;\n}\n\nfunction deferredFragmentRecordFromDeferUsage(\n  deferUsage: DeferUsage,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord>,\n): DeferredFragmentRecord {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return deferMap.get(deferUsage)!;\n}\n\nfunction collectAndExecuteSubfields(\n  exeContext: ExecutionContext,\n  returnType: GraphQLObjectType,\n  fieldDetailsList: FieldDetailsList,\n  path: Path,\n  result: unknown,\n  incrementalContext: IncrementalContext | undefined,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord> | undefined,\n): PromiseOrValue<GraphQLWrappedResult<ObjMap<unknown>>> {\n  const validatedExecutionArgs = exeContext.validatedExecutionArgs;\n\n  // Collect sub-fields to execute to complete this value.\n  const collectedSubfields = collectSubfields(\n    validatedExecutionArgs,\n    returnType,\n    fieldDetailsList,\n  );\n  const { groupedFieldSet, newDeferUsages } = collectedSubfields;\n\n  if (newDeferUsages.length > 0) {\n    invariant(\n      validatedExecutionArgs.operation.operation !==\n        OperationTypeNode.SUBSCRIPTION,\n      '`@defer` directive not supported on subscription operations. Disable `@defer` by setting the `if` argument to `false`.',\n    );\n  }\n\n  return executeSubExecutionPlan(\n    exeContext,\n    returnType,\n    result,\n    groupedFieldSet,\n    newDeferUsages,\n    path,\n    incrementalContext,\n    deferMap,\n  );\n}\n\nfunction executeSubExecutionPlan(\n  exeContext: ExecutionContext,\n  returnType: GraphQLObjectType,\n  sourceValue: unknown,\n  originalGroupedFieldSet: GroupedFieldSet,\n  newDeferUsages: ReadonlyArray<DeferUsage>,\n  path?: Path,\n  incrementalContext?: IncrementalContext,\n  deferMap?: ReadonlyMap<DeferUsage, DeferredFragmentRecord>,\n): PromiseOrValue<GraphQLWrappedResult<ObjMap<unknown>>> {\n  if (deferMap === undefined && newDeferUsages.length === 0) {\n    return executeFields(\n      exeContext,\n      returnType,\n      sourceValue,\n      path,\n      originalGroupedFieldSet,\n      incrementalContext,\n      deferMap,\n    );\n  }\n\n  const newDeferMap = getNewDeferMap(newDeferUsages, deferMap, path);\n\n  const { groupedFieldSet, newGroupedFieldSets } = buildSubExecutionPlan(\n    originalGroupedFieldSet,\n    incrementalContext?.deferUsageSet,\n  );\n\n  const graphqlWrappedResult = executeFields(\n    exeContext,\n    returnType,\n    sourceValue,\n    path,\n    groupedFieldSet,\n    incrementalContext,\n    newDeferMap,\n  );\n\n  if (newGroupedFieldSets.size > 0) {\n    const newPendingExecutionGroups = collectExecutionGroups(\n      exeContext,\n      returnType,\n      sourceValue,\n      path,\n      incrementalContext?.deferUsageSet,\n      newGroupedFieldSets,\n      newDeferMap,\n    );\n\n    return withNewExecutionGroups(\n      graphqlWrappedResult,\n      newPendingExecutionGroups,\n    );\n  }\n  return graphqlWrappedResult;\n}\n\nfunction buildSubExecutionPlan(\n  originalGroupedFieldSet: GroupedFieldSet,\n  deferUsageSet: DeferUsageSet | undefined,\n): ExecutionPlan {\n  let executionPlan = (\n    originalGroupedFieldSet as unknown as { _executionPlan: ExecutionPlan }\n  )._executionPlan;\n  if (executionPlan !== undefined) {\n    return executionPlan;\n  }\n  executionPlan = buildExecutionPlan(originalGroupedFieldSet, deferUsageSet);\n  (\n    originalGroupedFieldSet as unknown as { _executionPlan: ExecutionPlan }\n  )._executionPlan = executionPlan;\n  return executionPlan;\n}\n\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which attempts two strategies:\n *\n * First, See if the provided value has a `__typename` field defined, if so, use\n * that value as name of the resolved type.\n *\n * Otherwise, test each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\nexport const defaultTypeResolver: GraphQLTypeResolver<unknown, unknown> =\n  function (value, contextValue, info, abstractType) {\n    // First, look for `__typename`.\n    if (isObjectLike(value) && typeof value.__typename === 'string') {\n      return value.__typename;\n    }\n\n    // Otherwise, test each possible type.\n    const possibleTypes = info.schema.getPossibleTypes(abstractType);\n    const promisedIsTypeOfResults = [];\n\n    for (let i = 0; i < possibleTypes.length; i++) {\n      const type = possibleTypes[i];\n\n      if (type.isTypeOf) {\n        const isTypeOfResult = type.isTypeOf(value, contextValue, info);\n\n        if (isPromise(isTypeOfResult)) {\n          promisedIsTypeOfResults[i] = isTypeOfResult;\n        } else if (isTypeOfResult) {\n          if (promisedIsTypeOfResults.length > 0) {\n            Promise.all(promisedIsTypeOfResults).then(undefined, () => {\n              /* ignore errors */\n            });\n          }\n\n          return type.name;\n        }\n      }\n    }\n\n    if (promisedIsTypeOfResults.length) {\n      return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {\n        for (let i = 0; i < isTypeOfResults.length; i++) {\n          if (isTypeOfResults[i]) {\n            return possibleTypes[i].name;\n          }\n        }\n      });\n    }\n  };\n\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function while passing along args and context value.\n */\nexport const defaultFieldResolver: GraphQLFieldResolver<unknown, unknown> =\n  function (source: any, args, contextValue, info, abortSignal) {\n    // ensure source is a value for which property access is acceptable.\n    if (isObjectLike(source) || typeof source === 'function') {\n      const property = source[info.fieldName];\n      if (typeof property === 'function') {\n        return source[info.fieldName](args, contextValue, info, abortSignal);\n      }\n      return property;\n    }\n  };\n\n/**\n * Implements the \"Subscribe\" algorithm described in the GraphQL specification.\n *\n * Returns a Promise which resolves to either an AsyncIterator (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with descriptive\n * errors and no data will be returned.\n *\n * If the source stream could not be created due to faulty subscription resolver\n * logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to an AsyncIterator, which\n * yields a stream of ExecutionResults representing the response stream.\n *\n * This function does not support incremental delivery (`@defer` and `@stream`).\n * If an operation which would defer or stream data is executed with this\n * function, a field error will be raised at the location of the `@defer` or\n * `@stream` directive.\n *\n * Accepts an object with named arguments.\n */\nexport function subscribe(\n  args: ExecutionArgs,\n): PromiseOrValue<\n  AsyncGenerator<ExecutionResult, void, void> | ExecutionResult\n> {\n  // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n  const validatedExecutionArgs = validateExecutionArgs(args);\n\n  // Return early errors if execution context failed.\n  if (!('schema' in validatedExecutionArgs)) {\n    return { errors: validatedExecutionArgs };\n  }\n\n  const resultOrStream = createSourceEventStreamImpl(validatedExecutionArgs);\n\n  if (isPromise(resultOrStream)) {\n    return resultOrStream.then((resolvedResultOrStream) =>\n      mapSourceToResponse(validatedExecutionArgs, resolvedResultOrStream),\n    );\n  }\n\n  return mapSourceToResponse(validatedExecutionArgs, resultOrStream);\n}\n\nfunction mapSourceToResponse(\n  validatedExecutionArgs: ValidatedExecutionArgs,\n  resultOrStream: ExecutionResult | AsyncIterable<unknown>,\n): AsyncGenerator<ExecutionResult, void, void> | ExecutionResult {\n  if (!isAsyncIterable(resultOrStream)) {\n    return resultOrStream;\n  }\n\n  const abortSignal = validatedExecutionArgs.abortSignal;\n  const abortSignalListener = abortSignal\n    ? new AbortSignalListener(abortSignal)\n    : undefined;\n\n  // For each payload yielded from a subscription, map it over the normal\n  // GraphQL `execute` function, with `payload` as the rootValue.\n  // This implements the \"MapSourceToResponseEvent\" algorithm described in\n  // the GraphQL specification..\n  return mapAsyncIterable(\n    abortSignalListener\n      ? cancellableIterable(resultOrStream, abortSignalListener)\n      : resultOrStream,\n    (payload: unknown) => {\n      const perEventExecutionArgs: ValidatedExecutionArgs = {\n        ...validatedExecutionArgs,\n        rootValue: payload,\n      };\n      return validatedExecutionArgs.perEventExecutor(perEventExecutionArgs);\n    },\n    () => abortSignalListener?.disconnect(),\n  );\n}\n\nexport function executeSubscriptionEvent(\n  validatedExecutionArgs: ValidatedExecutionArgs,\n): PromiseOrValue<ExecutionResult> {\n  return executeQueryOrMutationOrSubscriptionEvent(validatedExecutionArgs);\n}\n\n/**\n * Implements the \"CreateSourceEventStream\" algorithm described in the\n * GraphQL specification, resolving the subscription source event stream.\n *\n * Returns a Promise which resolves to either an AsyncIterable (if successful)\n * or an ExecutionResult (error). The promise will be rejected if the schema or\n * other arguments to this function are invalid, or if the resolved event stream\n * is not an async iterable.\n *\n * If the client-provided arguments to this function do not result in a\n * compliant subscription, a GraphQL Response (ExecutionResult) with\n * descriptive errors and no data will be returned.\n *\n * If the the source stream could not be created due to faulty subscription\n * resolver logic or underlying systems, the promise will resolve to a single\n * ExecutionResult containing `errors` and no `data`.\n *\n * If the operation succeeded, the promise resolves to the AsyncIterable for the\n * event stream returned by the resolver.\n *\n * A Source Event Stream represents a sequence of events, each of which triggers\n * a GraphQL execution for that event.\n *\n * This may be useful when hosting the stateful subscription service in a\n * different process or machine than the stateless GraphQL execution engine,\n * or otherwise separating these two steps. For more on this, see the\n * \"Supporting Subscriptions at Scale\" information in the GraphQL specification.\n */\nexport function createSourceEventStream(\n  args: ExecutionArgs,\n): PromiseOrValue<AsyncIterable<unknown> | ExecutionResult> {\n  // If a valid execution context cannot be created due to incorrect arguments,\n  // a \"Response\" with only errors is returned.\n  const validatedExecutionArgs = validateExecutionArgs(args);\n\n  // Return early errors if execution context failed.\n  if (!('schema' in validatedExecutionArgs)) {\n    return { errors: validatedExecutionArgs };\n  }\n\n  return createSourceEventStreamImpl(validatedExecutionArgs);\n}\n\nfunction createSourceEventStreamImpl(\n  validatedExecutionArgs: ValidatedExecutionArgs,\n): PromiseOrValue<AsyncIterable<unknown> | ExecutionResult> {\n  try {\n    const eventStream = executeSubscription(validatedExecutionArgs);\n    if (isPromise(eventStream)) {\n      return eventStream.then(undefined, (error: unknown) => ({\n        errors: [error as GraphQLError],\n      }));\n    }\n\n    return eventStream;\n  } catch (error) {\n    return { errors: [error] };\n  }\n}\n\nfunction executeSubscription(\n  validatedExecutionArgs: ValidatedExecutionArgs,\n): PromiseOrValue<AsyncIterable<unknown>> {\n  const {\n    schema,\n    fragments,\n    rootValue,\n    contextValue,\n    operation,\n    variableValues,\n    hideSuggestions,\n    abortSignal,\n  } = validatedExecutionArgs;\n\n  const rootType = schema.getSubscriptionType();\n  if (rootType == null) {\n    throw new GraphQLError(\n      'Schema is not configured to execute subscription operation.',\n      { nodes: operation },\n    );\n  }\n\n  const { groupedFieldSet } = collectFields(\n    schema,\n    fragments,\n    variableValues,\n    rootType,\n    operation.selectionSet,\n    hideSuggestions,\n  );\n\n  const firstRootField = groupedFieldSet.entries().next().value as [\n    string,\n    FieldDetailsList,\n  ];\n  const [responseName, fieldDetailsList] = firstRootField;\n  const fieldName = fieldDetailsList[0].node.name.value;\n  const fieldDef = schema.getField(rootType, fieldName);\n\n  const fieldNodes = fieldDetailsList.map((fieldDetails) => fieldDetails.node);\n  if (!fieldDef) {\n    throw new GraphQLError(\n      `The subscription field \"${fieldName}\" is not defined.`,\n      { nodes: fieldNodes },\n    );\n  }\n\n  const path = addPath(undefined, responseName, rootType.name);\n  const info = buildResolveInfo(\n    validatedExecutionArgs,\n    fieldDef,\n    fieldNodes,\n    rootType,\n    path,\n  );\n\n  try {\n    // Implements the \"ResolveFieldEventStream\" algorithm from GraphQL specification.\n    // It differs from \"ResolveFieldValue\" due to providing a different `resolveFn`.\n\n    // Build a JS object of arguments from the field.arguments AST, using the\n    // variables scope to fulfill any variable references.\n    const args = getArgumentValues(\n      fieldDef,\n      fieldNodes[0],\n      variableValues,\n      hideSuggestions,\n    );\n\n    // Call the `subscribe()` resolver or the default resolver to produce an\n    // AsyncIterable yielding raw payloads.\n    const resolveFn =\n      fieldDef.subscribe ?? validatedExecutionArgs.subscribeFieldResolver;\n\n    // The resolve function's optional third argument is a context value that\n    // is provided to every resolve function within an execution. It is commonly\n    // used to represent an authenticated user, or request-specific caches.\n    const result = resolveFn(rootValue, args, contextValue, info, abortSignal);\n\n    if (isPromise(result)) {\n      const abortSignalListener = abortSignal\n        ? new AbortSignalListener(abortSignal)\n        : undefined;\n\n      const promise = abortSignalListener\n        ? cancellablePromise(result, abortSignalListener)\n        : result;\n      return promise.then(assertEventStream).then(\n        (resolved) => {\n          abortSignalListener?.disconnect();\n          return resolved;\n        },\n        (error: unknown) => {\n          abortSignalListener?.disconnect();\n          throw locatedError(error, fieldNodes, pathToArray(path));\n        },\n      );\n    }\n\n    return assertEventStream(result);\n  } catch (error) {\n    throw locatedError(error, fieldNodes, pathToArray(path));\n  }\n}\n\nfunction assertEventStream(result: unknown): AsyncIterable<unknown> {\n  if (result instanceof Error) {\n    throw result;\n  }\n\n  // Assert field returned an event stream, otherwise yield an error.\n  if (!isAsyncIterable(result)) {\n    throw new GraphQLError(\n      'Subscription field must return Async Iterable. ' +\n        `Received: ${inspect(result)}.`,\n    );\n  }\n\n  return result;\n}\n\nfunction collectExecutionGroups(\n  exeContext: ExecutionContext,\n  parentType: GraphQLObjectType,\n  sourceValue: unknown,\n  path: Path | undefined,\n  parentDeferUsages: DeferUsageSet | undefined,\n  newGroupedFieldSets: Map<DeferUsageSet, GroupedFieldSet>,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord>,\n): ReadonlyArray<PendingExecutionGroup> {\n  const newPendingExecutionGroups: Array<PendingExecutionGroup> = [];\n\n  for (const [deferUsageSet, groupedFieldSet] of newGroupedFieldSets) {\n    const deferredFragmentRecords = getDeferredFragmentRecords(\n      deferUsageSet,\n      deferMap,\n    );\n\n    const pendingExecutionGroup: PendingExecutionGroup = {\n      deferredFragmentRecords,\n      result:\n        undefined as unknown as BoxedPromiseOrValue<CompletedExecutionGroup>,\n    };\n\n    const executor = () =>\n      executeExecutionGroup(\n        pendingExecutionGroup,\n        exeContext,\n        parentType,\n        sourceValue,\n        path,\n        groupedFieldSet,\n        {\n          errors: undefined,\n          completed: false,\n          deferUsageSet,\n        },\n        deferMap,\n      );\n\n    if (exeContext.validatedExecutionArgs.enableEarlyExecution) {\n      pendingExecutionGroup.result = new BoxedPromiseOrValue(\n        shouldDefer(parentDeferUsages, deferUsageSet)\n          ? Promise.resolve().then(executor)\n          : executor(),\n      );\n    } else {\n      pendingExecutionGroup.result = () => new BoxedPromiseOrValue(executor());\n    }\n\n    newPendingExecutionGroups.push(pendingExecutionGroup);\n  }\n\n  return newPendingExecutionGroups;\n}\n\nfunction shouldDefer(\n  parentDeferUsages: undefined | DeferUsageSet,\n  deferUsages: DeferUsageSet,\n): boolean {\n  // If we have a new child defer usage, defer.\n  // Otherwise, this defer usage was already deferred when it was initially\n  // encountered, and is now in the midst of executing early, so the new\n  // deferred grouped fields set can be executed immediately.\n  return (\n    parentDeferUsages === undefined ||\n    !Array.from(deferUsages).every((deferUsage) =>\n      parentDeferUsages.has(deferUsage),\n    )\n  );\n}\n\nfunction executeExecutionGroup(\n  pendingExecutionGroup: PendingExecutionGroup,\n  exeContext: ExecutionContext,\n  parentType: GraphQLObjectType,\n  sourceValue: unknown,\n  path: Path | undefined,\n  groupedFieldSet: GroupedFieldSet,\n  incrementalContext: IncrementalContext,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord>,\n): PromiseOrValue<CompletedExecutionGroup> {\n  let result;\n  try {\n    result = executeFields(\n      exeContext,\n      parentType,\n      sourceValue,\n      path,\n      groupedFieldSet,\n      incrementalContext,\n      deferMap,\n    );\n  } catch (error) {\n    incrementalContext.completed = true;\n    return {\n      pendingExecutionGroup,\n      path: pathToArray(path),\n      errors: withError(incrementalContext.errors, error),\n    };\n  }\n\n  if (isPromise(result)) {\n    return result.then(\n      (resolved) => {\n        incrementalContext.completed = true;\n        return buildCompletedExecutionGroup(\n          incrementalContext.errors,\n          pendingExecutionGroup,\n          path,\n          resolved,\n        );\n      },\n      (error: unknown) => {\n        incrementalContext.completed = true;\n        return {\n          pendingExecutionGroup,\n          path: pathToArray(path),\n          errors: withError(incrementalContext.errors, error as GraphQLError),\n        };\n      },\n    );\n  }\n\n  incrementalContext.completed = true;\n  return buildCompletedExecutionGroup(\n    incrementalContext.errors,\n    pendingExecutionGroup,\n    path,\n    result,\n  );\n}\n\nfunction buildCompletedExecutionGroup(\n  errors: ReadonlyArray<GraphQLError> | undefined,\n  pendingExecutionGroup: PendingExecutionGroup,\n  path: Path | undefined,\n  result: GraphQLWrappedResult<ObjMap<unknown>>,\n): CompletedExecutionGroup {\n  const { rawResult: data, incrementalDataRecords } = result;\n  return {\n    pendingExecutionGroup,\n    path: pathToArray(path),\n    result: errors === undefined ? { data } : { data, errors },\n    incrementalDataRecords,\n  };\n}\n\nfunction getDeferredFragmentRecords(\n  deferUsages: DeferUsageSet,\n  deferMap: ReadonlyMap<DeferUsage, DeferredFragmentRecord>,\n): ReadonlyArray<DeferredFragmentRecord> {\n  return Array.from(deferUsages).map((deferUsage) =>\n    deferredFragmentRecordFromDeferUsage(deferUsage, deferMap),\n  );\n}\n\nfunction buildSyncStreamItemQueue(\n  initialItem: PromiseOrValue<unknown>,\n  initialIndex: number,\n  streamPath: Path,\n  iterator: Iterator<unknown>,\n  exeContext: ExecutionContext,\n  fieldDetailsList: FieldDetailsList,\n  info: GraphQLResolveInfo,\n  itemType: GraphQLOutputType,\n): Array<StreamItemRecord> {\n  const streamItemQueue: Array<StreamItemRecord> = [];\n\n  const enableEarlyExecution =\n    exeContext.validatedExecutionArgs.enableEarlyExecution;\n\n  const firstExecutor = () => {\n    const initialPath = addPath(streamPath, initialIndex, undefined);\n    const firstStreamItem = new BoxedPromiseOrValue(\n      completeStreamItem(\n        initialPath,\n        initialItem,\n        exeContext,\n        { errors: undefined, completed: false },\n        fieldDetailsList,\n        info,\n        itemType,\n      ),\n    );\n\n    let iteration = iterator.next();\n    let currentIndex = initialIndex + 1;\n    let currentStreamItem:\n      | BoxedPromiseOrValue<StreamItemResult>\n      | (() => BoxedPromiseOrValue<StreamItemResult>) = firstStreamItem;\n    while (!iteration.done) {\n      // TODO: add test case for early sync termination\n      /* c8 ignore next 6 */\n      if (currentStreamItem instanceof BoxedPromiseOrValue) {\n        const result = currentStreamItem.value;\n        if (!isPromise(result) && result.errors !== undefined) {\n          break;\n        }\n      }\n\n      const itemPath = addPath(streamPath, currentIndex, undefined);\n\n      const value = iteration.value;\n\n      const currentExecutor = () =>\n        completeStreamItem(\n          itemPath,\n          value,\n          exeContext,\n          { errors: undefined, completed: false },\n          fieldDetailsList,\n          info,\n          itemType,\n        );\n\n      currentStreamItem = enableEarlyExecution\n        ? new BoxedPromiseOrValue(currentExecutor())\n        : () => new BoxedPromiseOrValue(currentExecutor());\n\n      streamItemQueue.push(currentStreamItem);\n\n      iteration = iterator.next();\n      currentIndex = initialIndex + 1;\n    }\n\n    streamItemQueue.push(new BoxedPromiseOrValue({}));\n\n    return firstStreamItem.value;\n  };\n\n  streamItemQueue.push(\n    enableEarlyExecution\n      ? new BoxedPromiseOrValue(Promise.resolve().then(firstExecutor))\n      : () => new BoxedPromiseOrValue(firstExecutor()),\n  );\n\n  return streamItemQueue;\n}\n\nfunction buildAsyncStreamItemQueue(\n  initialIndex: number,\n  streamPath: Path,\n  asyncIterator: AsyncIterator<unknown>,\n  exeContext: ExecutionContext,\n  fieldDetailsList: FieldDetailsList,\n  info: GraphQLResolveInfo,\n  itemType: GraphQLOutputType,\n): Array<StreamItemRecord> {\n  const streamItemQueue: Array<StreamItemRecord> = [];\n  const executor = () =>\n    getNextAsyncStreamItemResult(\n      streamItemQueue,\n      streamPath,\n      initialIndex,\n      asyncIterator,\n      exeContext,\n      fieldDetailsList,\n      info,\n      itemType,\n    );\n\n  streamItemQueue.push(\n    exeContext.validatedExecutionArgs.enableEarlyExecution\n      ? new BoxedPromiseOrValue(executor())\n      : () => new BoxedPromiseOrValue(executor()),\n  );\n\n  return streamItemQueue;\n}\n\nasync function getNextAsyncStreamItemResult(\n  streamItemQueue: Array<StreamItemRecord>,\n  streamPath: Path,\n  index: number,\n  asyncIterator: AsyncIterator<unknown>,\n  exeContext: ExecutionContext,\n  fieldDetailsList: FieldDetailsList,\n  info: GraphQLResolveInfo,\n  itemType: GraphQLOutputType,\n): Promise<StreamItemResult> {\n  let iteration;\n  try {\n    iteration = await asyncIterator.next();\n  } catch (error) {\n    return {\n      errors: [\n        locatedError(error, toNodes(fieldDetailsList), pathToArray(streamPath)),\n      ],\n    };\n  }\n\n  if (iteration.done) {\n    return {};\n  }\n\n  const itemPath = addPath(streamPath, index, undefined);\n\n  const result = completeStreamItem(\n    itemPath,\n    iteration.value,\n    exeContext,\n    { errors: undefined, completed: false },\n    fieldDetailsList,\n    info,\n    itemType,\n  );\n\n  const executor = () =>\n    getNextAsyncStreamItemResult(\n      streamItemQueue,\n      streamPath,\n      index + 1,\n      asyncIterator,\n      exeContext,\n      fieldDetailsList,\n      info,\n      itemType,\n    );\n\n  streamItemQueue.push(\n    exeContext.validatedExecutionArgs.enableEarlyExecution\n      ? new BoxedPromiseOrValue(executor())\n      : () => new BoxedPromiseOrValue(executor()),\n  );\n\n  return result;\n}\n\nfunction completeStreamItem(\n  itemPath: Path,\n  item: unknown,\n  exeContext: ExecutionContext,\n  incrementalContext: IncrementalContext,\n  fieldDetailsList: FieldDetailsList,\n  info: GraphQLResolveInfo,\n  itemType: GraphQLOutputType,\n): PromiseOrValue<StreamItemResult> {\n  if (isPromise(item)) {\n    const abortSignalListener = exeContext.abortSignalListener;\n    const maybeCancellableItem = abortSignalListener\n      ? cancellablePromise(item, abortSignalListener)\n      : item;\n    return completePromisedValue(\n      exeContext,\n      itemType,\n      fieldDetailsList,\n      info,\n      itemPath,\n      maybeCancellableItem,\n      incrementalContext,\n      new Map(),\n    ).then(\n      (resolvedItem) => {\n        incrementalContext.completed = true;\n        return buildStreamItemResult(incrementalContext.errors, resolvedItem);\n      },\n      (error: unknown) => {\n        incrementalContext.completed = true;\n        return {\n          errors: withError(incrementalContext.errors, error as GraphQLError),\n        };\n      },\n    );\n  }\n\n  let result: PromiseOrValue<GraphQLWrappedResult<unknown>>;\n  try {\n    try {\n      result = completeValue(\n        exeContext,\n        itemType,\n        fieldDetailsList,\n        info,\n        itemPath,\n        item,\n        incrementalContext,\n        new Map(),\n      );\n    } catch (rawError) {\n      handleFieldError(\n        rawError,\n        exeContext,\n        itemType,\n        fieldDetailsList,\n        itemPath,\n        incrementalContext,\n      );\n      result = { rawResult: null, incrementalDataRecords: undefined };\n    }\n  } catch (error) {\n    incrementalContext.completed = true;\n    return {\n      errors: withError(incrementalContext.errors, error),\n    };\n  }\n\n  if (isPromise(result)) {\n    return result\n      .then(undefined, (rawError: unknown) => {\n        handleFieldError(\n          rawError,\n          exeContext,\n          itemType,\n          fieldDetailsList,\n          itemPath,\n          incrementalContext,\n        );\n        return { rawResult: null, incrementalDataRecords: undefined };\n      })\n      .then(\n        (resolvedItem) => {\n          incrementalContext.completed = true;\n          return buildStreamItemResult(incrementalContext.errors, resolvedItem);\n        },\n        (error: unknown) => {\n          incrementalContext.completed = true;\n          return {\n            errors: withError(incrementalContext.errors, error as GraphQLError),\n          };\n        },\n      );\n  }\n\n  incrementalContext.completed = true;\n  return buildStreamItemResult(incrementalContext.errors, result);\n}\n\nfunction buildStreamItemResult(\n  errors: ReadonlyArray<GraphQLError> | undefined,\n  result: GraphQLWrappedResult<unknown>,\n): StreamItemResult {\n  const { rawResult: item, incrementalDataRecords } = result;\n  return {\n    item,\n    errors,\n    incrementalDataRecords,\n  };\n}\n"]}