{"version":3,"file":"values.js","sourceRoot":"","sources":["../../src/execution/values.ts"],"names":[],"mappings":"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","sourcesContent":["import { invariant } from '../jsutils/invariant.js';\nimport type { Maybe } from '../jsutils/Maybe.js';\nimport type { ObjMap, ReadOnlyObjMap } from '../jsutils/ObjMap.js';\nimport { printPathArray } from '../jsutils/printPathArray.js';\n\nimport { GraphQLError } from '../error/GraphQLError.js';\n\nimport type {\n  DirectiveNode,\n  FieldNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n} from '../language/ast.js';\nimport { Kind } from '../language/kinds.js';\n\nimport type { GraphQLArgument, GraphQLField } from '../type/definition.js';\nimport {\n  isArgument,\n  isNonNullType,\n  isRequiredArgument,\n} from '../type/definition.js';\nimport type { GraphQLDirective } from '../type/directives.js';\nimport type { GraphQLSchema } from '../type/schema.js';\n\nimport {\n  coerceDefaultValue,\n  coerceInputLiteral,\n  coerceInputValue,\n} from '../utilities/coerceInputValue.js';\nimport {\n  validateInputLiteral,\n  validateInputValue,\n} from '../utilities/validateInputValue.js';\n\nimport type { GraphQLVariableSignature } from './getVariableSignature.js';\nimport { getVariableSignature } from './getVariableSignature.js';\n\nexport interface VariableValues {\n  readonly sources: ReadOnlyObjMap<VariableValueSource>;\n  readonly coerced: ReadOnlyObjMap<unknown>;\n}\n\ninterface VariableValueSource {\n  readonly signature: GraphQLVariableSignature;\n  readonly value?: unknown;\n}\n\ntype VariableValuesOrErrors =\n  | { variableValues: VariableValues; errors?: never }\n  | { errors: ReadonlyArray<GraphQLError>; variableValues?: never };\n\n/**\n * Prepares an object map of variableValues of the correct type based on the\n * provided variable definitions and arbitrary input. If the input cannot be\n * parsed to match the variable definitions, a GraphQLError will be thrown.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getVariableValues(\n  schema: GraphQLSchema,\n  varDefNodes: ReadonlyArray<VariableDefinitionNode>,\n  inputs: { readonly [variable: string]: unknown },\n  options?: { maxErrors?: number; hideSuggestions?: boolean },\n): VariableValuesOrErrors {\n  const errors: Array<GraphQLError> = [];\n  const maxErrors = options?.maxErrors;\n  try {\n    const variableValues = coerceVariableValues(\n      schema,\n      varDefNodes,\n      inputs,\n      (error) => {\n        if (maxErrors != null && errors.length >= maxErrors) {\n          throw new GraphQLError(\n            'Too many errors processing variables, error limit reached. Execution aborted.',\n          );\n        }\n        errors.push(error);\n      },\n      options?.hideSuggestions,\n    );\n\n    if (errors.length === 0) {\n      return { variableValues };\n    }\n  } catch (error) {\n    errors.push(error);\n  }\n\n  return { errors };\n}\n\nfunction coerceVariableValues(\n  schema: GraphQLSchema,\n  varDefNodes: ReadonlyArray<VariableDefinitionNode>,\n  inputs: { readonly [variable: string]: unknown },\n  onError: (error: GraphQLError) => void,\n  hideSuggestions?: Maybe<boolean>,\n): VariableValues {\n  const sources: ObjMap<VariableValueSource> = Object.create(null);\n  const coerced: ObjMap<unknown> = Object.create(null);\n  for (const varDefNode of varDefNodes) {\n    const varSignature = getVariableSignature(schema, varDefNode);\n\n    if (varSignature instanceof GraphQLError) {\n      onError(varSignature);\n      continue;\n    }\n\n    const { name: varName, type: varType } = varSignature;\n    let value: unknown;\n    if (!Object.hasOwn(inputs, varName)) {\n      sources[varName] = { signature: varSignature };\n      if (varDefNode.defaultValue) {\n        coerced[varName] = coerceInputLiteral(varDefNode.defaultValue, varType);\n        continue;\n      } else if (!isNonNullType(varType)) {\n        // Non-provided values for nullable variables are omitted.\n        continue;\n      }\n    } else {\n      value = inputs[varName];\n      sources[varName] = { signature: varSignature, value };\n    }\n\n    const coercedValue = coerceInputValue(value, varType);\n    if (coercedValue !== undefined) {\n      coerced[varName] = coercedValue;\n    } else {\n      validateInputValue(\n        value,\n        varType,\n        (error, path) => {\n          onError(\n            new GraphQLError(\n              `Variable \"$${varName}\" has invalid value${printPathArray(path)}: ${\n                error.message\n              }`,\n              { nodes: varDefNode, originalError: error },\n            ),\n          );\n        },\n        hideSuggestions,\n      );\n    }\n  }\n\n  return { sources, coerced };\n}\n\nexport function getFragmentVariableValues(\n  fragmentSpreadNode: FragmentSpreadNode,\n  fragmentSignatures: ReadOnlyObjMap<GraphQLVariableSignature>,\n  variableValues: VariableValues,\n  fragmentVariableValues?: Maybe<VariableValues>,\n  hideSuggestions?: Maybe<boolean>,\n): VariableValues {\n  const varSignatures: Array<GraphQLVariableSignature> = [];\n  const sources = Object.create(null);\n  for (const [varName, varSignature] of Object.entries(fragmentSignatures)) {\n    varSignatures.push(varSignature);\n    sources[varName] = {\n      signature: varSignature,\n      value:\n        fragmentVariableValues?.sources[varName]?.value ??\n        variableValues.sources[varName]?.value,\n    };\n  }\n\n  const coerced = experimentalGetArgumentValues(\n    fragmentSpreadNode,\n    varSignatures,\n    variableValues,\n    fragmentVariableValues,\n    hideSuggestions,\n  );\n\n  return { sources, coerced };\n}\n\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getArgumentValues(\n  def: GraphQLField<unknown, unknown> | GraphQLDirective,\n  node: FieldNode | DirectiveNode,\n  variableValues?: Maybe<VariableValues>,\n  hideSuggestions?: Maybe<boolean>,\n): { [argument: string]: unknown } {\n  return experimentalGetArgumentValues(\n    node,\n    def.args,\n    variableValues,\n    undefined,\n    hideSuggestions,\n  );\n}\n\nexport function experimentalGetArgumentValues(\n  node: FieldNode | DirectiveNode | FragmentSpreadNode,\n  argDefs: ReadonlyArray<GraphQLArgument | GraphQLVariableSignature>,\n  variableValues: Maybe<VariableValues>,\n  fragmentVariableValues?: Maybe<VariableValues>,\n  hideSuggestions?: Maybe<boolean>,\n): { [argument: string]: unknown } {\n  const coercedValues: { [argument: string]: unknown } = {};\n\n  const argumentNodes = node.arguments ?? [];\n  const argNodeMap = new Map(argumentNodes.map((arg) => [arg.name.value, arg]));\n\n  for (const argDef of argDefs) {\n    const name = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap.get(name);\n\n    if (!argumentNode) {\n      if (isRequiredArgument(argDef)) {\n        // Note: ProvidedRequiredArgumentsRule validation should catch this before\n        // execution. This is a runtime check to ensure execution does not\n        // continue with an invalid argument value.\n        throw new GraphQLError(\n          // TODO: clean up the naming of isRequiredArgument(), isArgument(), and argDef if/when experimental fragment variables are merged\n          `Argument \"${isArgument(argDef) ? argDef : argDef.name}\" of required type \"${argType}\" was not provided.`,\n          { nodes: node },\n        );\n      }\n      const coercedDefaultValue = coerceDefaultValue(argDef);\n      if (coercedDefaultValue !== undefined) {\n        coercedValues[name] = coercedDefaultValue;\n      }\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n\n    // Variables without a value are treated as if no argument was provided if\n    // the argument is not required.\n    if (valueNode.kind === Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n      const scopedVariableValues = fragmentVariableValues?.sources[variableName]\n        ? fragmentVariableValues\n        : variableValues;\n      if (\n        (scopedVariableValues == null ||\n          !Object.hasOwn(scopedVariableValues.coerced, variableName)) &&\n        !isRequiredArgument(argDef)\n      ) {\n        const coercedDefaultValue = coerceDefaultValue(argDef);\n        if (coercedDefaultValue !== undefined) {\n          coercedValues[name] = coercedDefaultValue;\n        }\n        continue;\n      }\n    }\n    const coercedValue = coerceInputLiteral(\n      valueNode,\n      argType,\n      variableValues,\n      fragmentVariableValues,\n    );\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      validateInputLiteral(\n        valueNode,\n        argType,\n        (error, path) => {\n          // TODO: clean up the naming of isRequiredArgument(), isArgument(), and argDef if/when experimental fragment variables are merged\n          error.message = `Argument \"${isArgument(argDef) ? argDef : argDef.name}\" has invalid value${printPathArray(\n            path,\n          )}: ${error.message}`;\n          throw error;\n        },\n        variableValues,\n        fragmentVariableValues,\n        hideSuggestions,\n      );\n      /* c8 ignore next */\n      invariant(false, 'Invalid argument');\n    }\n    coercedValues[name] = coercedValue;\n  }\n  return coercedValues;\n}\n\n/**\n * Prepares an object map of argument values given a directive definition\n * and a AST node which may contain directives. Optionally also accepts a map\n * of variable values.\n *\n * If the directive does not exist on the node, returns undefined.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getDirectiveValues(\n  directiveDef: GraphQLDirective,\n  node: { readonly directives?: ReadonlyArray<DirectiveNode> | undefined },\n  variableValues?: Maybe<VariableValues>,\n  fragmentVariableValues?: Maybe<VariableValues>,\n  hideSuggestions?: Maybe<boolean>,\n): undefined | { [argument: string]: unknown } {\n  const directiveNode = node.directives?.find(\n    (directive) => directive.name.value === directiveDef.name,\n  );\n\n  if (directiveNode) {\n    return experimentalGetArgumentValues(\n      directiveNode,\n      directiveDef.args,\n      variableValues,\n      fragmentVariableValues,\n      hideSuggestions,\n    );\n  }\n}\n"]}